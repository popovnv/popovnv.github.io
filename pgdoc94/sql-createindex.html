<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE INDEX</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"><LINK
REL="NEXT"
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEINDEX"
></A
>CREATE INDEX</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN73867"
></A
><H2
>Название</H2
>CREATE INDEX&nbsp;--&nbsp;создать индекс</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN73870"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> ] ON <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ USING <TT
CLASS="REPLACEABLE"
><I
>метод</I
></TT
> ]
    ( { <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ) } [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>класс_операторов</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> [, ... ] ) ]
    [ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
> ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>предикат</I
></TT
> ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN73883"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
> создаёт индексы по указанной колонке(ам) заданного отношения, которым может быть таблица или материализованное представление. Индексы применяются в первую очередь для оптимизации производительности базы данных (хотя при неправильном использовании возможен и противоположный эффект).</P
><P
>Ключевое поле для индекса задаётся как имя колонки или выражение, заключённое в скобки. Если метод индекса поддерживает многоколоночные индексы, допускается указание нескольких полей.</P
><P
>Поле индекса может быть выражением, вычисляемым из значений одной или нескольких колонок в строке таблицы. Это может быть полезно для получения быстрого доступа к данным по некоторому преобразованию исходных значений. Например, индекс, построенный по выражению <TT
CLASS="LITERAL"
>upper(col)</TT
>, позволит использовать поиск по индексу в предложении <TT
CLASS="LITERAL"
>WHERE upper(col) = 'JIM'</TT
>.</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> предоставляет следующие методы индексов: B-дерево, хеш, GiST, SP-GiST и GIN. Пользователи могут определить и собственные методы индексов, но это довольно сложная задача.</P
><P
>Если в команде присутствует предложение <TT
CLASS="LITERAL"
>WHERE</TT
>, она создаёт <I
CLASS="FIRSTTERM"
>частичный индекс</I
>. Такой индекс содержит записи только для части таблицы, обычно более полезной для индексации, чем остальная таблица. Например, если таблица содержит информацию об оплаченных и неоплаченных счетах, при этом последних сравнительно немного, но именно эта часть таблицы наиболее востребована, то увеличить быстродействие можно, создав индекс только по этой части. Ещё одно возможное применение <TT
CLASS="LITERAL"
>WHERE</TT
> — добавив <TT
CLASS="LITERAL"
>UNIQUE</TT
>, обеспечить уникальность в подмножестве таблицы. Подробнее это рассматривается в <A
HREF="indexes-partial.html"
>Разделе 11.8</A
>.</P
><P
>Выражение в предложении <TT
CLASS="LITERAL"
>WHERE</TT
> может ссылаться только на колонки нижележащей таблицы, но не обязательно ограничиваться теми, по которым строится индекс. В настоящее время в <TT
CLASS="LITERAL"
>WHERE</TT
> также нельзя использовать подзапросы и агрегатные выражения. Это же ограничение распространяется и на выражения в полях индексов.</P
><P
>Все функции и операторы, используемые в определении индекса, должны быть <SPAN
CLASS="QUOTE"
>"постоянными"</SPAN
>, то есть, их результаты должны зависеть только от аргументов, но не от внешних факторов (например, содержимого другой таблицы или текущего времени). Это ограничение обеспечивает определённость поведения индекса. Чтобы использовать в выражении индекса или в предложении <TT
CLASS="LITERAL"
>WHERE</TT
> собственную функцию, не забудьте пометить её при создании как постоянную.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN73905"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>UNIQUE</TT
></DT
><DD
><P
>Указывает, что система должна контролировать повторяющиеся значения в таблице при создании индекса (если в таблице уже есть данные) и при каждом добавлении данных. Попытки вставить или изменить данные, при которых будет нарушена уникальность индекса, будут завершаться ошибкой.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CONCURRENTLY</TT
></DT
><DD
><P
>С этим указанием <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> построит индекс, не устанавливая никаких блокировок, которые бы предотвращали добавление, изменение или удаление записей в таблице; тогда как по умолчанию операция построения индекса блокирует запись (но не чтение) в таблице до своего завершения. При создании индекса в параллельном режиме есть ряд особенностей, о которых следует знать &mdash; см. <A
HREF="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY"
><I
>Параллельное построение индексов</I
></A
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></DT
><DD
><P
>Имя создаваемого индекса. Указание схемы при этом не допускается; индекс всегда относится к той же схеме, что и родительская таблица. Если имя опущено, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> формирует подходящее имя по имени родительской таблицы и именам индексируемых колонок.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) индексируемой таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>метод</I
></TT
></DT
><DD
><P
>Имя применяемого метода индекса. Возможные варианты: <TT
CLASS="LITERAL"
>btree</TT
>, <TT
CLASS="LITERAL"
>hash</TT
>, <TT
CLASS="LITERAL"
>gist</TT
>, <TT
CLASS="LITERAL"
>spgist</TT
> и <TT
CLASS="LITERAL"
>gin</TT
>. По умолчанию подразумевается метод <TT
CLASS="LITERAL"
>btree</TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
></DT
><DD
><P
>Имя колонки таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
></DT
><DD
><P
>Выражение с одной или несколькими колонками таблицы. Обычно выражение должно записываться в скобках, как показано в синтаксисе команды. Однако скобки можно опустить, если выражение записано в виде вызова функции.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
></DT
><DD
><P
>Имя правила сортировки, применяемого для индекса. По умолчанию используется правило сортировки, заданное для индексируемой колонки, либо полученное для результата выражения индекса. Индексы с нестандартными правилами сортировки могут быть полезны для запросов, включающих выражения с такими правилами.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>класс_операторов</I
></TT
></DT
><DD
><P
>Имя класса операторов. Подробнее об этом ниже.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ASC</TT
></DT
><DD
><P
>Указывает порядок сортировки по возрастанию (подразумевается по умолчанию).</P
></DD
><DT
><TT
CLASS="LITERAL"
>DESC</TT
></DT
><DD
><P
>Указывает порядок сортировки по убыванию.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS FIRST</TT
></DT
><DD
><P
>Указывает, что значения NULL после сортировки оказываются перед остальными. Это поведение по умолчанию с порядком сортировки <TT
CLASS="LITERAL"
>DESC</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS LAST</TT
></DT
><DD
><P
>Указывает, что значения NULL после сортировки оказываются после остальных. Это поведение по умолчанию с порядком сортировки <TT
CLASS="LITERAL"
>ASC</TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
></DT
><DD
><P
>Имя специфичного для индекса параметра хранения. За подробностями обратитесь к <A
HREF="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS"
><I
>Параметры хранения индекса</I
></A
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
></DT
><DD
><P
>Табличное пространство, в котором будет создан индекс. Если не определено, выбирается <A
HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE"
>default_tablespace</A
>, либо <A
HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES"
>temp_tablespaces</A
>, при создании индекса временной таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>предикат</I
></TT
></DT
><DD
><P
>Выражение ограничения для частичного индекса.</P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-STORAGE-PARAMETERS"
></A
><H3
>Параметры хранения индекса</H3
><P
>Необязательное предложение <TT
CLASS="LITERAL"
>WITH</TT
> определяет <I
CLASS="FIRSTTERM"
>параметры хранения</I
> для индекса. У каждого метода индекса есть свой набор допустимых параметров хранения. Следующий параметр принимают методы B-дерево, хеш, GiST и SP-GiST:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>FILLFACTOR</TT
></DT
><DD
><P
>Фактор заполнения для индекса определяет в процентном отношении, насколько плотно метод индекса будет заполнять страницы индекса. Для B-деревьев концевые страницы заполняются до этого процента при начальном построении индекса и позже, при расширении индекса вправо (добавлении новых наибольших значений ключа). Если страницы впоследствии оказываются заполненными полностью, они будут разделены, что приводит к постепенному снижению эффективности индекса. Для B-деревьев по умолчанию используется фактор заполнения 90, но его можно поменять на любое целое значение от 10 до 100. Фактор заполнения, равный 100, полезен для статических таблиц и помогает уменьшить физический размер таблицы, но для интенсивно изменяемых таблиц лучше использовать меньшее значение, чтобы разделять страницы приходилось реже. С другими методами индекса фактор заполнения действует по-другому, но примерно в том же ключе; значение фактора заполнения по умолчанию для разных методов разное.</P
></DD
></DL
></DIV
><P
>Индексы GiST дополнительно принимают этот параметр:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>BUFFERING</TT
></DT
><DD
><P
>Определяет, будет ли при построении индекса использоваться буферизация, описанная в <A
HREF="gist-implementation.html#GIST-BUFFERING-BUILD"
>Подразделе 56.4.1</A
>. Со значением <TT
CLASS="LITERAL"
>OFF</TT
> она отключена, с <TT
CLASS="LITERAL"
>ON</TT
> — включена, а с <TT
CLASS="LITERAL"
>AUTO</TT
> — отключена вначале, но может затем включиться на ходу, как только размер индекса достигнет значения <A
HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE"
>effective_cache_size</A
>. По умолчанию подразумевается <TT
CLASS="LITERAL"
>AUTO</TT
>.</P
></DD
></DL
></DIV
><P
>Индексы GIN принимают другой параметр:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>FASTUPDATE</TT
></DT
><DD
><P
>Этот параметр управляет механизмом быстрого обновления, описанным в <A
HREF="gin-implementation.html#GIN-FAST-UPDATE"
>Подразделе 58.4.1</A
>. Он имеет логическое значение: <TT
CLASS="LITERAL"
>ON</TT
> включает быстрое обновление, <TT
CLASS="LITERAL"
>OFF</TT
> отключает его. (Другие возможные написания <TT
CLASS="LITERAL"
>ON</TT
> и <TT
CLASS="LITERAL"
>OFF</TT
> перечислены в <A
HREF="config-setting.html"
>Разделе 18.1</A
>.) Значение по умолчанию — <TT
CLASS="LITERAL"
>ON</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Выключение <TT
CLASS="LITERAL"
>FASTUPDATE</TT
> в <TT
CLASS="COMMAND"
>ALTER INDEX</TT
> предотвращает помещение добавляемых в дальнейшем строк в список записей, ожидающих индексации, но записи, добавленные в этот список ранее, в нём остаются. Чтобы очистить очередь операций, надо затем выполнить <TT
CLASS="COMMAND"
>VACUUM</TT
> для этой таблицы.</P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-CONCURRENTLY"
></A
><H3
>Параллельное построение индексов</H3
><P
>Создание индекса может мешать обычной работе с базой данных. Обычно <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> блокирует индексируемую таблицу от записи и выполняет всю операцию построения индекса за одно сканирование таблицы. Другие транзакции могут продолжать читать таблицу, но при попытке вставить, изменить или удалить строки в таблице они будут заблокированы до завершения построения индекса. Это может оказать нежелательное влияние на работу производственной базы данных. Индексация очень больших таблиц может занимать много часов, и даже для маленьких таблиц построение индекса может заблокировать записывающие процессы на время, неприемлемое для производственной системы.</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> поддерживает построение индексов без блокировки записи. Этот метод выбирается указанием <TT
CLASS="LITERAL"
>CONCURRENTLY</TT
> команды <TT
CLASS="COMMAND"
>CREATE INDEX</TT
>. Когда он используется, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> должен выполнить два сканирования таблицы, а кроме того, должен дождаться завершения всех существующих транзакций, которые потенциально могут использовать этот индекс. Таким образом, эта процедура требует проделать в сумме больше действий и выполняется значительно дольше, чем обычное построение индекса. Однако благодаря тому, что этот метод позволяет продолжать обычную работу с базой во время построения индекса, он оказывается полезным в производственной среде. Хотя разумеется, дополнительная нагрузка на процессор и подсистему ввода/вывода, создаваемая при построении индекса, может привести к замедлению других операций.</P
><P
>При параллельном построении индекса он попадает в системный каталог в одной транзакции, затем ещё два сканирования таблицы выполняются в двух других транзакциях. Любая транзакция, активная в момент начала второго сканирования таблицы, может заблокировать параллельное создание индекса до своего окончания, даже если эта транзакция обратилась к таблице уже после начала второго сканирования. Процедура параллельного создания индекса последовательно ожидает завершения всех старых транзакций, применяя подход, описанный в разделе <A
HREF="view-pg-locks.html"
>Раздел 48.60</A
>.</P
><P
>Если при сканировании таблицы возникает проблема, например взаимоблокировка или нарушение уникальности в уникальном индексе, команда <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> завершится ошибкой, но оставит после себя <SPAN
CLASS="QUOTE"
>"нерабочий"</SPAN
> индекс. Этот индекс будет игнорироваться при чтении данных, так как он может быть неполным; однако с ним могут быть связаны дополнительные операции при изменениях. В <SPAN
CLASS="APPLICATION"
>psql</SPAN
>
    встроенная команда <TT
CLASS="COMMAND"
>\d</TT
> помечает такой индекс как <TT
CLASS="LITERAL"
>INVALID</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers 
--------+---------+-----------
 col    | integer | 
Indexes:
    "idx" btree (col) INVALID</PRE
><P> Рекомендуемый в таких случаях способ исправления ситуации — удалить индекс и затем попытаться снова выполнить <TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>. (Кроме того, можно перестроить его с помощью команды <TT
CLASS="COMMAND"
>REINDEX</TT
>. Но так как <TT
CLASS="COMMAND"
>REINDEX</TT
> не поддерживает параллельный режим, вряд ли этот вариант будет желательным.)</P
><P
>Ещё одна сложность, с которой можно столкнуться при параллельном построении уникального индекса, заключается в том, что ограничение уникальности уже влияет на другие транзакции, когда второе сканирование таблицы только начинается. Это значит, что нарушения ограничения могут проявляться в других запросах до того, как индекс становится доступным для использования и даже тогда, когда создать индекс в итоге не удаётся. Кроме того, если при втором сканировании происходит ошибка, <SPAN
CLASS="QUOTE"
>"нерабочий"</SPAN
> индекс оставляет в силе своё ограничение уникальности и дальше.</P
><P
>Метод параллельного построения поддерживает также индексы выражений и частичные индексы. Ошибки, произошедшие при вычислении этих выражений, могут привести к такому же поведению, как в вышеописанных случаях с нарушением ограничений уникальности.</P
><P
>Обычное построение индекса допускает одновременное построение других индексов обычным методом, но параллельное построение в один момент времени допускается только одно. В обоих случаях, никакие изменения типов в схеме таблицы в это время не разрешаются. Другое отличие состоит в том, что в блоке транзакции может быть выполнена обычная команда <TT
CLASS="COMMAND"
>CREATE INDEX</TT
>, но не <TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN74075"
></A
><H2
>Замечания</H2
><P
>Информацию о том, когда могут применяться, и когда не применяются индексы, и в каких конкретных ситуациях они могут быть полезны, можно найти в <A
HREF="indexes.html"
>Главе 11</A
>.</P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Предостережение</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Операции с хеш-индексами в настоящее время не проходят через WAL, так что после аварийной остановки базы данных может потребоваться перестроить хеш-индексы командой <TT
CLASS="COMMAND"
>REINDEX</TT
>. Кроме того, изменения в хеш-индексах после начальной копии не переносятся при потоковой или файловой репликации, так что в последующих запросах они будут давать неправильные ответы. По этим причинам настоятельно рекомендуется не использовать их.</P
></TD
></TR
></TABLE
></DIV
><P
>В настоящее время многоколоночные индексы поддерживают только методы B-дерево, GiST и GIN. По умолчанию такой индекс может включать до 32 полей. (Этот предел можно изменить, пересобрав <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.) Уникальные индексы поддерживает только B-дерево.</P
><P
>Для каждой колонки индекса можно задать <I
CLASS="FIRSTTERM"
>класс операторов</I
>. Этот класс определяет, какие операторы будут использоваться индексом для этой колонки. Например, индекс-B-дерево по четырёхбайтовым целым будет использовать класс <TT
CLASS="LITERAL"
>int4_ops</TT
>; этот класс операторов включает функции сравнения для таких значений. На практике обычно достаточно использовать класс операторов по умолчанию для типа данных колонки. Существование классов операторов объясняется в первую очередь тем, что для некоторых типов данных можно предложить более одного осмысленного порядка сортировки. Например, может возникнуть желание отсортировать комплексные числа как по абсолютному значению, так и по вещественной части. Это можно сделать, определив два класса операторов для типа данных и выбрав подходящий класс при создании индекса. За дополнительными сведениями о классах операторов обратитесь к <A
HREF="indexes-opclass.html"
>Разделу 11.9</A
> и <A
HREF="xindex.html"
>Разделу 35.14</A
>.</P
><P
>Для методов индекса, поддерживающих сканирование по порядку (в настоящее время это поддерживает только B-дерево), можно изменить порядок сортировки индекса, добавив необязательные предложения <TT
CLASS="LITERAL"
>ASC</TT
>, <TT
CLASS="LITERAL"
>DESC</TT
>, <TT
CLASS="LITERAL"
>NULLS FIRST</TT
> или <TT
CLASS="LITERAL"
>NULLS LAST</TT
>. Так как упорядоченный индекс можно сканировать вперёд или назад, обычно не имеет смысла создавать индекс по убыванию (<TT
CLASS="LITERAL"
>DESC</TT
>) для одной колонки &mdash; этот порядок сортировки можно получить и с обычным индексом. Эти параметры имеют смысл при создании многоколоночных индексов так, что они будут соответствовать порядку сортировки, указанному в запросе со смешанным порядком, например <TT
CLASS="LITERAL"
>SELECT ... ORDER BY x ASC, y DESC</TT
>. Параметры <TT
CLASS="LITERAL"
>NULLS</TT
> полезны, когда требуется реализовать поведение <SPAN
CLASS="QUOTE"
>"NULL внизу"</SPAN
>, изменив стандартное <SPAN
CLASS="QUOTE"
>"NULL вверху"</SPAN
>, в запросах, зависящих от индексов, чтобы избежать дополнительной сортировки.</P
><P
>Для большинства методов индексов скорость создания индекса зависит от значения <A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>. При увеличении этого значения индекс будет создаваться быстрее, пока оно не превысит действительно доступный объём памяти, что приведёт к использованию подкачки. Для хеш-индексов значение <A
HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE"
>effective_cache_size</A
> также влияет на время создания индекса: <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет использовать один из двух различных методов создания индекса, в зависимости от того, больше или меньше оцениваемый размер индекса, чем <TT
CLASS="VARNAME"
>effective_cache_size</TT
>. Для наилучших результатов этот параметр нужно устанавливать в зависимости от объёма свободной памяти, но так, чтобы сумма <TT
CLASS="VARNAME"
>maintenance_work_mem</TT
> и <TT
CLASS="VARNAME"
>effective_cache_size</TT
> была меньше объёма ОЗУ за вычетом объёма, необходимого другим программам.</P
><P
>Для удаления индекса применяется <A
HREF="sql-dropindex.html"
>DROP INDEX</A
>.</P
><P
>В предыдущих выпусках <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> также поддерживался метод индекса R-дерево. Сейчас он отсутствует, так как он не даёт значительных преимуществ по сравнению с GiST. Указание <TT
CLASS="LITERAL"
>USING rtree</TT
> команда <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> будет интерпретировать как <TT
CLASS="LITERAL"
>USING gist</TT
>, для упрощения перевода старых баз на GiST.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN74113"
></A
><H2
>Примеры</H2
><P
>Создание индекса-B-дерева по колонке <TT
CLASS="LITERAL"
>title</TT
> в таблице <TT
CLASS="LITERAL"
>films</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title);</PRE
><P></P
><P
>Создание индекса по выражению <TT
CLASS="LITERAL"
>lower(title)</TT
>, позволяющего эффективно выполнять регистронезависимый поиск: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX ON films ((lower(title)));</PRE
><P> (В этом примере мы решили опустить имя индекса, чтобы имя выбрала система, например <TT
CLASS="LITERAL"
>films_lower_idx</TT
>.)</P
><P
>Создание индекса с нестандартным правилом сортировки: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</PRE
><P></P
><P
>Создание индекса с нестандартным порядком значений NULL: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</PRE
><P></P
><P
>Создание индекса с нестандартным фактором заполнения: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</PRE
><P></P
><P
>Создание индекса <ACRONYM
CLASS="ACRONYM"
>GIN</ACRONYM
> с отключённым механизмом быстрого обновления: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX gin_idx ON documents_table USING gin (locations) WITH (fastupdate = off);</PRE
><P></P
><P
>Создание индекса по колонке <TT
CLASS="LITERAL"
>code</TT
> в таблице <TT
CLASS="LITERAL"
>films</TT
> и размещение его в табличном пространстве <TT
CLASS="LITERAL"
>indexspace</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</PRE
><P></P
><P
>Создание индекса GiST по координатам точек, позволяющего эффективно использовать операторы box с результатом функции преобразования: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</PRE
><P></P
><P
>Создание индекса без блокировки записи в таблицу: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN74141"
></A
><H2
>Совместимость</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
> является языковым расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Средства обеспечения индексов в стандарте SQL не описаны.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN74146"
></A
><H2
>См. также</H2
><A
HREF="sql-alterindex.html"
>ALTER INDEX</A
>, <A
HREF="sql-dropindex.html"
>DROP INDEX</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-creategroup.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE GROUP</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE LANGUAGE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>