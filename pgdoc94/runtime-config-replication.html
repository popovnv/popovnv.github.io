<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Репликация</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Настройка сервера"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Журнал упреждающей записи"
HREF="runtime-config-wal.html"><LINK
REL="NEXT"
TITLE="Планирование запросов"
HREF="runtime-config-query.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Журнал упреждающей записи"
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 18. Настройка сервера</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Планирование запросов"
HREF="runtime-config-query.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-REPLICATION"
>18.6. Репликация</A
></H1
><P
>Эти параметры управляют поведением встроенного механизма <I
CLASS="FIRSTTERM"
>потоковой репликации</I
> (см. <A
HREF="warm-standby.html#STREAMING-REPLICATION"
>Подраздел 25.2.5</A
>). Когда он применяется, один сервер является главным, а другие — резервными. Главный сервер всегда передаёт данные, а резервные всегда принимают данные репликации, но когда настроена каскадная репликация (см. <A
HREF="warm-standby.html#CASCADING-REPLICATION"
>Подраздел 25.2.7</A
>), резервные серверы также могут быть и передающими. Следующие параметры в основном относятся к передающим и резервным серверам, хотя некоторые параметры имеют смысл только для главного. Все эти параметры вполне могут быть разными в рамках одного кластера, если это требуется.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-SENDER"
>18.6.1. Передающие серверы</A
></H2
><P
>Эти параметры можно задать на любом сервере, который передаёт данные репликации одному или нескольким резервным. Главный сервер всегда является передающим, так что на нём они должны задаваться всегда. Роль и значение этих параметров не меняются после того, как резервный сервер становится главным.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-WAL-SENDERS"
></A
><TT
CLASS="VARNAME"
>max_wal_senders</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимально допустимое число одновременных подключений резервных серверов или клиентов потокового копирования (т. е. максимальное количество одновременно работающих процессов передачи WAL). По умолчанию это значение равно нулю, то есть репликация отключается. Передающие WAL процессы учитываются в общем числе соединений, так что этот параметр не может превышать <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>. В случае неожиданного отключения клиента потоковой передачи слот подключения может оставаться занятым до достижения таймаута, так что этот параметр должен быть немного больше максимального ожидаемого числа клиентов, чтобы отключившиеся клиенты могли переподключиться немедленно. Задать этот параметр можно только при запуске сервера. Чтобы к данному серверу могли подключаться резервные, уровень <TT
CLASS="VARNAME"
>wal_level</TT
> должен быть <TT
CLASS="LITERAL"
>archive</TT
> или выше.</P
></DD
><DT
><A
NAME="GUC-MAX-REPLICATION-SLOTS"
></A
><TT
CLASS="VARNAME"
>max_replication_slots</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число слотов репликации (см. <A
HREF="warm-standby.html#STREAMING-REPLICATION-SLOTS"
>Подраздел 25.2.6</A
>), которое сможет поддерживать сервер. Значение по умолчанию — ноль. Этот параметр можно задать только при запуске сервера. Чтобы эти слоты репликации можно было использовать, уровень <TT
CLASS="VARNAME"
>wal_level</TT
> должен быть <TT
CLASS="LITERAL"
>archive</TT
> или выше. Если заданное значение данного параметра будет меньше, чем число уже существующих слотов репликации, сервер не запустится.</P
></DD
><DT
><A
NAME="GUC-WAL-KEEP-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>wal_keep_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт минимальное число файлов прошлых сегментов журнала, которые будут сохраняться в каталоге <TT
CLASS="FILENAME"
>pg_xlog</TT
>, чтобы резервный сервер мог выбрать их при потоковой репликации. Обычно сегмент имеет размер 16 мегабайт. Если резервный сервер, подключённый к передающему, отстаёт больше чем на <TT
CLASS="VARNAME"
>wal_keep_segments</TT
> сегментов, передающий удаляет сегменты WAL, всё ещё необходимые резервному, и в этом случае соединение репликации прерывается. В результате этого затем также будут прерваны зависимые соединения. (Однако резервный сервер сможет восстановиться, выбрав этот сегмент из архива, если осуществляется архивация WAL.)</P
><P
>Этот параметр задаёт только минимальное число сегментов, сохраняемое в каталоге <TT
CLASS="FILENAME"
>pg_xlog</TT
>; система может сохранить больше сегментов для архивации WAL или для восстановления с момента контрольной точки. Если <TT
CLASS="VARNAME"
>wal_keep_segments</TT
> равен нулю (это значение по умолчанию), система не сохраняет никакие дополнительные сегменты для резервных серверов, поэтому число старых сегментов WAL, доступных для резервных серверов, зависит от положения предыдущей контрольной точи и состояния архивации WAL. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-WAL-SENDER-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>wal_sender_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные соединения репликации. Это помогает передающему серверу обнаружить сбой резервного или разрывы в сети. При значении, равном нулю, таймаут отключается. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. Значение по умолчанию — 60 секунд.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-MASTER"
>18.6.2. Главный сервер</A
></H2
><P
>Эти параметры можно задать на главном/ведущем сервере, который должен передавать данные репликации одному или нескольким резервным. Заметьте, что помимо этих параметров на главном сервере должен быть правильно установлен <A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
>, а также может быть включена архивация WAL (см. <A
HREF="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING"
>Подраздел 18.5.3</A
>). Значения этих параметров на резервных серверах не важны, хотя их можно подготовить заранее, на случай, если резервный сервер придётся сделать главным.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SYNCHRONOUS-STANDBY-NAMES"
></A
><TT
CLASS="VARNAME"
>synchronous_standby_names</TT
> (<TT
CLASS="TYPE"
>string</TT
>) </DT
><DD
><P
>Определяет список имён резервных серверов через запятую, которые могут поддерживать <I
CLASS="FIRSTTERM"
>синхронную репликацию</I
>, как описано в <A
HREF="warm-standby.html#SYNCHRONOUS-REPLICATION"
>Подразделе 25.2.8</A
>. В любое время будет активен максимум один активный синхронный резервный сервер; транзакции, ожидающие фиксирования, завершаются только после того, как этот сервер подтверждает получение данных. Синхронным резервным сервером будет первый сервер в этом списке, который подключён в данный момент и принимает данные в реальном времени (что показывает признак <TT
CLASS="LITERAL"
>streaming</TT
> в представлении <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
><TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
>). Следующие резервные серверы в этом списке являются потенциальными синхронными серверами. Если текущий синхронный сервер отключается по какой-либо причине, он немедленно заменяется следующим резервным в этом списке. Таким образом, указание нескольких имён позволяет обеспечить очень высокую степень доступности.</P
><P
>В качестве имени резервного сервера в данном случае указывается значение параметра <TT
CLASS="VARNAME"
>application_name</TT
>, задаваемое в строке подключения <TT
CLASS="VARNAME"
>primary_conninfo</TT
> на резервном сервере, принимающем WAL. Уникальность этих имён не контролируется. В случае дублирования имён синхронным резервным сервером станет один из серверов с подходящим именем, хотя какой именно, не определено. Специальному указанию <TT
CLASS="LITERAL"
>*</TT
> соответствует любое имя приложения (<TT
CLASS="VARNAME"
>application_name</TT
>), включая имя приложения по умолчанию (<TT
CLASS="LITERAL"
>walreceiver</TT
>).</P
><P
>Если имена синхронных резервных серверов не определены, синхронная репликация не включается и фиксируемые транзакции не будут ждать репликации. Это поведение по умолчанию. Даже когда синхронная репликация включена, для отдельных транзакций можно отключить ожидание репликации, задав для параметра <A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
> значение <TT
CLASS="LITERAL"
>local</TT
> или <TT
CLASS="LITERAL"
>off</TT
>.</P
><P
>Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-VACUUM-DEFER-CLEANUP-AGE"
></A
><TT
CLASS="VARNAME"
>vacuum_defer_cleanup_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт число транзакций, на которое будет отложена очистка старых версий строк при <TT
CLASS="COMMAND"
>VACUUM</TT
> и изменениях <ACRONYM
CLASS="ACRONYM"
>HOT</ACRONYM
>. По умолчанию это число равно нулю, то есть старые версии строк могут удаляться сразу, как только перестанут быть видимыми в открытых транзакциях. Это значение можно сделать ненулевым на главном сервере, работающим с серверами горячего резерва, как описано в <A
HREF="hot-standby.html"
>Разделе 25.5</A
>. В результате увеличится время, в течение которого будут успешно выполняться запросы на резервном сервере без конфликтов из-за ранней очистки строк. Однако ввиду того, что эта отсрочка определяется числом записывающих транзакций, выполняющихся на главном сервере, сложно предсказать, каким будет дополнительное время отсрочки на резервном сервере. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
><P
>В качестве альтернативы этому параметру можно также рассмотреть <TT
CLASS="VARNAME"
>hot_standby_feedback</TT
> на резервном сервере.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-STANDBY"
>18.6.3. Резервные серверы</A
></H2
><P
>Эти параметры управляют поведением резервного сервера, который будет получать данные репликации. На главном сервере они не играют никакой роли.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-HOT-STANDBY"
></A
><TT
CLASS="VARNAME"
>hot_standby</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Определяет, можно ли будет подключаться к серверу и выполнять запросы в процессе восстановления, как описано в <A
HREF="hot-standby.html"
>Разделе 25.5</A
>. Значение по умолчанию — <TT
CLASS="LITERAL"
>off</TT
> (подключения не разрешаются). Задать этот параметр можно только при запуске сервера. Данный параметр играет роль только в режиме резервного сервера или при восстановлении архива.</P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-ARCHIVE-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>В режиме горячего резерва этот параметр определяет, как долго должен ждать резервный сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>Подразделе 25.5.2</A
>. Задержка <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> применяется при обработке данных WAL, считываемых из архива (не текущих данных). Значение этого параметра задаётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секундам. При значении, равном -1, резервный сервер может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
><P
>Заметьте, что параметр <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из одного сегмента WAL. Таким образом, если один запрос привёл к значительной задержке при обработке сегмента WAL, остальным конфликтующим запросам будет отведено гораздо меньше времени.</P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-STREAMING-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>В режиме горячего резерва этот параметр определяет, как долго должен ждать резервный сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>Подразделе 25.5.2</A
>. Задержка <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> применяется при обработке данных WAL, поступающих при потоковой репликации. Значение этого параметра задаётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секундам. При значении, равном -1, резервный сервер может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
><P
>Заметьте, что параметр <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из WAL после получения от главного сервера. Таким образом, если один запрос привёл к значительной задержке, остальным конфликтующим запросам будет отводиться гораздо меньше времени, пока резервный сервер не догонит главный.</P
></DD
><DT
><A
NAME="GUC-WAL-RECEIVER-STATUS-INTERVAL"
></A
><TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Определяет минимальную частоту, с которой процесс, принимающий WAL на резервном сервере, будет сообщать о состоянии репликации ведущему или вышестоящему резервному, где это состояние можно наблюдать в представлении <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
><TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
>. В этом сообщении передаются следующие позиции в журнале транзакций: позиция изменений записанных, изменений, сохранённых на диске, и изменений применённых. Значение параметра задаётся в секундах и определяет максимальный интервал между сообщениями. Сообщения о состоянии передаются при каждом продвижении позиций записанных или сохранённых на диске изменений, но с промежутком не больше, чем заданный этим параметром. Таким образом, последняя переданная позиция применённых изменений может немного отставать от фактической в текущий момент. При нулевом значении этого параметра передача состояния полностью отключается. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. По умолчанию его значение равно 10 секундам.</P
></DD
><DT
><A
NAME="GUC-HOT-STANDBY-FEEDBACK"
></A
><TT
CLASS="VARNAME"
>hot_standby_feedback</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Определяет, будет ли сервер горячего резерва сообщать ведущему или вышестоящему резервному о запросах, которые он выполняет в данный момент. Это позволяет исключить необходимость отмены запросов, вызванную очисткой записей, но при некоторых типах нагрузки это может приводить к раздуванию базы данных на ведущем сервере. Эти сообщения о запросах будут отправляться не чаще, чем раз в интервал, задаваемый параметром <TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
>. Значение данного параметра по умолчанию — <TT
CLASS="LITERAL"
>off</TT
>. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
><P
>Если используется каскадная репликация, сообщения о запросах передаются выше, пока в итоге не достигнут ведущего сервера. На промежуточных серверах эта информация больше никак не задействуется.</P
></DD
><DT
><A
NAME="GUC-WAL-RECEIVER-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>wal_receiver_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные соединения репликации. Это помогает принимающему резервному серверу обнаружить сбой ведущего узла или разрыв сети. При значении, равном нулю, таймаут отключается. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. Значение по умолчанию — 60 секунд.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-query.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Журнал упреждающей записи</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Планирование запросов</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>