<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Журнал упреждающей записи</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Настройка сервера"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Потребление ресурсов"
HREF="runtime-config-resource.html"><LINK
REL="NEXT"
TITLE="Репликация"
HREF="runtime-config-replication.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Потребление ресурсов"
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 18. Настройка сервера</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Репликация"
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-WAL"
>18.5. Журнал упреждающей записи</A
></H1
><P
>За дополнительной информацией о настройке этих параметров обратитесь к <A
HREF="wal-configuration.html"
>Разделу 29.4</A
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-SETTINGS"
>18.5.1. Параметры</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-WAL-LEVEL"
></A
><TT
CLASS="VARNAME"
>wal_level</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Параметр <TT
CLASS="VARNAME"
>wal_level</TT
> определяет, как много информации записывается в WAL. Со значением <TT
CLASS="LITERAL"
>minimal</TT
> (по умолчанию) в журнал записывается только информация, необходимая для восстановления после сбоя или аварийного отключения. Вариант <TT
CLASS="LITERAL"
>archive</TT
> добавляет информацию, необходимую для архивирования WAL; <TT
CLASS="LITERAL"
>hot_standby</TT
> включает дополнительную информацию, необходимую для выполнения запросов на резервном сервере в режиме &laquo;только чтение&raquo;; и наконец, <TT
CLASS="LITERAL"
>logical</TT
> добавляет информацию, требуемую для поддержки логического декодирования. Каждый последующий уровень включают всю информацию, записываемую на всех предыдущих. Задать этот параметр можно только при запуске сервера.</P
><P
>На уровне <TT
CLASS="LITERAL"
>minimal</TT
> некоторые массовые операции могут выполняться в обход журнала без риска потери данных, и при этом они выполнятся гораздо быстрее (см. <A
HREF="populate.html#POPULATE-PITR"
>Подраздел 14.4.7</A
>). В частности, такая оптимизация возможна с операциями: <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE TABLE AS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CLUSTER</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>COPY</TT
> с таблицами, которые были созданы или опустошены в той же транзакции</TD
></TR
></TBODY
></TABLE
><P
></P
> Однако такой минимальный журнал не будет содержать достаточно информации для восстановления данных из базовой копии и журналов, поэтому для реализации стратегии архивации WAL (см. <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
>) и потоковой репликации необходим уровень <TT
CLASS="LITERAL"
>archive</TT
> или более высокий.</P
><P
>На уровне <TT
CLASS="LITERAL"
>hot_standby</TT
> в журнал записывается та же информация, что и на уровне <TT
CLASS="LITERAL"
>archive</TT
>, плюс информация, необходимая для восстановления состояния работающих транзакций из WAL. Чтобы на резервном сервере можно было выполнять запросы &laquo;только на чтение&raquo;, на ведущем <TT
CLASS="VARNAME"
>wal_level</TT
> должен быть не ниже <TT
CLASS="LITERAL"
>hot_standby</TT
>, а на резервном необходимо установить параметр <A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY"
>hot_standby</A
>. По нашему убеждению, уровни <TT
CLASS="LITERAL"
>hot_standby</TT
> и <TT
CLASS="LITERAL"
>archive</TT
> не должны значительно отличаться по быстродействию, поэтому если в вашей среде проявятся серьёзные различия, мы хотели бы узнать об этом.</P
><P
>На уровне <TT
CLASS="LITERAL"
>logical</TT
> в журнал записывается та же информация, что и на уровне <TT
CLASS="LITERAL"
>hot_standby</TT
>, плюс информация, необходимая для извлечения из журнала наборов логических изменений. Повышение уровня до <TT
CLASS="LITERAL"
>logical</TT
> приводит к значительному увеличению объёма WAL, особенно если многие таблицы имеют характеристику <TT
CLASS="LITERAL"
>REPLICA IDENTITY FULL</TT
> и выполняется множество команд <TT
CLASS="COMMAND"
>UPDATE</TT
> и <TT
CLASS="COMMAND"
>DELETE</TT
>.</P
></DD
><DT
><A
NAME="GUC-FSYNC"
></A
><TT
CLASS="VARNAME"
>fsync</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Если этот параметр установлен, сервер <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> старается добиться, чтобы изменения были записаны на диск физически, выполняя системные вызовы <CODE
CLASS="FUNCTION"
>fsync()</CODE
> или другими подобными методами (см. <A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
>). Это даёт гарантию, что кластер баз данных сможет вернуться в согласованное состояние после сбоя оборудования или операционной системы.</P
><P
>Хотя отключение <TT
CLASS="VARNAME"
>fsync</TT
> часто даёт выигрыш в скорости, это может привести к неисправимой порче данных в случае отключения питания или сбоя системы. Поэтому отключать <TT
CLASS="VARNAME"
>fsync</TT
> рекомендуется, только если вы легко сможет восстановить всю базу из внешнего источника.</P
><P
>В качестве примеров, когда отключение <TT
CLASS="VARNAME"
>fsync</TT
> неопасно, можно привести начальное наполнение нового кластера данными из копии, обработку массива данных, после которой базу данных можно удалить и создать заново, либо эксплуатацию копии базы данных только для чтения, которая регулярно пересоздаётся и не используется для отработки отказа. Качественное оборудование само по себе не является достаточной причиной для отключения <TT
CLASS="VARNAME"
>fsync</TT
>.</P
><P
>При смене значения <TT
CLASS="VARNAME"
>fsync</TT
> с off на on для надёжного восстановления также необходимо сбросить все изменённые буферы из ядра в надёжное хранилище. Это можно сделать, когда сервер остановлен или когда режим fsync включён, с помощью команды <TT
CLASS="COMMAND"
>initdb --sync-only</TT
>, либо выполнить команду <TT
CLASS="COMMAND"
>sync</TT
>, размонтировать файловую систему или перезагрузить сервер.</P
><P
>Во многих случаях отключение <A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
> для некритичных транзакций может дать больший выигрыш в скорости, чем отключение <TT
CLASS="VARNAME"
>fsync</TT
>, при этом не добавляя риски повреждения данных.</P
><P
>Параметр <TT
CLASS="VARNAME"
>fsync</TT
> можно задать только в файле <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. Если вы отключаете этот параметр, возможно, имеет смысл отключить также и <A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>.</P
></DD
><DT
><A
NAME="GUC-SYNCHRONOUS-COMMIT"
></A
><TT
CLASS="VARNAME"
>synchronous_commit</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Определяет, будет ли сервер при фиксировании транзакции ждать, пока записи из WAL сохранятся на диске, прежде чем сообщить клиенту об успешном завершении операции. Допустимые значения: <TT
CLASS="LITERAL"
>on</TT
>, <TT
CLASS="LITERAL"
>remote_write</TT
>, <TT
CLASS="LITERAL"
>local</TT
> и <TT
CLASS="LITERAL"
>off</TT
>. Значение по умолчанию (оно же самое безопасное) — <TT
CLASS="LITERAL"
>on</TT
>. Со значением <TT
CLASS="LITERAL"
>off</TT
> может образоваться окно от момента, когда клиент узнаёт об успешном завершении, до момента, когда транзакция действительно гарантированно защищена от сбоя. (Максимальный размер окна равен тройному значению <A
HREF="runtime-config-wal.html#GUC-WAL-WRITER-DELAY"
>wal_writer_delay</A
>.) В отличие от <A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>, значение <TT
CLASS="LITERAL"
>off</TT
> для этого параметра не угрожает целостности данных: сбой операционной системы или базы данных может привести к потере последних транзакций, считавшихся зафиксированными, но состояние базы данных будет точно таким же, как и в случае штатного прерывания этих транзакций. Поэтому выключение режима <TT
CLASS="VARNAME"
>synchronous_commit</TT
> может быть полезной альтернативой отключению <A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>, когда производительность важнее, чем надёжная гарантия сохранности каждой транзакции. Подробнее это обсуждается в <A
HREF="wal-async-commit.html"
>Разделе 29.3</A
>.</P
><P
>Если задано значение <A
HREF="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES"
>synchronous_standby_names</A
>, этот параметр также определяет, будет ли сервер при фиксировании транзакции ждать, пока выполнится репликация записей WAL для данной транзакции на резервный сервер. Со значением <TT
CLASS="LITERAL"
>on</TT
> фиксирование завершается только после получения ответа от текущего синхронного резервного сервера, подтверждающего, что он получил запись о фиксировании транзакции и сохранил её на диске. Это гарантирует, что транзакция не будет потеряна, если только база данных не будет повреждена и на главном, и на резервном сервере. Со значением <TT
CLASS="LITERAL"
>remote_write</TT
> фиксирование завершается после получения ответа от текущего синхронного резервного сервера, подтверждающего, что он получил запись о фиксировании транзакции и передал её операционной системе (хотя эти данные могут ещё не достичь надёжного хранилища на нём). Этот вариант позволяет гарантировать сохранность данных в случае отказа резервного сервера <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, но не в случае сбоя на уровне операционной системы.</P
><P
>Когда применяется синхронная репликация, обычно имеет смысл либо ждать сохранения на локальный диск и репликации записей WAL, либо разрешить асинхронное фиксирование транзакций. Если же требуется ждать завершения сохранения на локальный диск, но не синхронной репликации, такое поведение обеспечивает вариант <TT
CLASS="LITERAL"
>local</TT
>. Если параметр <TT
CLASS="VARNAME"
>synchronous_standby_names</TT
> не задан, варианты <TT
CLASS="LITERAL"
>on</TT
>, <TT
CLASS="LITERAL"
>remote_write</TT
> и <TT
CLASS="LITERAL"
>local</TT
> реализуют одинаковый уровень синхронизации: при фиксировании транзакции сервер ждёт только сохранения данных на локальный диск.</P
><P
>Этот параметр можно изменить в любое время; поведение каждой конкретной транзакции определяется значением, действующим в момент её фиксирования. Таким образом, есть возможность и смысл фиксировать некоторые транзакции синхронно, а другие — асинхронно. Например, чтобы зафиксировать одну транзакцию из нескольких команд асинхронно, когда по умолчанию выбран противоположный вариант, выполните в этой транзакции <TT
CLASS="COMMAND"
>SET LOCAL synchronous_commit TO OFF</TT
>.</P
></DD
><DT
><A
NAME="GUC-WAL-SYNC-METHOD"
></A
><TT
CLASS="VARNAME"
>wal_sync_method</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Метод, применяемый для принудительного сохранения изменений WAL на диске. Если режим <TT
CLASS="VARNAME"
>fsync</TT
> отключён, данный параметр не действует, так как принудительное сохранение изменений WAL не производится вовсе. Возможные значения этого параметра:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>open_datasync</TT
> (для сохранения файлов WAL открывать их функцией <CODE
CLASS="FUNCTION"
>open()</CODE
> с параметром <TT
CLASS="SYMBOL"
>O_DSYNC</TT
>)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>fdatasync</TT
> (вызывать <CODE
CLASS="FUNCTION"
>fdatasync()</CODE
> при каждом фиксировании)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>fsync</TT
> (вызывать <CODE
CLASS="FUNCTION"
>fsync()</CODE
> при каждом фиксировании)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>fsync_writethrough</TT
> (вызывать <CODE
CLASS="FUNCTION"
>fsync()</CODE
> при каждом фиксировании, форсируя сквозную запись кеша)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>open_sync</TT
> (для сохранения файлов WAL открывать их функцией <CODE
CLASS="FUNCTION"
>open()</CODE
> с параметром <TT
CLASS="SYMBOL"
>O_SYNC</TT
>)</P
></LI
></UL
><P
>Варианты <TT
CLASS="LITERAL"
>open_</TT
>* также применяют флаг <TT
CLASS="LITERAL"
>O_DIRECT</TT
>, если он доступен. Не все эти методы поддерживается в разных системах. По умолчанию выбирается первый из этих методов, который поддерживается текущей системой, с одним исключением — в Linux по умолчанию выбирается <TT
CLASS="LITERAL"
>fdatasync</TT
>. Выбираемый по умолчанию вариант не обязательно будет идеальным; в зависимости от требований к отказоустойчивости или производительности может потребоваться скорректировать выбранное значение или внести другие изменения в конфигурацию вашей системы. Соответствующие аспекты конфигурации рассматриваются в <A
HREF="wal-reliability.html"
>Разделе 29.1</A
>. Этот параметр можно задать только в файле <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-FULL-PAGE-WRITES"
></A
><TT
CLASS="VARNAME"
>full_page_writes</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Когда этот параметр включён, сервер <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки. Это необходимо, потому что запись страницы, прерванная при сбое операционной системы, может выполниться частично, и на диске окажется страница, содержащая смесь старых данных с новыми. При этом информации об изменениях на уровне строк, которая обычно сохраняется в WAL, будет недостаточно для получения согласованного содержимого такой страницы при восстановлении после сбоя. Сохранение образа всей страницы гарантирует, что страницу можно восстановить корректно, ценой увеличения объёма данных, которые будут записываться в WAL. (Так как воспроизведение WAL всегда начинается от контрольной точки, достаточно сделать это при первом изменении каждой страницы после контрольной точки. Таким образом, уменьшить затраты на запись полных страниц можно, увеличив интервалы контрольных точек.)</P
><P
>Отключение этого параметра ускоряет обычные операции, но может привести к неисправимому повреждению или незаметной порче данных после сбоя системы. Так как при этом возникают практически те же риски, что и при отключении <TT
CLASS="VARNAME"
>fsync</TT
>, хотя и в меньшей степени, отключать его следует только при тех же обстоятельствах, которые перечислялись в рекомендациях для вышеописанного параметра.</P
><P
>Отключение этого параметра не влияет на возможность применения архивов WAL для восстановления состояния на момент времени (см. <A
HREF="continuous-archiving.html"
>Раздел 24.3</A
>).</P
><P
>Этот параметр можно задать только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. По умолчанию этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
>.</P
></DD
><DT
><A
NAME="GUC-WAL-LOG-HINTS"
></A
><TT
CLASS="VARNAME"
>wal_log_hints</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Когда этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
>, сервер <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки, даже при второстепенных изменениях так называемых вспомогательных битов.</P
><P
>Если включён расчёт контрольных сумм данных, изменения вспомогательных битов всегда проходят через WAL и этот параметр игнорируется. С помощью этого параметра можно проверить, насколько больше дополнительной информации записывалось бы в журнал, если бы для базы данных был включён подсчёт контрольных сумм.</P
><P
>Этот параметр можно задать только при запуске сервера. По умолчанию он имеет значение <TT
CLASS="LITERAL"
>off</TT
>.</P
></DD
><DT
><A
NAME="GUC-WAL-BUFFERS"
></A
><TT
CLASS="VARNAME"
>wal_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё не записанных на диск. Значение по умолчанию, равное -1, задаёт размер, равный 1/32 (около 3%) от <A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>, но не меньше, чем <TT
CLASS="LITERAL"
>64 КБ</TT
> и не больше, чем размер одного сегмента WAL (обычно <TT
CLASS="LITERAL"
>16 МБ</TT
>). Это значение можно задать вручную, если выбираемое автоматически слишком мало или велико, но при этом любое положительное число меньше <TT
CLASS="LITERAL"
>32 КБ</TT
> будет восприниматься как <TT
CLASS="LITERAL"
>32 КБ</TT
>. Этот параметр можно задать только при запуске сервера.</P
><P
>Содержимое буферов WAL записывается на диск при фиксировании каждой транзакции, так что очень большие значения вряд ли принесут значительную пользу. Однако значение как минимум в несколько мегабайт может увеличить быстродействие при записи на нагруженном сервере, когда сразу множество клиентов фиксируют транзакции. Автонастройка, действующая при значении по умолчанию (-1), в большинстве случаев выбирает разумные значения.</P
></DD
><DT
><A
NAME="GUC-WAL-WRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>wal_writer_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт задержку между раундами активности процесса записи WAL. В каждом таком раунде этот процесс сохраняет WAL на диск, затем делает паузу на <TT
CLASS="VARNAME"
>wal_writer_delay</TT
> миллисекунд, а затем всё повторяется снова. По умолчанию выбирается задержка 200 миллисекунд (<TT
CLASS="LITERAL"
>200ms</TT
>). Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <TT
CLASS="VARNAME"
>wal_writer_delay</TT
> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-COMMIT-DELAY"
></A
><TT
CLASS="VARNAME"
>commit_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Параметр <TT
CLASS="VARNAME"
>commit_delay</TT
> добавляет паузу (в микросекундах) перед собственно выполнением сохранения WAL. Эта задержка может увеличить быстродействие при фиксировании множества транзакций, позволяя зафиксировать большее число транзакций за одну операции сохранения WAL, если система нагружена достаточно сильно и за заданное время успевают зафиксироваться другие транзакции. Однако этот параметр также увеличивает задержку максимум до <TT
CLASS="VARNAME"
>commit_delay</TT
> микросекунд при каждом сохранении WAL. Эта задержка окажется бесполезной, если никакие другие транзакции не будут зафиксированы за это время, поэтому она добавляется, только в если момент запроса сохранения WAL активны как минимум <TT
CLASS="VARNAME"
>commit_siblings</TT
> других транзакций. Кроме того, эти задержки не добавляются при выключенном <TT
CLASS="VARNAME"
>fsync</TT
>. По умолчанию значение <TT
CLASS="VARNAME"
>commit_delay</TT
> равно нулю (задержка отсутствует). Изменить этот параметр могут только суперпользователи.</P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 9.3, параметр <TT
CLASS="VARNAME"
>commit_delay</TT
> работал по-другому и не так эффективно: он задерживал только фиксирование транзакций, а не все операции сохранения WAL, и заданная пауза выдерживалась полностью, даже если WAL удавалось сохранить быстрее. Начиная с версии 9.3, заданное время ожидает только первый процесс, готовый произвести сохранение, тогда как все последующие процессы ждут только, когда он закончит эту операцию.</P
></DD
><DT
><A
NAME="GUC-COMMIT-SIBLINGS"
></A
><TT
CLASS="VARNAME"
>commit_siblings</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Минимальное число одновременно открытых транзакций, при котором будет добавляться задержка <TT
CLASS="VARNAME"
>commit_delay</TT
>. Чем больше это значение, тем больше вероятность, что минимум одна транзакция окажется готовой к фиксированию за время задержки. По умолчанию это число равно пяти.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-CHECKPOINTS"
>18.5.2. Контрольные точки</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-CHECKPOINT-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>checkpoint_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Максимальное число сегментов файлов журнала между автоматическими контрольными точками в WAL (сегмент обычно имеет размер 16 мегабайт). По умолчанию это значение равно 3. Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Максимальное время между автоматическими контрольными точками в WAL (в секундах). По умолчанию оно равно пяти минутам (<TT
CLASS="LITERAL"
>5min</TT
>). Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-COMPLETION-TARGET"
></A
><TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт целевое время для завершения процедуры контрольной точки, как коэффициент для общего времени между контрольными точками. По умолчанию это значение равно 0.5. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-WARNING"
></A
><TT
CLASS="VARNAME"
>checkpoint_warning</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Записывать в журнал сервера сообщение в случае, если контрольные точки, вызванные заполнением файлов сегментов, выполняются раньше, чем через заданное число секунд (что говорит о том, что значение <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> нужно увеличить). Значение по умолчание равно 30 секундам (<TT
CLASS="LITERAL"
>30s</TT
>). При нуле это предупреждение отключается. Если <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> меньше, чем <TT
CLASS="VARNAME"
>checkpoint_warning</TT
>, предупреждения так же не будут выводиться. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-ARCHIVING"
>18.5.3. Архивация</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-ARCHIVE-MODE"
></A
><TT
CLASS="VARNAME"
>archive_mode</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Когда параметр <TT
CLASS="VARNAME"
>archive_mode</TT
> включён, полные сегменты WAL передаются в хранилище архива командой <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>. Параметры <TT
CLASS="VARNAME"
>archive_mode</TT
> и <TT
CLASS="VARNAME"
>archive_command</TT
> разделены, чтобы команду архивации (<TT
CLASS="VARNAME"
>archive_command</TT
>) можно было изменять, не отключая режим архивации. Этот параметр можно задать только при запуске сервера. Режим архивации нельзя включить, когда установлен минимальный уровень WAL (<TT
CLASS="VARNAME"
>wal_level</TT
> имеет значение <TT
CLASS="LITERAL"
>minimal</TT
>).</P
></DD
><DT
><A
NAME="GUC-ARCHIVE-COMMAND"
></A
><TT
CLASS="VARNAME"
>archive_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>) </DT
><DD
><P
>Команда локальной оболочки, которая будет выполняться для архивации завершённого сегмента WAL. Любое вхождение <TT
CLASS="LITERAL"
>%p</TT
> в этой строке заменяется путём архивируемого файла, а вхождение <TT
CLASS="LITERAL"
>%f</TT
> заменяется только его именем. (Путь задаётся относительно рабочего каталога сервера, то есть каталога данных кластера.) Чтобы вставить в команду символ <TT
CLASS="LITERAL"
>%</TT
>, его нужно записать как <TT
CLASS="LITERAL"
>%%</TT
>. Важно, чтобы команда возвращала нулевой код выхода, только если она завершается успешно. За дополнительной информацией обратитесь к <A
HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL"
>Подразделу 24.3.1</A
>.</P
><P
>Этот параметр можно задать только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера. Если режим архивации (<TT
CLASS="VARNAME"
>archive_mode</TT
>) не был включён при запуске, этот параметр игнорируется. Если значение <TT
CLASS="VARNAME"
>archive_command</TT
> — пустая строка (по умолчанию), но <TT
CLASS="VARNAME"
>archive_mode</TT
> включён, архивация WAL временно отключается, но сервер продолжает накапливать файлы сегментов WAL в ожидании, что команда будет вскоре определена. Если в качестве <TT
CLASS="VARNAME"
>archive_command</TT
> задать команду, которая ничего не делает, но сообщает об успешном завершении, например <TT
CLASS="LITERAL"
>/bin/true</TT
> (или <TT
CLASS="LITERAL"
>REM</TT
> в Windows), архивация по сути отключается, но при этом нарушается цепочка файлов WAL, необходимых для восстановления архива, поэтому такой вариант следует использовать только в особых случаях.</P
></DD
><DT
><A
NAME="GUC-ARCHIVE-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>archive_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Команда <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
> вызывается только для завершённых сегментов WAL. Поэтому, если ваш сервер записывает мало данных WAL (или это наблюдается в некоторые периоды времени), от завершения транзакции до надёжного сохранения её в архивном хранилище может пройти довольно много времени. Для ограничения времени существования неархивированных данных можно установить значение <TT
CLASS="VARNAME"
>archive_timeout</TT
>, чтобы сервер периодически переключался на новый файл сегмента WAL. Когда этот параметр больше нуля, сервер будет переключаться на новый файл сегмента, если с момента последнего переключения на новый файл пройдёт заданное число секунд, и наблюдалась какая-то активность базы данных, даже если это была просто контрольная точка. (Для сокращения числа ненужных контрольных точек в простаивающей системе можно увеличить <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>.) Заметьте, что архивируемые файлы, закрываемые раньше из-за принудительного переключения, всё равно будут иметь тот же размер, что и полностью заполненные. Поэтому устанавливать для <TT
CLASS="VARNAME"
>archive_timeout</TT
> очень маленькое значение неразумно &mdash; это ведёт к замусориванию архивного хранилища. Обычно для <TT
CLASS="VARNAME"
>archive_timeout</TT
> имеет смысл задавать значение около минуты. Если вам нужно, чтобы данные копировались с главного сервера на резервный, вам следует подумать о переходе от архивации к потоковой репликации. Этот параметр можно задать только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Потребление ресурсов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Репликация</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>