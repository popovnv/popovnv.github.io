<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>intarray</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Дополнительно поставляемые модули"
HREF="contrib.html"><LINK
REL="PREVIOUS"
TITLE="intagg"
HREF="intagg.html"><LINK
REL="NEXT"
TITLE="isn"
HREF="isn.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="intagg"
HREF="intagg.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="contrib.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Приложение E. Дополнительно поставляемые модули</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="isn"
HREF="isn.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTARRAY"
>E.18. intarray</A
></H1
><P
>Модуль <TT
CLASS="FILENAME"
>intarray</TT
> предоставляет ряд полезных функций и операторов для работы с массивами целых чисел без NULL. Также он поддерживает поиск по индексу для некоторых из этих операторов.</P
><P
>Все эти операции выдают ошибку, если в передаваемом массиве оказываются значения NULL.</P
><P
>Многие из этих операций имеют смысл только с одномерными массивами. Хоти им можно передать входной массив и большей размерности, значения будут считываться из него как из линейного массива в порядке хранения.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121384"
>E.18.1. Функции и операторы <TT
CLASS="FILENAME"
>intarray</TT
></A
></H2
><P
>Реализованные в модуле <TT
CLASS="FILENAME"
>intarray</TT
> функции перечислены в <A
HREF="intarray.html#INTARRAY-FUNC-TABLE"
>Таблице E-8</A
>, а операторы — в <A
HREF="intarray.html#INTARRAY-OP-TABLE"
>Таблице E-9</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="INTARRAY-FUNC-TABLE"
></A
><P
><B
>Таблица E-8. Функции <TT
CLASS="FILENAME"
>intarray</TT
></B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Тип результата</TH
><TH
>Описание</TH
><TH
>Пример</TH
><TH
>Результат</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>icount(int[])</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
><TD
>число элементов в массиве</TD
><TD
>                    <TT
CLASS="LITERAL"
>icount('{1,2,3}'::int[])</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>3</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>sort(int[], text dir)</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>сортирует массив &mdash; в <TT
CLASS="PARAMETER"
>dir</TT
> должно задаваться <TT
CLASS="LITERAL"
>asc</TT
> (по возрастанию) или <TT
CLASS="LITERAL"
>desc</TT
> (по убыванию)</TD
><TD
>                    <TT
CLASS="LITERAL"
>sort('{1,2,3}'::int[], 'desc')</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{3,2,1}</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>sort(int[])</CODE
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>сортирует в порядке возрастания</TD
><TD
>                    <TT
CLASS="LITERAL"
>sort(array[11,77,44])</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{11,44,77}</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>sort_asc(int[])</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>сортирует в порядке возрастания</TD
><TD
>                    <TT
CLASS="LITERAL"
></TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
></TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>sort_desc(int[])</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>сортирует в порядке убывания</TD
><TD
>                    <TT
CLASS="LITERAL"
></TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
></TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>uniq(int[])</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>удаляет дубликаты</TD
><TD
>                    <TT
CLASS="LITERAL"
>uniq(sort('{1,2,3,2,1}'::int[]))</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{1,2,3}</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>idx(int[], int item)</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
><TD
>индекс первого элемента, равного <TT
CLASS="PARAMETER"
>item</TT
> (0, если такого нет)</TD
><TD
>                    <TT
CLASS="LITERAL"
>idx(array[11,22,33,22,11], 22)</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>2</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>subarray(int[], int start, int len)</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>часть массива, начинающаяся с позиции <TT
CLASS="PARAMETER"
>start</TT
> и состоящая из <TT
CLASS="PARAMETER"
>len</TT
> элементов</TD
><TD
>                    <TT
CLASS="LITERAL"
>subarray('{1,2,3,2,1}'::int[], 2, 3)</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{2,3,2}</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>subarray(int[], int start)</CODE
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>часть массива, начинающаяся с позиции <TT
CLASS="PARAMETER"
>start</TT
></TD
><TD
>                    <TT
CLASS="LITERAL"
>subarray('{1,2,3,2,1}'::int[], 2)</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{2,3,2,1}</TT
>
                  </TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>intset(int)</CODE
></TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>создаёт массив с одним элементом</TD
><TD
>                    <TT
CLASS="LITERAL"
>intset(42)</TT
>
                  </TD
><TD
>                    <TT
CLASS="LITERAL"
>{42}</TT
>
                  </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="INTARRAY-OP-TABLE"
></A
><P
><B
>Таблица E-9. Операторы <TT
CLASS="FILENAME"
>intarray</TT
></B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Оператор</TH
><TH
>Возвращает</TH
><TH
>Описание</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] &amp;&amp; int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
>пересекается с &mdash; <TT
CLASS="LITERAL"
>true</TT
>, если массивы имеют минимум один общий элемент</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] @&gt; int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
>включает &mdash; <TT
CLASS="LITERAL"
>true</TT
>, если левый массив содержит правый массив</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] &lt;@ int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
>включается в &mdash; <TT
CLASS="LITERAL"
>true</TT
>, если левый массив содержится в правом массиве</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
># int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
><TD
>число элементов в массиве</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] # int</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
><TD
>индекс элемента (делает то же, что и функция <CODE
CLASS="FUNCTION"
>idx</CODE
>)</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] + int</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>вставляет элемент в массив (добавляет его в конец массива)</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] + int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>соединяет массивы (правый массив добавляется в конец левого)</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] - int</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>удаляет из массива записи, равные правому аргументу</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] - int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>удаляет из левого массива элементы правого массива</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] | int</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>объединение аргументов</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] | int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>объединение массивов</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] &amp; int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int[]</TT
>
                  </TD
><TD
>пересечение массивов</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>int[] @@ query_int</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
><TT
CLASS="LITERAL"
>true</TT
>, если массив удовлетворяет запросу (см. ниже)</TD
></TR
><TR
><TD
>                    <TT
CLASS="LITERAL"
>query_int ~~ int[]</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
><TT
CLASS="LITERAL"
>true</TT
>, если запросу удовлетворяет массив (коммутирующий оператор к <TT
CLASS="LITERAL"
>@@</TT
>)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>(До версии PostgreSQL 8.2 операторы включения <TT
CLASS="LITERAL"
>@&gt;</TT
> и <TT
CLASS="LITERAL"
>&lt;@</TT
> обозначались соответственно как <TT
CLASS="LITERAL"
>@</TT
> и <TT
CLASS="LITERAL"
>~</TT
>. Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упразднены. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые геометрические типы данных!)</P
><P
>Операторы <TT
CLASS="LITERAL"
>&amp;&amp;</TT
>, <TT
CLASS="LITERAL"
>@&gt;</TT
> и <TT
CLASS="LITERAL"
>&lt;@</TT
> равнозначны встроенным операторам <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> с теми же именами, за исключением того, что они работают только с целочисленными массивами, не содержащими NULL, тогда как встроенные операторы работают с массивами любых типов. Благодаря этому ограничению, в большинстве случаев они работают быстрее, чем встроенные операторы.</P
><P
>Операторы <TT
CLASS="LITERAL"
>@@</TT
> и <TT
CLASS="LITERAL"
>~~</TT
> проверяют, удовлетворяет ли массив <I
CLASS="FIRSTTERM"
>запросу</I
>, представляемому в виде значения специализированного типа данных <TT
CLASS="TYPE"
>query_int</TT
>. <I
CLASS="FIRSTTERM"
>Запрос</I
> содержит целочисленные значения, сравниваемые с элементами массива, возможно с использованием операторов <TT
CLASS="LITERAL"
>&amp;</TT
> (AND), <TT
CLASS="LITERAL"
>|</TT
> (OR) и <TT
CLASS="LITERAL"
>!</TT
> (NOT). При необходимости могут использоваться скобки. Например, запросу <TT
CLASS="LITERAL"
>1&amp;(2|3)</TT
> удовлетворяют запросы, которые содержат 1 и также содержат 2 или 3.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121647"
>E.18.2. Поддержка индексов</A
></H2
><P
>Модуль <TT
CLASS="FILENAME"
>intarray</TT
> поддерживает индексы для операторов <TT
CLASS="LITERAL"
>&amp;&amp;</TT
>, <TT
CLASS="LITERAL"
>@&gt;</TT
>, <TT
CLASS="LITERAL"
>&lt;@</TT
> и <TT
CLASS="LITERAL"
>@@</TT
>, а также обычную проверку равенства массивов.</P
><P
>Модуль предоставляет два класса операторов GiST: <TT
CLASS="LITERAL"
>gist__int_ops</TT
> (используется по умолчанию), подходящий для маленьких и средних по размеру наборов данных, и <TT
CLASS="LITERAL"
>gist__intbig_ops</TT
>, применяющий сигнатуру большего размера и подходящий для индексации больших наборов данных (то есть колонок, содержащих много различных значений массива). В этой реализации используется структура данных RD-дерева со встроенным сжатием с потерями.</P
><P
>Есть также нестандартный класс операторов GIN, <TT
CLASS="LITERAL"
>gin__int_ops</TT
>, поддерживающий те же операторы.</P
><P
>Выбор между индексами GiST и GIN зависит от относительных характеристик производительности GiST и GIN, которые здесь не рассматриваются. Как правило, индекс GIN быстрее индекса GiST при поиске, но строится или обновляется он медленнее; поэтому GIN лучше подходит для статических, а GiST для часто изменяемых данных.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121661"
>E.18.3. Пример</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>-- сообщение может относиться к одной или нескольким <SPAN
CLASS="QUOTE"
>"секциям"</SPAN
>
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- создать специализированный индекс
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- вывести сообщения из секций 1 или 2 — оператор пересечения
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- вывести сообщения из секций 1 и 2 — оператор включения
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- тот же результат, но с оператором запроса
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121665"
>E.18.4. Тестирование производительности</A
></H2
><P
>В каталоге исходного кода <TT
CLASS="FILENAME"
>contrib/intarray/bench</TT
> содержится набор тестов производительности. Чтобы запустить эти тесты, выполните:</P
><PRE
CLASS="PROGRAMLISTING"
>cd .../bench
createdb TEST
psql TEST &lt; ../_int.sql
./create_test.pl | psql TEST
./bench.pl</PRE
><P
>Скрипт <TT
CLASS="FILENAME"
>bench.pl</TT
> принимает несколько аргументов, о которых можно узнать, запустив его без аргументов.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121672"
>E.18.5. Авторы</A
></H2
><P
>Разработку осуществили Фёдор Сигаев (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:teodor@sigaev.ru"
>teodor@sigaev.ru</A
>&#62;</CODE
>) и Олег Бартунов (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:oleg@sai.msu.su"
>oleg@sai.msu.su</A
>&#62;</CODE
>). Дополнительные сведения можно найти на странице <A
HREF="http://www.sai.msu.su/~megera/postgres/gist/"
TARGET="_top"
>http://www.sai.msu.su/~megera/postgres/gist/</A
>. Андрей Октябрьский проделал отличную работу, добавив новые функции и операторы.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="intagg.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="isn.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>intagg</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="contrib.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>isn</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>