<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Потребление ресурсов</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Настройка сервера"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Подключения и аутентификация"
HREF="runtime-config-connection.html"><LINK
REL="NEXT"
TITLE="Журнал упреждающей записи"
HREF="runtime-config-wal.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Подключения и аутентификация"
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 18. Настройка сервера</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Журнал упреждающей записи"
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-RESOURCE"
>18.4. Потребление ресурсов</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-MEMORY"
>18.4.1. Память</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SHARED-BUFFERS"
></A
><TT
CLASS="VARNAME"
>shared_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. По умолчанию это обычно 128 мегабайт (<TT
CLASS="LITERAL"
>128MB</TT
>), но может быть и меньше, если конфигурация вашего ядра накладывает дополнительные ограничения (это определяется в процессе <SPAN
CLASS="APPLICATION"
>initdb</SPAN
>). Это значение не должно быть меньше 128 килобайт. (Этот минимум зависит от величины <TT
CLASS="SYMBOL"
>BLCKSZ</TT
>.) Однако для хорошей производительности обычно требуются гораздо большие значения. Задать этот параметр можно только при запуске сервера.</P
><P
>Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным значением <TT
CLASS="VARNAME"
>shared_buffers</TT
> будет 25% от объёма памяти. Существуют варианты нагрузки, при которых эффективны будут и ещё большие значения <TT
CLASS="VARNAME"
>shared_buffers</TT
>, но так как <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> использует и кеш операционной системы, выделять для <TT
CLASS="VARNAME"
>shared_buffers</TT
> более 40% ОЗУ вряд ли будет полезно. При увеличении <TT
CLASS="VARNAME"
>shared_buffers</TT
> обычно требуется соответственно увеличить <TT
CLASS="VARNAME"
>checkpoint_segments</TT
>, чтобы растянуть процесс записи большого объёма новых или изменённых данных на более продолжительное время.</P
><P
>В серверах с объёмом ОЗУ меньше 1ГБ следует использовать меньший процент ОЗУ, чтобы оставить достаточно памяти для операционной системы. Кроме того, большие значения <TT
CLASS="VARNAME"
>shared_buffers</TT
> не так эффективны в Windows. Возможно, вы получите лучшие результаты, если оставите это значение относительно небольшим и будете больше полагаться на кеш операционной системы. Оптимальные значения <TT
CLASS="VARNAME"
>shared_buffers</TT
> для Windows обычно лежат в интервале от 64 до 512 мегабайт.</P
></DD
><DT
><A
NAME="GUC-HUGE-PAGES"
></A
><TT
CLASS="VARNAME"
>huge_pages</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Включает/отключает использование огромных страниц памяти. Допустимые значения: <TT
CLASS="LITERAL"
>try</TT
> (попытаться, по умолчанию), <TT
CLASS="LITERAL"
>on</TT
> (вкл.) и <TT
CLASS="LITERAL"
>off</TT
> (выкл.).</P
><P
>В настоящее время это поддерживается только в Linux. В других системах значение <TT
CLASS="LITERAL"
>try</TT
> просто игнорируется.</P
><P
>В результате использования огромных страниц уменьшаются таблицы страниц и сокращается время, которое тратит процессор на управление памятью. За подробностями обратитесь к <A
HREF="kernel-resources.html#LINUX-HUGE-PAGES"
>Подразделу 17.4.4</A
>.</P
><P
>Когда <TT
CLASS="VARNAME"
>huge_pages</TT
> имеет значение <TT
CLASS="LITERAL"
>try</TT
>, сервер попытается использовать огромные страницы, но может переключиться на обычные, если это не удастся. Со значением <TT
CLASS="LITERAL"
>on</TT
>, если использовать огромные страницы не получится, сервер не будет запущен. Со значением <TT
CLASS="LITERAL"
>off</TT
> огромные страницы использоваться не будут.</P
></DD
><DT
><A
NAME="GUC-TEMP-BUFFERS"
></A
><TT
CLASS="VARNAME"
>temp_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число временных буферов для каждого сеанса, По умолчанию объём временных буферов составляет восемь мегабайт (1024 буфера). Этот параметр можно изменить в отдельном сеансе, но только до первого обращения к временным таблицам; после этого изменить его значение для текущего сеанса не удастся.</P
><P
>Сеанс выделяет временные буферы по мере необходимости до достижения предела, заданного параметром <TT
CLASS="VARNAME"
>temp_buffers</TT
>. Если сеанс не задействует временные буферы, то для него хранятся только дескрипторы буферов, которые занимает около 64 байтов (в количестве <TT
CLASS="VARNAME"
>temp_buffers</TT
>). Однако если буфер действительно используется, он будет дополнительно занимать 8192 байта (или в общем случае, <TT
CLASS="SYMBOL"
>BLCKSZ</TT
> байтов).</P
></DD
><DT
><A
NAME="GUC-MAX-PREPARED-TRANSACTIONS"
></A
><TT
CLASS="VARNAME"
>max_prepared_transactions</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число транзакций, которые могут одновременно находиться в <SPAN
CLASS="QUOTE"
>"подготовленном"</SPAN
> состоянии (см. <A
HREF="sql-prepare-transaction.html"
>PREPARE TRANSACTION</A
>). При нулевом значении (по умолчанию) механизм подготовленных транзакций отключается. Задать этот параметр можно только при запуске сервера.</P
><P
>Если использовать транзакции не планируется, этот параметр следует обнулить, чтобы не допустить непреднамеренного создания подготовленных транзакций. Если же подготовленные транзакции применяются, то <TT
CLASS="VARNAME"
>max_prepared_transactions</TT
>, вероятно, должен быть не меньше, чем <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>, чтобы подготовить транзакцию можно было в каждом сеансе.</P
><P
>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</P
></DD
><DT
><A
NAME="GUC-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт объём памяти, который будет использоваться для внутренних операций сортировки и хеш-таблиц, прежде чем будут задействованы временные файлы на диске. Значение по умолчанию — четыре мегабайта (<TT
CLASS="LITERAL"
>4MB</TT
>). Заметьте, что в сложных запросах одновременно могут выполняться несколько операций сортировки или хеширования, так что этот объём памяти будет доступен для каждой операции. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение <TT
CLASS="VARNAME"
>work_mem</TT
>; это следует учитывать, выбирая подходящее значение. Операции сортировки используются для <TT
CLASS="LITERAL"
>ORDER BY</TT
>, <TT
CLASS="LITERAL"
>DISTINCT</TT
> и соединений слиянием. Хеш-таблицы используются при соединениях и агрегировании по хешу, а также обработке подзапросов <TT
CLASS="LITERAL"
>IN</TT
> с применением хеша.</P
></DD
><DT
><A
NAME="GUC-MAINTENANCE-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>maintenance_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальный объём памяти для операций обслуживания БД, в частности <TT
CLASS="COMMAND"
>VACUUM</TT
>, <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> и <TT
CLASS="COMMAND"
>ALTER TABLE ADD FOREIGN KEY</TT
>. По умолчанию его значение — 64 мегабайта (<TT
CLASS="LITERAL"
>64MB</TT
>). Так как в один момент времени в сеансе может выполняться только одна такая операция, и обычно они не запускаются параллельно, это значение вполне может быть гораздо больше <TT
CLASS="VARNAME"
>work_mem</TT
>. Увеличение этого значения может привести к ускорению операций очистки и восстановления БД из копии.</P
><P
>Учтите, что когда выполняется автоочистка, этот объём может быть выделен <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
> раз, поэтому не стоит устанавливать значение по умолчанию слишком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно, изменяя <A
HREF="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM"
>autovacuum_work_mem</A
>.</P
></DD
><DT
><A
NAME="GUC-AUTOVACUUM-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>autovacuum_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальный объём памяти, который будет использовать каждый рабочий процесс автоочистки. По умолчанию равен -1, что означает, что этот объём определяется значением <A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>. Этот параметр не влияет на поведение команды <TT
CLASS="COMMAND"
>VACUUM</TT
>, выполняемой в других контекстах.</P
></DD
><DT
><A
NAME="GUC-MAX-STACK-DEPTH"
></A
><TT
CLASS="VARNAME"
>max_stack_depth</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальную безопасную глубину стека для исполнителя. В идеале это значение должно равняться предельному размеру стека, ограниченному ядром (как устанавливает команда <TT
CLASS="LITERAL"
>ulimit -s</TT
> или равнозначные ей), за вычетом запаса примерно в мегабайт. Этот запас необходим, потому что сервер проверяет глубину стека не в каждой процедуре, а только в потенциально рекурсивных процедурах, например, при вычислении выражений. Значение по умолчанию — два мегабайта (<TT
CLASS="LITERAL"
>2MB</TT
>), выбрано с большим запасом, так что риск переполнения стека минимален. Однако, с другой стороны, его может быть недостаточно для выполнения сложных функций. Изменить этот параметр могут только суперпользователи.</P
><P
>Если <TT
CLASS="VARNAME"
>max_stack_depth</TT
> будет превышать фактический предел ядра, то функция с неограниченной рекурсией сможет вызвать крах отдельного процесса сервера. В системах, где <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может определить предел, установленный ядром, он не позволит установить для этого параметра небезопасное значение. Однако эту информацию выдают не все системы, поэтому выбирать это значение следует с осторожностью.</P
></DD
><DT
><A
NAME="GUC-DYNAMIC-SHARED-MEMORY-TYPE"
></A
><TT
CLASS="VARNAME"
>dynamic_shared_memory_type</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Выбирает механизм динамической разделяемой памяти, который будет использовать сервер. Допустимые варианты: <TT
CLASS="LITERAL"
>posix</TT
> (для выделения разделяемой памяти POSIX функцией <TT
CLASS="LITERAL"
>shm_open</TT
>), <TT
CLASS="LITERAL"
>sysv</TT
> (для выделения разделяемой памяти System V функцией <TT
CLASS="LITERAL"
>shmget</TT
>), <TT
CLASS="LITERAL"
>windows</TT
> (для выделения разделяемой памяти в Windows), <TT
CLASS="LITERAL"
>mmap</TT
> (для эмуляции разделяемой памяти через отображение в память файлов, хранящихся в каталоге данных) и <TT
CLASS="LITERAL"
>none</TT
> (для отключения этой функциональности). Не все варианты поддерживаются на разных платформах; первый из поддерживаемых данной платформой вариантов становится для неё вариантом по умолчанию. Применять <TT
CLASS="LITERAL"
>mmap</TT
>, который нигде не выбирается по умолчанию, вообще не рекомендуется, так как операционная система может периодически записывать на диск изменённые страницы, что создаст дополнительную нагрузку; однако, это может быть полезно для отладки, когда каталог <TT
CLASS="LITERAL"
>pg_dynshmem</TT
> находится в RAM-диске или когда другие механизмы разделяемой памяти недоступны.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-DISK"
>18.4.2. Диск</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-TEMP-FILE-LIMIT"
></A
><TT
CLASS="VARNAME"
>temp_file_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальный объём дискового пространства, который сможет использовать один сеанс для временных файлов, например, при сортировке и хешировании, или для сохранения удерживаемого курсора. Транзакция, которая попытается превысить этот предел, будет отменена. Этот параметр задаётся в килобайтах, а значение <TT
CLASS="LITERAL"
>-1</TT
> (по умолчанию) означает, что предел отсутствует. Изменить этот параметр могут только суперпользователи.</P
><P
>Этот параметр ограничивает общий объём, который могут занимать в момент времени все временные файлы, задействованные в данном сеансе <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Следует отметить, что при этом учитывается только место, занимаемое явно создаваемыми временными таблицами; на временные файлы, которые создаются неявно при выполнении запроса, это ограничение <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> распространяется.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-KERNEL"
>18.4.3. Использование ресурсов ядра</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-FILES-PER-PROCESS"
></A
><TT
CLASS="VARNAME"
>max_files_per_process</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число файлов, которые могут быть одновременно открыты каждым серверным подпроцессом. Значение по умолчанию — 1000 файлов. Если ядро реализует безопасное ограничение по процессам, об этом параметре можно не беспокоиться. Но на некоторых платформах (а именно, в большинстве систем BSD) ядро позволяет отдельному процессу открыть больше файлов, чем могут открыть несколько процессов одновременно. Если вы столкнётесь с ошибками <SPAN
CLASS="QUOTE"
>"Too many open files"</SPAN
> (Слишком много открытых файлов), попробуйте уменьшить это число. Задать этот параметр можно только при запуске сервера.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-VACUUM-COST"
>18.4.4. Задержка очистки по стоимости</A
></H2
><P
>Во время выполнения команд <A
HREF="sql-vacuum.html"
>VACUUM</A
> и <A
HREF="sql-analyze.html"
>ANALYZE</A
> система ведёт внутренний счётчик, в котором суммирует оцениваемую стоимость различных выполняемых операций ввода/вывода. Когда накопленная стоимость превышает предел (<TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
>), процесс, выполняющий эту операцию, засыпает на некоторое время (<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>). Затем счётчик сбрасывается и процесс продолжается.</P
><P
>Данный подход реализован для того, чтобы администраторы могли снизить влияние этих команд на параллельную работу с базой, за счёт уменьшения нагрузки на подсистему ввода-вывода. Очень часто не имеет значения, насколько быстро выполнятся команды обслуживания (например, <TT
CLASS="COMMAND"
>VACUUM</TT
> и <TT
CLASS="COMMAND"
>ANALYZE</TT
>), но очень важно, чтобы они как можно меньше влияли на выполнение других операций с базой данных. Администраторы имеют возможность управлять этим, настраивая задержку очистки по стоимости.</P
><P
>По умолчанию этот режим отключён для выполняемых вручную команд <TT
CLASS="COMMAND"
>VACUUM</TT
>. Чтобы включить его, нужно установить в <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> ненулевое значение.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-VACUUM-COST-DELAY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Продолжительность времени, в миллисекундах, в течение которого будет простаивать процесс, превысивший предел стоимости. По умолчанию его значение равно нулю, то есть задержка очистки отсутствует. При положительных значениях интенсивность очистки будет зависеть от стоимости. Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10.</P
><P
>При настройке интенсивности очистки для <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> обычно выбираются довольно небольшие значения, например 10 или 20 миллисекунд. Чтобы точнее ограничить потребление ресурсов при очистке, лучше всего изменять другие параметры стоимости очистки.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-HIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_hit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Примерная стоимость очистки буфера, оказавшегося в общем кеше. Это подразумевает блокировку пула буферов, поиск в хеш-таблице и сканирование содержимого страницы. По умолчанию этот параметр равен одному.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-MISS"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_miss</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Примерная стоимость очистки буфера, который нужно прочитать с диска. Это подразумевает блокировку пула буферов, поиск в хеш-таблице, чтение требуемого блока с диска и сканирование его содержимого. По умолчанию этот параметр равен 10.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-DIRTY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_dirty</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Примерная стоимость очистки, при которой изменяется блок, не модифицированный ранее. В неё включается дополнительная стоимость ввода/вывода, связанная с записью изменённого блока на диск. По умолчанию этот параметр равен 20.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-LIMIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Общая стоимость, при накоплении которой процесс очистки будет засыпать. По умолчанию этот параметр равен 200.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Некоторые операции устанавливают критические блокировки и поэтому должны завершаться как можно быстрее. Во время таких операций задержка очистки по стоимости не осуществляется, так что накопленная за это время стоимость может намного превышать установленный предел. Во избежание ненужных длительных задержек в таких случаях, фактическая задержка вычисляется по формуле <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * <TT
CLASS="VARNAME"
>accumulated_balance</TT
> / <TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
> и ограничивается максимумом, равным <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * 4.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER"
>18.4.5. Фоновая запись</A
></H2
><P
>В числе специальных процессов сервера есть процесс <I
CLASS="FIRSTTERM"
>фоновой записи</I
>, задача которого — осуществлять запись <SPAN
CLASS="QUOTE"
>"грязных"</SPAN
> (новых или изменённых) общих буферов на диск. Он старается записывать данные из буферов так, чтобы обычным серверным процессам, обрабатывающим запросы, не приходилось ждать записи или это ожидание было минимальным. Однако процесс фоновой записи увеличивает общую нагрузку на подсистему ввода/вывода, так как он может записывать неоднократно изменяемую страницу при каждом изменении, тогда как она может быть записана всего раз в контрольной точке. Параметры, рассматриваемые в данном подразделе, позволяют настроить поведение фоновой записи для конкретных нужд.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-BGWRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>bgwriter_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт задержку между раундами активности процесса фоновой записи. Во время раунда этот процесс осуществляет запись некоторого количество загрязнённых буферов (это настраивается следующими параметрами). Затем он засыпает на время <TT
CLASS="VARNAME"
>bgwriter_delay</TT
> (задаваемое в миллисекундах), и всё повторяется снова. Однако если в пуле не остаётся загрязнённых буферов, он может быть неактивен более длительное время. По умолчанию этот параметр равен 200 миллисекундам (<TT
CLASS="LITERAL"
>200ms</TT
>). Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <TT
CLASS="VARNAME"
>bgwriter_delay</TT
> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MAXPAGES"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число буферов, которое сможет записать процесс фоновой записи за раунд активности. При нулевом значении фоновая запись отключается. (Учтите, что на контрольные точки, которые управляются отдельным вспомогательным процессом, это не влияет.) По умолчанию значение этого параметра — 100 буферов. Задать этот параметр можно только в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MULTIPLIER"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Число загрязнённых буферов, записываемых в очередном раунде, зависит от того, сколько новых буферов требовалось серверным процессам в предыдущих раундах. Средняя недавняя потребность умножается на <TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> и предполагается, что именно столько буферов потребуется на следующем раунде. Процесс фоновой записи будет записывать на диск и освобождать буферы, пока число свободных буферов не достигнет целевого значения. (При этом число буферов, записываемых за раунд, ограничивается сверху параметром <TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
>.) Таким образом, со множителем, равным 1.0, записывается ровно столько буферов, сколько требуется по предположению (<SPAN
CLASS="QUOTE"
>"точно по плану"</SPAN
>). Увеличение этого множителя даёт некоторую страховку от резких скачков потребностей, тогда как уменьшение отражает намерение оставить некоторый объём записи для серверных процессов. По умолчанию он равен 2.0. Этот параметр можно установить только в файле <TT
CLASS="FILENAME"
>postgresql.conf</TT
> или в командной строке при запуске сервера.</P
></DD
></DL
></DIV
><P
>С маленькими значениями <TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> и <TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> уменьшается активность ввода/вывода со стороны процесса фоновой записи, но увеличивается вероятность того, что запись придётся производить непосредственно серверным процессам, что замедлит выполнение запросов.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR"
>18.4.6. Асинхронное поведение</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-EFFECTIVE-IO-CONCURRENCY"
></A
><TT
CLASS="VARNAME"
>effective_io_concurrency</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт допустимое число параллельных операций ввода/вывода, которое говорит <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> о том, сколько операций ввода/вывода могут быть выполнены одновременно. Чем больше это число, тем больше операций ввода/вывода будет пытаться выполнить параллельно <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> в отдельном сеансе. Допустимые значения лежат в интервале от 1 до 1000, а нулевое значение отключает асинхронные запросы ввода/вывода. В настоящее время этот параметр влияет только на сканирование по битовой карте.</P
><P
>Хорошим начальным значением этого параметра будет число отдельных дисков, составляющих массив RAID 0 или RAID 1, если база данных размещена в нём. (Для RAID 5 следует исключить один диск (как диск с чётностью).) Однако, если база данных часто обрабатывает множество запросов в различных сеансах, и при небольших значениях дисковый массив может быть полностью загружен. Если продолжать увеличивать это значение при полной загрузке дисков, это приведёт только к увеличению нагрузки на процессор.</P
><P
>Для более экзотических систем, таких как хранилище в памяти или внешний RAID-массив, где ограничение накладывает пропускная способность шины, оптимальным значением может быть число доступных каналов ввода/вывода. Для выбора лучшего значения могут потребоваться некоторые эксперименты.</P
><P
>Асинхронный ввод/вывод зависит от эффективности функции <CODE
CLASS="FUNCTION"
>posix_fadvise</CODE
>, которая отсутствует в некоторых операционных системах. В случае её отсутствия попытка задать для этого параметра любое ненулевое значение приведёт к ошибке. В некоторых системах (например, в Solaris), эта функция присутствует, но на самом деле ничего не делает.</P
></DD
><DT
><A
NAME="GUC-MAX-WORKER-PROCESSES"
></A
><TT
CLASS="VARNAME"
>max_worker_processes</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число фоновых процессов, которое можно запустить в текущей операционной системе. Этот параметр можно задать только при запуске сервера.</P
><P
>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Подключения и аутентификация</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Журнал упреждающей записи</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>