<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Изоляция транзакций</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Управление конкурентным доступом"
HREF="mvcc.html"><LINK
REL="PREVIOUS"
TITLE="Введение"
HREF="mvcc-intro.html"><LINK
REL="NEXT"
TITLE="Явные блокировки"
HREF="explicit-locking.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Введение"
HREF="mvcc-intro.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 13. Управление конкурентным доступом</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Явные блокировки"
HREF="explicit-locking.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TRANSACTION-ISO"
>13.2. Изоляция транзакций</A
></H1
><P
>Стандарт <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> определяет четыре уровня изоляции транзакций. Наиболее строгий из них &mdash; сериализуемый, определяется одним абзацем, говорящем, что при параллельном выполнении несколько сериализуемых транзакций должны гарантированно выдавать такой же результат, как если бы они запускались по очереди в некотором порядке. Остальные три уровня определяются через описания особых явлений, которые возможны при взаимодействии параллельных транзакций, но не допускаются на определённом уровне. Как отмечается в стандарте, из определения сериализуемого уровня вытекает, что на этом уровне ни одно из этих явлений не возможно. (В самом деле &mdash; если эффект транзакций должен быть тем же, что и при их выполнении по очереди, как можно было бы увидеть особые явления, связанные с другими транзакциями?)</P
><P
>Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>&laquo;грязное&raquo; чтение</DT
><DD
><P
>Транзакция читает данные, записанные параллельной незавершённой транзакцией.</P
></DD
><DT
>неповторяемое чтение</DT
><DD
><P
>Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).</P
></DD
><DT
>фантомное чтение</DT
><DD
><P
>Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.</P
></DD
></DL
></DIV
><P></P
><P
> Четыре уровня изоляции транзакции и их соответствующие поведения описаны в <A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>Таблице 13-1</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="MVCC-ISOLEVEL-TABLE"
></A
><P
><B
>Таблица 13-1. Уровни изоляции транзакций, определённые в стандарте <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>Уровень изоляции</TH
><TH
>&laquo;Грязное&raquo; чтение</TH
><TH
>Неповторяемое чтение</TH
><TH
>Фантомное чтение</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Read uncommited (Чтение незафиксированных данных)</TD
><TD
>Возможно</TD
><TD
>Возможно</TD
><TD
>Возможно</TD
></TR
><TR
><TD
>Read committed (Чтение зафиксированных данных)</TD
><TD
>Невозможно</TD
><TD
>Возможно</TD
><TD
>Возможно</TD
></TR
><TR
><TD
>Repeatable read (Повторяемое чтение)</TD
><TD
>Невозможно</TD
><TD
>Невозможно</TD
><TD
>Возможно</TD
></TR
><TR
><TD
>Serializable (Сериализуемость)</TD
><TD
>Невозможно</TD
><TD
>Невозможно</TD
><TD
>Невозможно</TD
></TR
></TBODY
></TABLE
></DIV
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> вы можете запросить любой из этих четырёх уровней изоляции транзакций. Однако внутри определены только три различных уровня, соответствующие уровням Read Committed, Repeatable Read и Serializable. Запрашивая уровень Read Uncommitted (Чтение незафиксированных данных), на самом деле вы получаете чтение зафиксированных, а в реализации Repeatable Read в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> фантомное чтение невозможно, так что фактически выбранный уровень может быть более строгим, чем запрошенный. Это разрешается стандартом SQL &mdash; для четырёх уровней изоляции определяется только, какие особые условия не должны наблюдаться, но не определяется, какие должны. Причина наличия в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> только трёх уровней изоляции состоит в том, что только так можно сопоставить стандартные уровни изоляции с архитектурой многоверсионного управления конкурентным доступом. Более подробно доступные уровни изоляции описаны в следующих подразделах.</P
><P
>Для выбора нужного уровня изоляции транзакций используется команда <A
HREF="sql-set-transaction.html"
>SET TRANSACTION</A
>.</P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>Важно: </B
>Поведение некоторых функций и типов данных <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> в транзакциях подчиняется особым правилам. В частности, изменения последовательностей (и следовательно, счётчика в колонке, объявленной как <TT
CLASS="TYPE"
>serial</TT
>) немедленно видны во всех остальных транзакциях и не откатываются назад, если выполнившая их транзакция прерывается. См. <A
HREF="functions-sequence.html"
>Раздел 9.16</A
> и <A
HREF="datatype-numeric.html#DATATYPE-SERIAL"
>Подраздел 8.1.4</A
>.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-READ-COMMITTED"
>13.2.1. Уровень изоляции Read Committed</A
></H2
><P
><I
CLASS="FIRSTTERM"
>Read Committed</I
> &mdash; уровень изоляции транзакции, выбираемый в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> по умолчанию. В транзакции, работающей на этом уровне, запрос <TT
CLASS="COMMAND"
>SELECT</TT
> (без предложения <TT
CLASS="LITERAL"
>FOR UPDATE/SHARE</TT
>) видит только те данные, которые были зафиксированы до начала запроса; он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями. По сути запрос <TT
CLASS="COMMAND"
>SELECT</TT
> видит снимок базы данных в момент начала выполнения запроса. Однако <TT
CLASS="COMMAND"
>SELECT</TT
> видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два последовательных оператора <TT
CLASS="COMMAND"
>SELECT</TT
> могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции зафиксируют изменения после запуска первого <TT
CLASS="COMMAND"
>SELECT</TT
>, но до запуска второго.</P
><P
>Команды <TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>, <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> и <TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
> ведут себя подобно <TT
CLASS="COMMAND"
>SELECT</TT
> при поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на момент начала команды. Однако к моменту, когда они будут найдены, эти целевые строки могут быть уже изменены (а также удалены или заблокированы) другой параллельной транзакцией. В этом случае запланированное изменение будет отложено до фиксирования или отката первой изменяющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзакция откатывается, её результат отбрасывается и вторая изменяющая транзакция может продолжить изменение изначально полученной строки. Если первая транзакция зафиксировалась, но в результате удалила эту строку, вторая будет игнорировать её, а в противном случае попытается выполнить свою операцию с изменённой версией строки. Условие поиска в команде (предложение <TT
CLASS="LITERAL"
>WHERE</TT
>) вычисляется повторно для выяснения, соответствует ли по-прежнему этому условию изменённая версия строки. Если да, вторая изменяющая транзакция продолжают свою работу с изменённой версией строки. Применительно к командам <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> и <TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
> это означает, что изменённая версия строки блокируется и возвращается клиенту.</P
><P
>Вследствие описанного выше правила, изменяющая команда может увидеть несогласованное состояние: она может видеть результаты параллельных команд, изменяющих запрошенные ей строки, но она не видит результаты этих команд в других строках таблиц. Из-за этого поведения уровень Read Committed не подходит для команд со сложными условиями поиска; однако он вполне пригоден для простых случаев. Например, рассмотрим изменение баланса счёта в таких транзакциях: </P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;</PRE
><P> Если две такие транзакции пытаются параллельно изменить баланса счёта 12345, мы, естественно, хотим, чтобы вторая транзакция работала с изменённой версией строки счёта. Так как каждая команда влияет только на определённую строку, если она будет видеть изменённую версию строки, это не приведёт к проблемам несогласованности.</P
><P
>В более сложных ситуациях уровень Read Committed может приводить к нежелательным результатам. Например, рассмотрим команду <TT
CLASS="COMMAND"
>DELETE</TT
>, работающую со строками, которые параллельно добавляет и удаляет из множества, определённого её условием, другая команда. Например, предположим, что <TT
CLASS="LITERAL"
>website</TT
> &mdash; таблица из двух строк, в которых <TT
CLASS="LITERAL"
>website.hits</TT
> равны <TT
CLASS="LITERAL"
>9</TT
> и <TT
CLASS="LITERAL"
>10</TT
>: </P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE website SET hits = hits + 1;
-- выполняется параллельно:  DELETE FROM website WHERE hits = 10;
COMMIT;</PRE
><P> Команда <TT
CLASS="COMMAND"
>DELETE</TT
> не сделает ничего, даже несмотря на то, что строка с <TT
CLASS="LITERAL"
>website.hits = 10</TT
> была в таблице и до, и после выполнения <TT
CLASS="COMMAND"
>UPDATE</TT
>. Это происходит потому, что строка со значением <TT
CLASS="LITERAL"
>9</TT
> до изменения пропускается, а когда команда <TT
CLASS="COMMAND"
>UPDATE</TT
> завершается и <TT
CLASS="COMMAND"
>DELETE</TT
> получает освободившуюся блокировку, строка с <TT
CLASS="LITERAL"
>10</TT
> теперь содержит <TT
CLASS="LITERAL"
>11</TT
>, а это значение уже не соответствует условию.</P
><P
>Так как в режиме Read Committed каждая команда начинается с нового снимка состояния, который включает результаты всех транзакций, зафиксированных к этому моменту, последующие команды в одной транзакции будут в любом случае видеть эффекты всех параллельных зафиксированных транзакций. Вопрос здесь состоит в том, видит ли <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>одна</I
></SPAN
> команда абсолютно согласованное состояние базы данных.</P
><P
>Частичная изоляция транзакция, обеспечиваемая в режиме Read Committed, приемлема для множества приложений. Этот режим быстр и прост в использовании, однако он подходит не для всех случаев. Приложениям, выполняющим сложные запросы и изменения, могут потребоваться более строго согласованное представление данных, чем то, что даёт Read Committed.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-REPEATABLE-READ"
>13.2.2. Уровень изоляции Repeatable Read</A
></H2
><P
>В режиме <I
CLASS="FIRSTTERM"
>Repeatable Read</I
> видны только те данные, которые были зафиксированы до начала транзакции, но не видны незафиксированные данные и изменения, произведённые другими транзакциями в процессе выполнения данной транзакции. (Однако запрос будет видеть эффекты предыдущих изменений в своей транзакции, несмотря на то, что они не зафиксированы.) Это самое строгое требование, которое стандарт <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> вводит для этого уровня изоляции, и при его выполнении предотвращаются все явления, описанные в <A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>Таблице 13-1</A
>. Как было сказано выше, это не противоречит стандарту, так как он определяет только <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>минимальную</I
></SPAN
> защиту, которая должна обеспечиваться на каждом уровне изоляции.</P
><P
>Этот уровень отличается от Read Committed тем, что на данном уровне транзакция видит снимок данных на момент начала <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>транзакции</I
></SPAN
>, а не начала запроса. Таким образом, последовательные команды <TT
CLASS="COMMAND"
>SELECT</TT
> в <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>одной</I
></SPAN
> транзакции видят одни и те же данные; они не видят изменений, внесённых и зафиксированных другими транзакциями после начала текущей транзакции.</P
><P
>Приложения, использующие этот уровень, должны быть готовы повторить транзакции в случае сбоев сериализации.</P
><P
>Команды <TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>, <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> и <TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
> ведут себя подобно <TT
CLASS="COMMAND"
>SELECT</TT
> при поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на момент начала транзакции. Однако к моменту, когда они будут найдены, эти целевые строки могут быть уже изменены (а также изменены и заблокированы) другой параллельной транзакцией. В этом случае транзакция в режиме Repeatable Read будет ожидать фиксирования или отката первой изменяющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзакция откатывается, её результат отбрасывается и текущая транзакция может продолжить изменение изначально полученной строки. Если же первая транзакция зафиксировалась, и в результате изменила или удалила эту строку, а не просто заблокировала её, произойдёт откат текущей транзакции с сообщением </P><PRE
CLASS="SCREEN"
>ОШИБКА: не удалось сериализовать доступ из-за параллельного изменения</PRE
><P> так как транзакция уровня Repeatable Read не может изменять или блокировать строки, изменённые другими транзакциями с момента её начала.</P
><P
>Когда приложение получает это сообщение об ошибке, оно должна прервать текущую транзакцию и попытаться повторить её с самого начала. Во второй раз транзакция увидит внесённое до этого изменение как часть начального снимка базы данных, так что новая версия строки вполне может использоваться в качестве отправной точки для изменения в повторной транзакции.</P
><P
>Заметьте, что потребность в повторении транзакции может возникнуть, только если эта транзакция изменяет данные; в транзакциях, которые только читают данные, конфликтов сериализации не бывает.</P
><P
>Режим Repeatable Read строго гарантирует, что каждая транзакция видит полностью стабильное представление базы данных. Однако это представление не обязательно будет согласовано с некоторым последовательным выполнением транзакций одного уровня. Например, даже транзакция, которая только читает данные, в этом режиме может видеть строку, показывающую, что некоторое задание завершено, но <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> видеть одну из строк логических частей задания, так как эта транзакция может прочитать более раннюю версию строки задания, чем ту, для которой параллельно добавлялась очередная логическая часть. Строго исполнить бизнес-правила в транзакциях, работающих на этом уровне изоляции, скорее всего не удастся без явных блокировок конфликтующих транзакций.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>До версии 9.1 в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> при запросе режима Serializable поведение системы в точности соответствовало вышеописанному. Таким образом, чтобы сейчас получить старое поведение Serializable, нужно запрашивать режим Repeatable Read.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-SERIALIZABLE"
>13.2.3. Уровень изоляции Serializable</A
></H2
><P
>Уровень <I
CLASS="FIRSTTERM"
>Serializable</I
> обеспечивает самую строгую изоляцию транзакций. На этом уровне моделируется последовательное выполнение всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не параллельно. Однако, как и на уровне Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбоев сериализации. Фактически этот режим изоляции работает так же, как и Repeatable Read, только он дополнительно отслеживает условия, при которых результат параллельно выполняемых сериализуемых транзакций может не согласовываться с результатом этих же транзакций, выполняемых по очереди. Это отслеживание не вводит дополнительных блокировок, кроме тех, что присущи режиму Repeatable Read, но тем не менее создаёт некоторую добавочную нагрузку, а при выявлении исключительных условий регистрируется <I
CLASS="FIRSTTERM"
>аномалия сериализации</I
> и происходит <I
CLASS="FIRSTTERM"
>сбой сериализации</I
>.</P
><P
>Например, рассмотрим таблицу <TT
CLASS="STRUCTNAME"
>mytab</TT
>, изначально содержащую: </P><PRE
CLASS="SCREEN"
> class | value
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200</PRE
><P> Предположим, что сериализуемая транзакция A вычисляет: </P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 1;</PRE
><P> а затем вставляет результат (30) в поле <TT
CLASS="STRUCTFIELD"
>value</TT
> в новую строку со значением <TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 2</TT
>. В это же время сериализуемая транзакция B вычисляет: </P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 2;</PRE
><P> получает результат 300 и вставляет его в новую строку со значением <TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 1</TT
>. Затем обе транзакции пытаются зафиксироваться. Если бы одна из этих транзакций работала в режиме Repeatable Read, зафиксироваться могли бы обе; но так как полученный результат не соответствовал бы последовательному порядку, в режиме Serializable будет зафиксирована только одна транзакция, а вторая закончится откатом с сообщением: </P><PRE
CLASS="SCREEN"
>ОШИБКА: не удалось сериализовать доступ из-за зависимостей чтения/записи между
  транзакциями</PRE
><P> Это объясняется тем, что при выполнении A перед B транзакция B вычислила бы сумму 330, а не 300, а при выполнении в обратном порядке A вычислила бы другую сумму.</P
><P
>Рассчитывая, что сериализуемые транзакции предотвратят аномалии, важно понимать, что любые данные, полученные из постоянной таблицы пользователя, не должны считаться действительными, пока транзакция, прочитавшая их, не будет успешно зафиксирована. Это верно даже для транзакций, не модифицирующих данные, за исключением случая, когда данные считываются в <I
CLASS="FIRSTTERM"
>откладываемой</I
> транзакции такого типа. В этом случае данные могут считаться действительными, так как такая транзакция ждёт, пока не сможет получить снимок, гарантированно предотвращающий подобные проблемы. Во всех остальных случаях приложения не должны полагаться на результаты чтения данных в транзакции, которая не была зафиксирована; в случае ошибки и отката приложения должны повторять транзакцию, пока она не будет завершена успешно.</P
><P
>Для полной гарантии сериализуемости в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> применяются <I
CLASS="FIRSTTERM"
>предикатные блокировки</I
>, то есть блокировки, позволяющие определить, когда запись могла бы повлиять на результат предыдущего чтения параллельной транзакции, если бы эта запись выполнялась сначала. В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> эти блокировки не приводят к фактическим блокировкам данным и следовательно никоим образом <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> могут повлечь взаимоблокировки транзакций. Они помогают выявить и отметить зависимости между параллельными сериализуемыми транзакциями, которые в определённых сочетаниях могут приводить к аномалиям сериализации. Транзакции Read Committed или Repeatable Read для обеспечения целостности данных, напротив, должны либо блокировать таблицы целиком, что помешает пользователям обращаться к этим таблицам, либо применять <TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
> или <TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>, что не только заблокирует другие транзакции, но и создаст дополнительную нагрузку на диск.</P
><P
>Предикатные блокировки в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, как и в большинстве других СУБД, устанавливаются для данных, фактически используемых в транзакции. Они отображаются в системном представлении <A
HREF="view-pg-locks.html"
><TT
CLASS="STRUCTNAME"
>pg_locks</TT
></A
> со значением <TT
CLASS="LITERAL"
>mode</TT
> равным <TT
CLASS="LITERAL"
>SIReadLock</TT
>. Какие именно блокировки будут затребованы при выполнении запроса, зависит от плана запроса, при этом детализированные блокировки (например, блокировки строк) могут объединяться в более общие (например, в блокировки страниц) в процессе транзакции для экономии памяти, расходуемой для отслеживания блокировок. Транзакция <TT
CLASS="LITERAL"
>READ ONLY</TT
> может даже освободить свои блокировки SIRead до завершения, если обнаруживается, что конфликты, которые могли бы привести к аномалии сериализации, исключены. На самом деле для транзакций <TT
CLASS="LITERAL"
>READ ONLY</TT
> этот факт чаще всего устанавливается в самом начале, так что они обходятся без предикатных блокировок. Если же вы явно запросите транзакцию <TT
CLASS="LITERAL"
>SERIALIZABLE READ ONLY DEFERRABLE</TT
>, она будет заблокирована до тех пор, пока не сможет установить этот факт. (Это <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>единственный</I
></SPAN
> случай, когда транзакции уровня Serializable блокируются, а транзакции Repeatable Read &mdash; нет.) С другой стороны, блокировки SIRead часто должны сохраняться и после фиксирования транзакции, пока не будут завершены другие, наложившиеся на неё транзакции.</P
><P
>При правильном использовании сериализуемые транзакции могут значительно упростить разработку приложений. Гарантия того, что любое сочетание параллельных сериализуемых транзакцию даст тот же результат, что и последовательность этих транзакций, выполненных по очереди, означает, что если вы уверены, что единственная транзакция определённого содержания работает правильно, когда она запускается отдельно, вы можете быть уверены, что она будет работать так же правильно в любом сочетании сериализуемых транзакций, вне зависимости от того, что они делают. При этом важно, чтобы в среде, где применяется этот подход, была реализована общая обработка сбоев сериализации (которые можно определить по значению SQLSTATE '40001'), так как заведомо определить, какие именно транзакции могут стать жертвами зависимостей чтения/записи и не будут зафиксированы для предотвращения аномалий сериализации, обычно очень сложно. Отслеживание зависимостей чтения-записи неизбежно создаёт дополнительную нагрузку, как и перезапуск транзакций, не зафиксированных из-за сбоев сериализации, но если на другую чашу весов положить нагрузку и блокировки, связанные с применением явных блокировок и <TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
> или <TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>, использовать сериализуемые транзакции в ряде случаев окажется выгоднее.</P
><P
>Применяя сериализуемые транзакции для управления конкурентным доступом, примите к сведению следующие рекомендации: <P
></P
></P><UL
><LI
><P
>Объявляйте транзакции как <TT
CLASS="LITERAL"
>READ ONLY</TT
>, если это отражает их суть.</P
></LI
><LI
><P
>Управляйте числом активных подключений, при необходимости используя пул соединений. Это всегда полезно для увеличения производительности, но особенно важно это в загруженной системе с сериализуемыми транзакциями.</P
></LI
><LI
><P
>Заключайте в одну транзакцию не больше команд, чем необходимо для обеспечения целостности.</P
></LI
><LI
><P
>Не оставляйте соединения <SPAN
CLASS="QUOTE"
>"простаивающими"</SPAN
> в транзакции дольше, чем необходимо.</P
></LI
><LI
><P
>Исключите явные блокировки, <TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
> и <TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
> там, где они не нужны благодаря защите, автоматически предоставляемой сериализуемыми транзакциями.</P
></LI
><LI
><P
>Когда система вынуждена объединять предикатные блокировки уровня страницы в одну предикатную блокировку уровня таблицы из-за нехватки памяти, может возрасти частота сбоев сериализации. Избежать этого можно, увеличив параметр <A
HREF="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION"
>max_pred_locks_per_transaction</A
>.</P
></LI
><LI
><P
>Последовательное сканирование всегда влечёт за собой предикатную блокировку на уровне таблицы. Это приводит к увеличению сбоев сериализации. В таких ситуациях бывает полезно склонить систему к использованию индексов, уменьшая <A
HREF="runtime-config-query.html#GUC-RANDOM-PAGE-COST"
>random_page_cost</A
> и/или увеличивая <A
HREF="runtime-config-query.html#GUC-CPU-TUPLE-COST"
>cpu_tuple_cost</A
>. Однако тут важно сопоставить выигрыш от уменьшения числа откатов и перезапусков транзакций с проигрышем от возможного менее эффективного выполнения запросов.</P
></LI
></UL
><P></P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Внимание</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Поддержка уровня изоляции Serializable ещё не реализована для целевых серверов горячего резерва (они описываются в <A
HREF="hot-standby.html"
>Разделе 25.5</A
>). На данный момент самый строгий уровень изоляции, поддерживаемый в режиме горячего резерва, это Repeatable Read. Хотя и тогда, когда главный сервер выполняет запись в транзакциях Serializable, все резервные серверы в итоге достигают согласованного состояния, но транзакция Repeatable Read на резервном сервере иногда может увидеть промежуточное состояние, не соответствующее результату последовательного выполнения транзакций на главном сервере.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc-intro.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="explicit-locking.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Введение</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Явные блокировки</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>