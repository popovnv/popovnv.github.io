<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE AGGREGATE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="COPY"
HREF="sql-copy.html"><LINK
REL="NEXT"
TITLE="CREATE CAST"
HREF="sql-createcast.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="COPY"
HREF="sql-copy.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE CAST"
HREF="sql-createcast.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEAGGREGATE"
></A
>CREATE AGGREGATE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN72145"
></A
><H2
>Название</H2
>CREATE AGGREGATE&nbsp;--&nbsp;создать агрегатную функцию</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN72148"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>режим_аргумента</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>имя_аргумента</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>тип_данных_аргумента</I
></TT
> [ , ... ] ) (
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>начальное_условие</I
></TT
> ]
    [ , MSFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_состояния_движ</I
></TT
> ]
    [ , MINVFUNC = <TT
CLASS="REPLACEABLE"
><I
>обратная_функция_движ</I
></TT
> ]
    [ , MSTYPE = <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
> ]
    [ , MSSPACE = <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния_движ</I
></TT
> ]
    [ , MFINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_завершения_движ</I
></TT
> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <TT
CLASS="REPLACEABLE"
><I
>начальное_условие_движ</I
></TT
> ]
    [ , SORTOP = <TT
CLASS="REPLACEABLE"
><I
>оператор_сортировки</I
></TT
> ]
)

CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> ( [ [ <TT
CLASS="REPLACEABLE"
><I
>режим_аргумента</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>имя_аргумента</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>тип_данных_аргумента</I
></TT
> [ , ... ] ]
                        ORDER BY [ <TT
CLASS="REPLACEABLE"
><I
>режим_аргумента</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>имя_аргумента</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>тип_данных_аргумента</I
></TT
> [ , ... ] ) (
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>начальное_условие</I
></TT
> ]
    [ , HYPOTHETICAL ]
)

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>или старый синтаксис</SPAN
></SPAN
>

CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> (
    BASETYPE = <TT
CLASS="REPLACEABLE"
><I
>базовый_тип</I
></TT
>,
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>начальное_условие</I
></TT
> ]
    [ , MSFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_состояния_движ</I
></TT
> ]
    [ , MINVFUNC = <TT
CLASS="REPLACEABLE"
><I
>обратная_функция_движ</I
></TT
> ]
    [ , MSTYPE = <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
> ]
    [ , MSSPACE = <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния_движ</I
></TT
> ]
    [ , MFINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>функция_завершения_движ</I
></TT
> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <TT
CLASS="REPLACEABLE"
><I
>начальное_условие_движ</I
></TT
> ]
    [ , SORTOP = <TT
CLASS="REPLACEABLE"
><I
>оператор_сортировки</I
></TT
> ]
)</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72193"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
> создаёт новую агрегатную функцию. Некоторое количество базовых и часто используемых агрегатных функций включено в дистрибутив, они описаны в <A
HREF="functions-aggregate.html"
>Разделе 9.20</A
>. Но если нужно адаптировать их к новым типам или создать недостающие агрегатные функции, это можно сделать с помощью команды <TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>.</P
><P
>Если указывается имя схемы (например, <TT
CLASS="LITERAL"
>CREATE AGGREGATE myschema.myagg ...</TT
>), агрегатная функция создаётся в указанной схеме. В противном случае она создаётся в текущей схеме.</P
><P
>Агрегатная функция идентифицируется по имени и типам входных данных. Две агрегатных функции в одной схеме могут иметь одно имя, только если они работают с разными типами данных. Имя и тип(ы) входных данных агрегата не могут совпадать с именем и типами данных любой другой обычной функции в той же схеме. Это же правило действует при перегрузке имён обычных функций (см. <A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>).</P
><P
>Простую агрегатную функцию образуют одна или две обычные функции: функция перехода состояния <TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
> и необязательная функция окончательного вычисления <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
>. Они используются следующим образом: </P><PRE
CLASS="PROGRAMLISTING"
><TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
>( внутреннее-состояние, следующие-значения-данных ) ---&gt; следующее-внутреннее-состояние
<TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
>( внутреннее-состояние ) ---&gt; агрегатное_значение</PRE
><P></P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> создаёт временную переменную типа <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
> для хранения текущего внутреннего состояния агрегата. Затем для каждой поступающей строки вычисляются значения аргументов агрегата и вызывается функция перехода состояния с текущим значением состояния и полученными аргументами; эта функция вычисляет следующее внутреннее состояние. Когда таким образом будут обработаны все строки, вызывается завершающая функция, которая должна вычислить возвращаемое значение агрегата. Если функция завершения отсутствует, просто возвращается конечное значение состояния.</P
><P
>Агрегатная функция может определить начальное условие, то есть начальное значение для внутренней переменной состояния. Это значение задаётся и сохраняется в базе данных в виде строки типа <TT
CLASS="TYPE"
>text</TT
>, но оно должно быть допустимым внешним представлением константы типа данных переменной состояния. По умолчанию начальным значением состояния считается NULL.</P
><P
>Если функция перехода состояния объявлена как <SPAN
CLASS="QUOTE"
>"strict"</SPAN
> (строгая), её нельзя вызывать с входными значениями NULL. В этом случае агрегатная функция выполняется следующим образом. Строки со значениями NULL игнорируются (функция перехода не вызывается и предыдущее значение состояния не меняется) и если начальное состояние равно NULL, то в первой же строке, в которой все входные значения не NULL, первый аргумент заменяет значение состояния, а функция перехода вызывается для каждой последующей строки, в которой все входные значения не NULL. Это поведение удобно для реализации таких агрегатных функций, как <CODE
CLASS="FUNCTION"
>max</CODE
>. Заметьте, что такое поведение возможно, только если <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
> совпадает с первым <TT
CLASS="REPLACEABLE"
><I
>типом_данных_аргумента</I
></TT
>. Если же эти типы различаются, необходимо задать начальное условие не NULL или использовать нестрогую функцию перехода состояния.</P
><P
>Если функция перехода состояния не является строгой, она вызывается безусловно для каждой поступающей строки и должна сама обрабатывать вводимые значения и переменную состояния, равные NULL. Это позволяет разработчику агрегатной функции полностью управлять тем, как она воспринимает значения NULL.</P
><P
>Если функция завершения объявлена как <SPAN
CLASS="QUOTE"
>"strict"</SPAN
> (строгая), она не будет вызвана при конечном значении состояния, равном NULL; вместо этого автоматически возвращается результат NULL. (Разумеется, это вполне нормальное поведение для строгих функций.) Когда функция завершения вызывается, она в любом случае может возвратить значение NULL. Например, функция завершения для <CODE
CLASS="FUNCTION"
>avg</CODE
> возвращает NULL, если определяет, что было обработано ноль строк.</P
><P
>Иногда бывает полезно объявить функцию завершения как принимающую не только состояние, но и дополнительные параметры, соответствующие входным данным агрегата. В основном это имеет смысл для полиморфных функций завершения, которым может быть недостаточно знать тип данных только переменной состояния, чтобы вывести тип результата. Эти дополнительные параметры всегда передаются как NULL (так что функция завершения не должна быть строгой, когда применяется <TT
CLASS="LITERAL"
>FINALFUNC_EXTRA</TT
>), но в остальном это обычные параметры. Функция завершения может выяснить фактические типы аргументов в текущем вызове, воспользовавшись системным вызовом <CODE
CLASS="FUNCTION"
>get_fn_expr_argtype</CODE
>.</P
><P
>Агрегатная функция может дополнительно поддерживать <I
CLASS="FIRSTTERM"
>режим движущегося агрегата</I
>, как описано в <A
HREF="xaggr.html#XAGGR-MOVING-AGGREGATES"
>Подразделе 35.10.1</A
>. Для применения этого режима требуется указать параметры <TT
CLASS="LITERAL"
>MSFUNC</TT
>, <TT
CLASS="LITERAL"
>MINVFUNC</TT
> и <TT
CLASS="LITERAL"
>MSTYPE</TT
>, а также, возможно, параметры <TT
CLASS="LITERAL"
>MSPACE</TT
>, <TT
CLASS="LITERAL"
>MFINALFUNC</TT
>, <TT
CLASS="LITERAL"
>MFINALFUNC_EXTRA</TT
> и <TT
CLASS="LITERAL"
>MINITCOND</TT
>. За исключением <TT
CLASS="LITERAL"
>MINVFUNC</TT
>, эти параметры работают как соответствующие параметры простого агрегата без начальной буквы <TT
CLASS="LITERAL"
>M</TT
>; они определяют отдельную реализацию агрегата, включающую функцию обратного перехода.</P
><P
>Если в список параметров добавлено указание <TT
CLASS="LITERAL"
>ORDER BY</TT
>, создаётся особый типа агрегата, называемый <I
CLASS="FIRSTTERM"
>сортирующим агрегатом</I
>; с указанием <TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
> создаётся <I
CLASS="FIRSTTERM"
>гипотезирующий агрегат</I
>. Эти агрегаты работают с группами отсортированных значений и зависят от порядка сортировки, поэтому определение порядка сортировки входных данных является неотъемлемой частью их вызова. Кроме того, они могут иметь <I
CLASS="FIRSTTERM"
>непосредственные</I
> аргументы, которые вычисляются единожды для всей процедуры агрегирования, а не для каждой поступающей строки. Гипотезирующие агрегаты представляют собой подкласс сортирующих агрегатов, в которых непосредственные аргументы должны совпадать, по количеству и типам данных, с агрегируемыми аргументами. Это позволяет добавить значения этих непосредственных аргументов в набор агрегируемых строк в качестве дополнительной <SPAN
CLASS="QUOTE"
>"гипотетической"</SPAN
> строки.</P
><P
>Агрегаты, работающие подобно <CODE
CLASS="FUNCTION"
>MIN</CODE
> и <CODE
CLASS="FUNCTION"
>MAX</CODE
>, иногда можно соптимизировать, заменив сканирование всех строк таблицы обращением к индексу. Если агрегат подлежит такой оптимизации, это можно указать, определив <I
CLASS="FIRSTTERM"
>оператор сортировки</I
>. Основное требование при этом: агрегат должен выдавать в результате первый элемент по порядку сортировки, задаваемому оператором; другими словами: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT agg(col) FROM tab;</PRE
><P> должно быть равнозначно: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;</PRE
><P> Дополнительно предполагается, что агрегат игнорирует значения NULL и возвращает NULL, только если строк со значениями не NULL не нашлось. Обычно оператор <TT
CLASS="LITERAL"
>&lt;</TT
> является подходящим оператором сортировки для <CODE
CLASS="FUNCTION"
>MIN</CODE
>, а <TT
CLASS="LITERAL"
>&gt;</TT
> — для <CODE
CLASS="FUNCTION"
>MAX</CODE
>. Заметьте, что обращение к индексу может дать эффект, только если заданный оператор реализует стратегию <SPAN
CLASS="QUOTE"
>"меньше"</SPAN
> или <SPAN
CLASS="QUOTE"
>"больше"</SPAN
> в классе операторов индекса-B-дерева.</P
><P
>Чтобы создать агрегатную функцию, необходимо иметь право <TT
CLASS="LITERAL"
>USAGE</TT
> для типов аргументов, типа(ов) состояния и типа результата, а также право <TT
CLASS="LITERAL"
>EXECUTE</TT
> для функций перехода и завершения.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72260"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) создаваемой агрегатной функции.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>режим_аргумента</I
></TT
></DT
><DD
><P
>Режим аргумента: <TT
CLASS="LITERAL"
>IN</TT
> или <TT
CLASS="LITERAL"
>VARIADIC</TT
>. (Агрегатные функции не поддерживают выходные аргументы (<TT
CLASS="LITERAL"
>OUT</TT
>).) По умолчанию подразумевается <TT
CLASS="LITERAL"
>IN</TT
>. Режим <TT
CLASS="LITERAL"
>VARIADIC</TT
> может быть указан только последним.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_аргумента</I
></TT
></DT
><DD
><P
>Имя аргумента. В настоящее время используется только в целях документирования. Если опущено, соответствующий аргумент будет безымянным.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных_аргумента</I
></TT
></DT
><DD
><P
>Тип входных данных, с которым работает эта агрегатная функция. Для создания агрегатной функции без аргументов вставьте <TT
CLASS="LITERAL"
>*</TT
> вместо списка с определениями аргументов. (Пример такой агрегатной функции: <CODE
CLASS="FUNCTION"
>count(*)</CODE
>.)</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>базовый_тип</I
></TT
></DT
><DD
><P
>В прежнем синтаксисе <TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
> тип входных данных задавался параметром <TT
CLASS="LITERAL"
>basetype</TT
>, а не записывался после имени агрегата. Это позволяло указать только один входной параметр. Чтобы определить функцию без аргументов, используя этот синтаксис, в качестве значения <TT
CLASS="LITERAL"
>basetype</TT
> нужно указать <TT
CLASS="LITERAL"
>"ANY"</TT
> (не <TT
CLASS="LITERAL"
>*</TT
>). Создать сортирующий агрегат старый синтаксис не позволял.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
></DT
><DD
><P
>Имя функции перехода состояния, вызываемой для каждой входной строки. Для обычных агрегатных функций с <TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
> аргументами, <TT
CLASS="REPLACEABLE"
><I
>функция_состояния</I
></TT
> должна принимать <TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
>+1 аргумент, первый должен иметь тип <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>, а остальные — типы соответствующих входных данных. Возвращать она должна значение типа <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>. Эта функция принимает текущее значение состояния и текущие значения входных данных, и возвращает следующее значение состояния.</P
><P
>В сортирующих (и в том числе, гипотезирующих) агрегатах функция перехода состояния получает только текущее значение состояния и агрегируемые аргументы, без непосредственных аргументов. Других отличий у неё нет.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
></DT
><DD
><P
>Тип данных значения состояния для агрегатной функции.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния</I
></TT
></DT
><DD
><P
>Средний размер значения состояния агрегата (в байтах). Если этот параметр опущен или равен нулю, применяемая оценка по умолчанию определяется по типу <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>. Планировщик использует это значение для оценивания объёма памяти, требуемому для агрегатного запроса с группировкой. Планировщик может применить агрегирование по хешу для такого запроса, только если хеш-таблица, судя по оценке, поместится в <A
HREF="runtime-config-resource.html#GUC-WORK-MEM"
>work_mem</A
>; таким образом, при больших значениях этого параметра агрегирование по хешу будет менее желательным.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
></DT
><DD
><P
>Имя функции завершения, вызываемой для вычисления результата агрегатной функции после обработки всех входных строк. Для обычного агрегата эта функция должна принимать единственный аргумент типа <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>. Возвращаемым типом агрегата будет тип, который возвращает эта функция. Если <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
> не указана, результатом агрегата будет конечное значение состояния, а типом результата — <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>.</P
><P
>В сортирующих (и в том числе, гипотезирующих) агрегатах функция завершения получает не только конечное значение состояния, но и значения всех непосредственных аргументов.</P
><P
>Если команда содержит указание <TT
CLASS="LITERAL"
>FINALFUNC_EXTRA</TT
>, то в дополнение к конечному значению состояния и всем непосредственным аргументам функция завершения получает добавочные значения NULL, соответствующие обычным (агрегируемым) аргументам агрегата. Это в основном полезно для правильного определения типа результата при создании полиморфной агрегатной функции.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>начальное_условие</I
></TT
></DT
><DD
><P
>Начальное значение переменной состояния. Оно должно задаваться строковой константой в форме, пригодной для ввода в <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>. Если не указано, начальным значением состояния будет NULL.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_состояния_движ</I
></TT
></DT
><DD
><P
>Имя функции прямого перехода состояния, вызываемой для каждой входной строки в режиме движущегося агрегата. Это точно такая же функция, как и обычная функция перехода, но её первый аргумент и результат имеют тип <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
>, который может отличаться от типа <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния</I
></TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>обратная_функция_движ</I
></TT
></DT
><DD
><P
>Имя функции обратного перехода состояния, применяемой в режиме движущегося агрегата. У этой функции те же типы аргумента и результатов, что и у <TT
CLASS="REPLACEABLE"
><I
>функции_состояния_движ</I
></TT
>, но она предназначена не для добавления, а для удаления значения из текущего состояния агрегата. Функция обратного перехода должна иметь ту же характеристику строгости, что и функция прямого перехода.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
></DT
><DD
><P
>Тип данных значения состояния для агрегатной функции в режиме движущегося агрегата.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния_движ</I
></TT
></DT
><DD
><P
>Примерный размер значения состояния в режиме движущегося агрегата. Он имеет то же значение, что и <TT
CLASS="REPLACEABLE"
><I
>размер_данных_состояния</I
></TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_завершения_движ</I
></TT
></DT
><DD
><P
>Имя функции завершения, вызываемой в режиме движущегося агрегата для вычисления результата агрегатной функции после обработки всех входных строк. Она работает так же, как <TT
CLASS="REPLACEABLE"
><I
>функция_завершения</I
></TT
>, но её первый аргумент имеет тип <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
>, а дополнительными пустыми аргументами управляет параметр <TT
CLASS="LITERAL"
>MFINALFUNC_EXTRA</TT
>. Тип результата, который определяет <TT
CLASS="REPLACEABLE"
><I
>функция_завершения_движ</I
></TT
>, или <TT
CLASS="REPLACEABLE"
><I
>тип_данных_состояния_движ</I
></TT
>, должен совпадать с типом результата обычной реализации агрегата.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>начальное_условие_движ</I
></TT
></DT
><DD
><P
>Начальное значение переменной состояния в режиме движущегося агрегата. Оно применяется так же, как <TT
CLASS="REPLACEABLE"
><I
>начальное_условие</I
></TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>оператор_сортировки</I
></TT
></DT
><DD
><P
>Связанный оператор сортировки для реализации агрегатов, подобных <CODE
CLASS="FUNCTION"
>MIN</CODE
> или <CODE
CLASS="FUNCTION"
>MAX</CODE
>. Здесь указывается просто имя оператора (возможно, дополненное схемой). Предполагается, что оператор поддерживает те же типы входных данных, что и агрегат (который должен быть обычным и иметь один аргумент).</P
></DD
><DT
><TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
></DT
><DD
><P
>Этот признак, допустимый только для сортирующих агрегатов, указывает, что агрегатные аргументы должны обрабатываться согласно требованиям гипотезирующих агрегатов: то есть последние несколько прямых аргументов должны соответствовать по типам агрегатным аргументам (<TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>). Признак <TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
> не влияет на поведение во время выполнения, он учитывается только при разрешении типов данных и правил сортировки аргументов.</P
></DD
></DL
></DIV
><P
>Параметры <TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
> могут записываться в любом порядке, не обязательно так, как показано выше.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72396"
></A
><H2
>Замечания</H2
><P
>В параметрах, определяющих имена вспомогательных функций, при необходимости можно написать имя схемы, например: <TT
CLASS="LITERAL"
>SFUNC = public.sum</TT
>. Однако типы аргументов там не указываются &mdash; типы аргументов вспомогательных функций определяются другими параметрами.</P
><P
>Если агрегатная функция поддерживает режим движущегося агрегата, это увеличивает эффективность вычислений, когда она применяется в качестве оконной функции для окна с движущимся началом рамки (то есть, когда начало определяется не как <TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>). По сути, функция прямого перехода добавляет входные значения к состоянию агрегата, когда они поступают в рамку окна снизу, а функция обратного перехода снова вычитает их, когда они покидают рамку сверху. Поэтому вычитаются значения в том же порядке, в каком добавлялись. Когда бы ни вызывалась функция обратного перехода, она таким образом получит первое из добавленных, но ещё не удалённых значений аргумента. Функция обратного перехода может рассчитывать на то, что после того, как она удалит самые старые данные, в текущем состоянии останется ещё как минимум одна строка. (Когда это правило могло бы нарушиться, механизм оконных функций просто начинает агрегировать данные заново, а не вызывает функцию обратного перехода.)</P
><P
>Функция прямого перехода для режима движущегося агрегата не может возвращать NULL в качестве нового значения состояния. Если NULL возвращает функция обратного перехода, это показывает, что она не может произвести обратное вычисление для этих конкретных данных, и что вычисление агрегата следует выполнить заново от начальной позиции текущей рамки. Благодаря этому соглашению, режим движущегося агрегата можно использовать, даже если иногда возникают ситуации, в которых обратный расчёт состояния производить непрактично.</P
><P
>Агрегатную функцию можно использовать с движущимися рамками и без реализации движущегося агрегата, но при этом <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет заново агрегировать все данные при каждом перемещении начала рамки. Заметьте, что вне зависимости от того, поддерживает ли агрегатная функция режим движущегося агрегата, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может обойтись без повторных вычислений при сдвиге конца рамки; новые значения просто продолжают добавляться в состояние агрегата. Предполагается, что функция завершения не повреждает значение состояния агрегата, так что вычисление агрегата можно продолжить даже после получения результата для строк в определённой рамке.</P
><P
>Синтаксис сортирующих агрегатных функций позволяет указать <TT
CLASS="LITERAL"
>VARIADIC</TT
> и в последнем непосредственном параметре, и в последнем агрегатном (<TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>). Однако в текущей реализации на применение <TT
CLASS="LITERAL"
>VARIADIC</TT
> накладываются два ограничения. Во-первых, в сортирующих агрегатах можно использовать только <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>, но не другие типы переменных массивов. Во-вторых, если последним непосредственным аргументом является <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>, то допускается только один агрегатный аргумент и это тоже должен быть <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>. (В представлении, используемом в системных каталогах, эти два параметра объединяются в один элемент <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>, так как в <TT
CLASS="STRUCTNAME"
>pg_proc</TT
> нельзя представить функцию с несколькими параметрами <TT
CLASS="LITERAL"
>VARIADIC</TT
>.) Если агрегатная функция является гипотезирующей, непосредственные аргументы, соответствующие параметру <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>, будут гипотетическими; любые предшествующие параметры представляют дополнительные непосредственные аргументы, которые могут не соответствовать агрегатным.</P
><P
>В настоящее время сортирующие агрегатные функции не поддерживают режим движущегося агрегата, так как их нельзя применять в качестве оконных функций.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72418"
></A
><H2
>Примеры</H2
><P
>См. <A
HREF="xaggr.html"
>Раздел 35.10</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72422"
></A
><H2
>Совместимость</H2
><P
>Оператор <TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
> является языковым расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. В стандарте SQL не предусмотрено создание пользовательских агрегатных функций.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72427"
></A
><H2
>См. также</H2
><A
HREF="sql-alteraggregate.html"
>ALTER AGGREGATE</A
>, <A
HREF="sql-dropaggregate.html"
>DROP AGGREGATE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-copy.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createcast.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>COPY</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE CAST</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>