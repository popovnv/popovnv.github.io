<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Горячий резерв</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Отказоустойчивость, балансировка нагрузки и репликация"
HREF="high-availability.html"><LINK
REL="PREVIOUS"
TITLE="Другие методы трансляции журнала"
HREF="log-shipping-alternative.html"><LINK
REL="NEXT"
TITLE="Конфигурация восстановления"
HREF="recovery-config.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Другие методы трансляции журнала"
HREF="log-shipping-alternative.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 25. Отказоустойчивость, балансировка нагрузки и репликация</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Конфигурация восстановления"
HREF="recovery-config.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HOT-STANDBY"
>25.5. Горячий резерв</A
></H1
><P
>Термин &laquo;горячий резерв&raquo; используется для описания возможности подключаться к серверу и выполнять запросы на чтение, в то время как сервер находится в режиме резерва или восстановления архива. Это полезно и для целей репликации, и для восстановления желаемого состояния из резервной копии с высокой точностью. Так же термин «горячий резерв» описывает способность сервера переходить из режима восстановления к обычной работе, в то время как пользователи продолжают выполнять запросы и/или их соединения остаются открытыми.</P
><P
>В режиме горячего резерва запросы выполняются примерно так же, как и в обычном режиме, с некоторыми отличиями в использовании и администрировании, описанными ниже.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="HOT-STANDBY-USERS"
>25.5.1. Краткий пользовательский обзор</A
></H2
><P
>Когда параметр <A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY"
>hot_standby</A
> на резервном сервере установлен в true, то он начинает принимать соединения сразу как только система придёт в согласованное состояние в процессе восстановления. Все соединения только для чтения, даже временные таблицы не могут быть записаны.</P
><P
>Для того, чтобы данные с ведущего сервера были получены на резервном, требуется некоторое время. Таким образом, имеется измеряемая задержка между ведущим и резервным серверами. Поэтому запуск одинаковых запросов примерно в одно время на ведущем и резервном серверах может вернуть разный результат. Можно сказать, что данные на резервном сервере <I
CLASS="FIRSTTERM"
>согласованы на данный момент</I
> с ведущим. Так, подтверждённая запись для транзакции проигрывается на резервном сервере. После этого изменения, совершённые в транзакции, станут видимыми для любого нового снимка данных, сделанного на резервном сервере. Снимок может быть сделан в начале каждого запроса или в начале каждой транзакции в зависимости от уровня изоляции транзакции. Более подробно см. <A
HREF="transaction-iso.html"
>Раздел 13.2</A
>.</P
><P
>Транзакции, запущенные в режиме горячего резерва, могут выполнять следующие команды: <P
></P
></P><UL
><LI
><P
>Доступ к данным — <TT
CLASS="COMMAND"
>SELECT</TT
>, <TT
CLASS="COMMAND"
>COPY TO</TT
></P
></LI
><LI
><P
>Команды для работы с курсором — <TT
CLASS="COMMAND"
>DECLARE</TT
>, <TT
CLASS="COMMAND"
>FETCH</TT
>, <TT
CLASS="COMMAND"
>CLOSE</TT
></P
></LI
><LI
><P
>Параметры — <TT
CLASS="COMMAND"
>SHOW</TT
>, <TT
CLASS="COMMAND"
>SET</TT
>, <TT
CLASS="COMMAND"
>RESET</TT
></P
></LI
><LI
><P
>Команды явного управления транзакциями <P
></P
></P><UL
><LI
><P
><TT
CLASS="COMMAND"
>BEGIN</TT
>, <TT
CLASS="COMMAND"
>END</TT
>, <TT
CLASS="COMMAND"
>ABORT</TT
>, <TT
CLASS="COMMAND"
>START TRANSACTION</TT
></P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>SAVEPOINT</TT
>, <TT
CLASS="COMMAND"
>RELEASE</TT
>, <TT
CLASS="COMMAND"
>ROLLBACK TO SAVEPOINT</TT
></P
></LI
><LI
><P
>Блок <TT
CLASS="COMMAND"
>EXCEPTION</TT
> и другие внутренние подчиненные транзакции</P
></LI
></UL
><P></P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>LOCK TABLE</TT
>, только когда исполняется в явном виде в следующем режиме: <TT
CLASS="LITERAL"
>ACCESS SHARE</TT
>, <TT
CLASS="LITERAL"
>ROW SHARE</TT
> или <TT
CLASS="LITERAL"
>ROW EXCLUSIVE</TT
>.</P
></LI
><LI
><P
>Планы и ресурсы — <TT
CLASS="COMMAND"
>PREPARE</TT
>, <TT
CLASS="COMMAND"
>EXECUTE</TT
>, <TT
CLASS="COMMAND"
>DEALLOCATE</TT
>, <TT
CLASS="COMMAND"
>DISCARD</TT
></P
></LI
><LI
><P
>Дополнения и расширения — <TT
CLASS="COMMAND"
>LOAD</TT
></P
></LI
></UL
><P></P
><P
>Транзакции, запущенные в режиме горячего резерва, никогда не получают ID транзакции и не могут быть записаны в журнал транзакций. Поэтому при попытке выполнить следующие действия возникнут ошибки: <P
></P
></P><UL
><LI
><P
>Команды манипуляции данными (DML) — <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>, <TT
CLASS="COMMAND"
>COPY FROM</TT
>, <TT
CLASS="COMMAND"
>TRUNCATE</TT
>. Следует отметить, что нет разрешённых действий, которые приводили бы к срабатыванию триггера во время исполнения на резервном сервере. Это ограничение так же касается и временных таблиц, так как строки таблицы не могут быть прочитаны или записаны без обращения к ID транзакции, что в настоящее время не возможно в среде горячего резерва.</P
></LI
><LI
><P
>Команды определения данных (DDL) — <TT
CLASS="COMMAND"
>CREATE</TT
>, <TT
CLASS="COMMAND"
>DROP</TT
>, <TT
CLASS="COMMAND"
>ALTER</TT
>, <TT
CLASS="COMMAND"
>COMMENT</TT
>. Эти ограничения так же относятся и к временным таблицам, так как операции могут потребовать обновления таблиц системных каталогов.</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>SELECT ... FOR SHARE | UPDATE</TT
>, так как блокировка строки не может быть проведена без обновления соответствующих файлов данных.</P
></LI
><LI
><P
>Правила для выражений <TT
CLASS="COMMAND"
>SELECT</TT
>, которые приводят к выполнению команд DML.</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>LOCK</TT
> которая явно требует режим более строгий чем <TT
CLASS="LITERAL"
>ROW EXCLUSIVE MODE</TT
>.</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>LOCK</TT
> в короткой форме с умолчаниями, так как требует <TT
CLASS="LITERAL"
>ACCESS EXCLUSIVE MODE</TT
>.</P
></LI
><LI
><P
>Команды управления транзакциями, которые в явном виде требуют режим не только для чтения <P
></P
></P><UL
><LI
><P
><TT
CLASS="COMMAND"
>BEGIN READ WRITE</TT
>, <TT
CLASS="COMMAND"
>START TRANSACTION READ WRITE</TT
></P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>SET TRANSACTION READ WRITE</TT
>, <TT
CLASS="COMMAND"
>SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</TT
></P
></LI
><LI
><P
>           <TT
CLASS="COMMAND"
>SET transaction_read_only = off</TT
>
          </P
></LI
></UL
><P></P
></LI
><LI
><P
>Команды двухфазной фиксации — <TT
CLASS="COMMAND"
>PREPARE TRANSACTION</TT
>, <TT
CLASS="COMMAND"
>COMMIT PREPARED</TT
>, <TT
CLASS="COMMAND"
>ROLLBACK PREPARED</TT
>, так как даже транзакции только для чтения нуждаются в записи в WAL на подготовительной фазе (первая фаза двухфазной фиксации).</P
></LI
><LI
><P
>Обновление последовательностей — <CODE
CLASS="FUNCTION"
>nextval()</CODE
>, <CODE
CLASS="FUNCTION"
>setval()</CODE
></P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>LISTEN</TT
>, <TT
CLASS="COMMAND"
>UNLISTEN</TT
>, <TT
CLASS="COMMAND"
>NOTIFY</TT
></P
></LI
></UL
><P></P
><P
>При обычной работе транзакции <SPAN
CLASS="QUOTE"
>"только для чтения"</SPAN
> могут обновлять последовательности и использовать команды <TT
CLASS="COMMAND"
>LISTEN</TT
>, <TT
CLASS="COMMAND"
>UNLISTEN</TT
>, и <TT
CLASS="COMMAND"
>NOTIFY</TT
>, таким образом сессии горячего резерва работают с несколько большими ограничениями, чем обычные только читающие сессии. Возможно, что некоторые из этих ограничений будут ослаблены в следующих выпуска.</P
><P
>В режиме горячего резерва параметр <TT
CLASS="VARNAME"
>transaction_read_only</TT
> всегда имеет значение true и изменить его нельзя. Но если не пытаться модифицировать содержимое БД, подключение к серверу в этом режиме не отличается от подключений к обычным базам данных. При отработке отказа или переключении ролей база данных переходит в обычный режим работы. Когда сервер меняет режим работы, установленные сеансы остаются подключёнными. После выхода из режима горячего резерва становится возможным запускать пишущие транзакции (даже в сеансах, начатых ещё в режиме горячего резерва).</P
><P
>Пользователи могут узнать о нахождении сессии в режиме только для чтения с помощью команды <TT
CLASS="COMMAND"
>SHOW transaction_read_only</TT
>. Кроме того, набор функций (<A
HREF="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE"
>Таблица 9-66</A
>) позволяет пользователям получить доступ к информации о резервном сервере. Это позволяет создавать программы, учитывающие текущий статус базы данных. Такой режим может быть полезен для мониторинга процесса восстановления или для написания комплексного восстановления для особенных случаев.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="HOT-STANDBY-CONFLICT"
>25.5.2. Обработка конфликтов запросов</A
></H2
><P
>Ведущий и резервный серверы связаны между собой многими слабыми связями. События на ведущем сервере оказывают влияние на резервный. В результате имеется потенциальная возможность отрицательного влияния или конфликта между ними. Наиболее простой для понимания конфликт — быстродействие: если на ведущем происходит загрузка очень большого объёма данных, то происходит создание соответствующего потока записей WAL на резервный сервер. Таким образом, запросы на резервном конкурируют за системные ресурсы, например, ввод-вывод.</P
><P
>Так же может возникнуть дополнительный тип конфликта на сервере горячего резерва. Этот конфликт называется <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>жёстким конфликтом</I
></SPAN
>, оказывает влияние на запросы, приводя к их отмене, а в некоторых случаях и к обрыву сессии для разрешения конфликтов. Пользователям предоставлен набор средств для обработки подобных конфликтов. Случаи конфликтов включают: <P
></P
></P><UL
><LI
><P
>Установка эксклюзивной блокировки на ведущем сервере, как с помощью явной команды <TT
CLASS="COMMAND"
>LOCK</TT
>, так и при различных <ACRONYM
CLASS="ACRONYM"
>DDL</ACRONYM
>, что приводит к конфликту доступа к таблицам на резервном.</P
></LI
><LI
><P
>Удаление табличного пространства на ведущем сервере приводит к конфликту на резервном когда запросы используют это пространство для хранения временных рабочих файлов.</P
></LI
><LI
><P
>Удаление базы данных на ведущем сервере конфликтует с сессиями, подключёнными к этой БД на резервном.</P
></LI
><LI
><P
>Приложение очистки устаревших транзакций из WAL конфликтует с транзакциями на резервном сервере, которые используют снимок данных, который всё ещё видит какие-то из очищенных на ведущем строк.</P
></LI
><LI
><P
>Приложение очистки устаревших транзакций из WAL конфликтует с запросами к целевой странице на резервном сервере вне зависимости от того, являются ли данные удалёнными или видимыми.</P
></LI
></UL
><P></P
><P
>В этих случаях на ведущем сервере просто происходит ожидание; пользователю следует выбрать какую их конфликтующих сторон отменить. Тем не менее, на резервном нет выбора: действия из WAL уже произошли на ведущем, поэтому резервный обязан применить их. Более того, позволять обработчику WAL ожидать неограниченно долго может быть крайне нежелательно, так как отставание резервного сервера от ведущего может всё возрастать. Таким образом, механизм обеспечивает принудительную отмену запросов на резервном сервере, которые конфликтуют с применяемыми записями WAL.</P
><P
>Примером такой проблемы может быть ситуация: администратор на ведущем сервере выполнил команду <TT
CLASS="COMMAND"
>DROP TABLE</TT
> для таблицы, которая сейчас участвует в запросе на резервном. Понятно, что этот запрос нельзя будет выполнять дальше, если команда <TT
CLASS="COMMAND"
>DROP TABLE</TT
> применится на резервном. Если бы этот запрос выполнялся на ведущем, команда <TT
CLASS="COMMAND"
>DROP TABLE</TT
> ждала бы его окончания. Но когда на ведущем выполняется только команда <TT
CLASS="COMMAND"
>DROP TABLE</TT
>, ведущий сервер не знает, какие запросы выполняются на резервном, поэтому он не может ждать завершения подобных запросов. Поэтому если записи WAL с изменением прибудут на резервный сервер, когда запрос будет продолжать выполняться, возникнет конфликт. В этом случае резервный сервер должен либо задержать применение этих записей WAL (и всех остальных, следующих за ними), либо отменить конфликтующий запрос, чтобы можно было применить <TT
CLASS="COMMAND"
>DROP TABLE</TT
>.</P
><P
>Если конфликтный запрос короткий, обычно желательно разрешить ему завершиться, ненадолго задержав применение записей WAL, но слишком большая задержка в применении WAL обычно нежелательна. Поэтому механизм отмены имеет параметры <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY"
>max_standby_archive_delay</A
> и <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY"
>max_standby_streaming_delay</A
>, которые определяют максимально допустимое время задержки применения WAL. Конфликтующие запросы будут отменены, если они длятся дольше допустимого времени задержки применения очередных записей WAL. Два параметра существуют для того, чтобы можно было задать разные значения для чтения записей WAL из архива (то есть при начальном восстановлении из базовой копии либо при <SPAN
CLASS="QUOTE"
>"навёрстывании"</SPAN
> ведущего сервера в случае большого отставания) и для получения записей WAL при потоковой репликации.</P
><P
>На резервном сервере, созданном преимущественно для отказоустойчивости, лучше выставлять параметры задержек относительно небольшими, чтобы он не мог сильно отстать от ведущего из-за задержек, связанных с ожиданием запросов горячего резерва. Однако если резервный сервер предназначен для выполнения длительных запросов, то высокое значение или даже бесконечное ожидание могут быть предпочтительнее. Тем не менее, следует иметь в виду, что длительные запросы могут оказать влияние на другие сессии на резервном сервере в виде отсутствия последних изменений от ведущего из-за задержки применения записей WAL.</P
><P
>В случае, если задержка, определённая <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> или <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> будет превышена, конфликтующий запрос будет отменён. Обычно это выражается в виде ошибки отмены, но в случае проигрывания команды <TT
CLASS="COMMAND"
>DROP DATABASE</TT
> обрывается вся конфликтная сессия. Так же, если конфликт произошел при блокировке, вызванной транзакцией в состоянии IDLE, конфликтная сессия разрывается (это поведение может изменить в будущем).</P
><P
>Отменённые запросы могут быть немедленно повторены (конечно после старта новой транзакции). Так как причина отмены зависит от природы проигрываемых записей WAL, запрос, который был отменён, может быть успешно выполнен вновь.</P
><P
>Следует учесть, что параметры задержки отсчитываются от времени получения резервным сервером данных WAL. Таким образом, период дозволенной работы для запроса на резервном сервере никогда не может быть длиннее параметра задержки и может быть существенно короче, если резервный уже находится в режиме задержки в результате ожидания предыдущего запроса или результат не доступен из-за высокой нагрузки обновлений.</P
><P
>Наиболее частой причиной конфликтов между запросами на резервном сервере и проигрыванием WAL является преждевременная очистка. Обычно <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> допускает очистку старых версий записей при условии что ни одна из транзакций их не видит согласно правилам видимости данных для MVCC. Тем не менее, эти правила применяются только для транзакций, выполняемых на главном сервере. Таким образом, допустима ситуация, когда на главном запись уже очищена, но эта же запись всё ещё видна для транзакций на резервном сервере.</P
><P
>Для опытных пользователей следует отметить, что как очистка старых версий строк, так и заморозка версии строки могут потенциально вызвать конфликт с запросами на резервном сервере. Ручной запуск команды <TT
CLASS="COMMAND"
>VACUUM FREEZE</TT
> может привести к конфликту, даже в таблице без обновленных и удалённых строк.</P
><P
>Пользователи должны понимать, что таблицы, подвергающиеся высокой нагрузке на обновление на ведущем сервере с большей вероятностью могут вызвать отмену длительных запросов на резервном. В таком случае установка окончательного значения для <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> или <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> может быть близка к значению <TT
CLASS="VARNAME"
>statement_timeout</TT
>.</P
><P
>В случае, если количество отменённых запросов на резервном сервере получается неприемлемым, существует ряд дополнительных возможностей. Первая возможность — установить параметр <TT
CLASS="VARNAME"
>hot_standby_feedback</TT
>, который не даёт команде <TT
CLASS="COMMAND"
>VACUUM</TT
> удалять записи, ставшие недействительными недавно, что предотвращает конфликты очистки. При этом следует учесть, что это вызывает задержку очистки мёртвых строк на ведущем, что может привести к нежелательному распуханию таблицы. Тем не менее, в итоге ситуация будет не хуже, чем если бы запросы к резервному серверу исполнялись непосредственно на ведущем, но при этом сохранится положительный эффект от разделения нагрузки. В случае, когда соединение резервных серверов с ведущим часто разрывается, следует скорректировать период, в течение которого обратная связь через <TT
CLASS="VARNAME"
>hot_standby_feedback</TT
> не обеспечивается. Например, следует подумать об увеличении <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
>, чтобы запросы отменялись не сразу при конфликтах с архивом WAL в период разъединения. Также может иметь смысл увеличить <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> для предотвращения быстрой отмены запросов из-за полученных записей WAL после восстановления соединения.</P
><P
>Другая возможность — увеличение <A
HREF="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE"
>vacuum_defer_cleanup_age</A
> на ведущем сервере таким образом, чтобы мёртвые записи не очищались бы так быстро, как при обычном режиме работы. Это даёт запросам на резервном сервере больше времени на выполнение, прежде чем они могут быть отменены, без увеличения задержки <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>. Тем не менее при таком подходе очень трудно обеспечить какое-то определённое окно по времени, так как <TT
CLASS="VARNAME"
>vacuum_defer_cleanup_age</TT
> измеряется в количестве транзакций, выполняемых на ведущем сервере.</P
><P
>Количество отменённых запросов и причины отмены можно просмотреть через системное представление <TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
> на резервном сервере. Системное представление <TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
> так же содержит итоговую информацию.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="HOT-STANDBY-ADMIN"
>25.5.3. Обзор административной части</A
></H2
><P
>Если в файле <TT
CLASS="FILENAME"
>postgresql.conf</TT
> параметр <TT
CLASS="VARNAME"
>hot_standby</TT
> установлен в значение <TT
CLASS="LITERAL"
>on</TT
> и существует файл <TT
CLASS="FILENAME"
>recovery.conf</TT
>, то сервер работает в режиме горячего резерва. Тем не менее, требуется какое-то время перед тем как сервер горячего резерва сможет принимать соединения. Потому что сервер не принимает соединения пока не пройдёт достаточная часть восстановления для обеспечения согласованных данных для приходящих запросов. В течение этого периода клиенты при попытке подключения получают отказ соединения с сообщением об ошибке. Для того чтобы удостовериться в том, что сервер заработал, нужно либо постоянно повторять попытки соединений из приложения, либо посмотреть на сообщения в журнале сервера: </P><PRE
CLASS="PROGRAMLISTING"
>LOG:  entering standby mode

... then some time later ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read only connections</PRE
><P> Информация о согласованности записывается один раз при наступлении проверочной точки на ведущем. Нет возможности включить горячий резерв, когда зачитываемый WAL был записан в момент когда <TT
CLASS="VARNAME"
>wal_level</TT
> не был установлен в значение <TT
CLASS="LITERAL"
>hot_standby</TT
> или <TT
CLASS="LITERAL"
>logical</TT
> на ведущем сервере. Достижение согласованного состояния так же может задерживаться при наличии следующих условий: <P
></P
></P><UL
><LI
><P
>Пишущая транзакция имеет более 64 подтранзакций</P
></LI
><LI
><P
>Очень длительные пишущие транзакции</P
></LI
></UL
><P> Если применяется трансляция файлов журналов (&laquo;тёплый резерв&raquo;), то следует подождать прибытия очередного WAL-файла, который сформируется не позднее чем через период <TT
CLASS="VARNAME"
>archive_timeout</TT
>, заданный для ведущего сервера.</P
><P
>Значения некоторых параметров на резервном сервере необходимо изменить при модификации их на ведущем. Для таких параметров значения на резервном сервере должны быть равны или больше значений на ведущем. Если параметр имеет недостаточно большое значение, резервный сервер не сможет начать работу. Следует увеличить значение и повторить попытку восстановления ещё раз. Это касается следующих параметров: <P
></P
></P><UL
><LI
><P
>         <TT
CLASS="VARNAME"
>max_connections</TT
>
        </P
></LI
><LI
><P
>         <TT
CLASS="VARNAME"
>max_prepared_transactions</TT
>
        </P
></LI
><LI
><P
>         <TT
CLASS="VARNAME"
>max_locks_per_transaction</TT
>
        </P
></LI
></UL
><P></P
><P
>Очень важно для администратора выбрать подходящие значения для <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY"
>max_standby_archive_delay</A
> и <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY"
>max_standby_streaming_delay</A
>. Оптимальное значение зависит от приоритетов. Например, если основное назначение сервера — обеспечение высокой степени доступности, то следует установить короткий период, возможно даже нулевой, хотя это очень жёсткий вариант. Если резервный сервер планируется как дополнительный сервер для аналитических запросов, то приемлемой будет максимальная задержка в несколько часов или даже -1, что означает бесконечное ожидание окончания запроса.</P
><P
>Вспомогательные биты статуса транзакций, записанные на ведущем, не попадают в WAL, так что они, скорее всего, будут перезаписаны на нём при работе с данными. Таким образом, резервный сервер будет производить запись на диск, даже если все пользователи только читают данные, ничего не меняя. Кроме того, пользователи будут записывать временные файлы при сортировке больших объёмов и обновлять файлы кеша. Поэтому в режиме горячего резерва ни одна часть базы данных фактически не работает в режиме &laquo;только чтение&raquo;. Следует отметить, что также возможно выполнить запись в удалённую базу данных с помощью модуля <SPAN
CLASS="APPLICATION"
>dblink</SPAN
> и другие операции вне базы данных с применением PL-функций, несмотря на то, что транзакции по-прежнему смогут только читать данные.</P
><P
>Следующие типы административных команд недоступны в течение режима восстановления: <P
></P
></P><UL
><LI
><P
>Команды определения данных (DDL) — например: <TT
CLASS="COMMAND"
>CREATE INDEX</TT
></P
></LI
><LI
><P
>Команды выдачи привилегий и назначения владельца — <TT
CLASS="COMMAND"
>GRANT</TT
>, <TT
CLASS="COMMAND"
>REVOKE</TT
>, <TT
CLASS="COMMAND"
>REASSIGN</TT
></P
></LI
><LI
><P
>Команды обслуживания — <TT
CLASS="COMMAND"
>ANALYZE</TT
>, <TT
CLASS="COMMAND"
>VACUUM</TT
>, <TT
CLASS="COMMAND"
>CLUSTER</TT
>, <TT
CLASS="COMMAND"
>REINDEX</TT
></P
></LI
></UL
><P></P
><P
>Ещё раз следует отметить, что некоторые из этих команд фактически доступны на ведущем сервере для транзакций в режиме только для чтения.</P
><P
>В результате нельзя создать дополнительные индексы или статистику, чтобы они существовали только на резервном. Если подобные административные команды нужны, то их следует выполнить на ведущем сервере, затем эти изменения будут распространены на резервные серверы.</P
><P
>Функции <CODE
CLASS="FUNCTION"
>pg_cancel_backend()</CODE
> и <CODE
CLASS="FUNCTION"
>pg_terminate_backend()</CODE
> работают на стороне пользователя, но не для процесса запуска, который обеспечивает восстановление. Представление <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> не показывает ни вхождение для процесса запуска, ни восстановление транзакций в активном состоянии. В результате <TT
CLASS="STRUCTNAME"
>pg_prepared_xacts</TT
> всегда пусто в ходе восстановления. Если требуется разрешить сомнительные подготовленные транзакции, следует обратиться к <TT
CLASS="LITERAL"
>pg_prepared_xacts</TT
> на ведущем и выполнить команду для разрешения транзакции там.</P
><P
><TT
CLASS="STRUCTNAME"
>pg_locks</TT
> отображает блокировки, происходящие в процессе работы сервера как обычно. <TT
CLASS="STRUCTNAME"
>pg_locks</TT
> так же показывает виртуальные транзакции, обработанные процессом запуска, которому принадлежат все <TT
CLASS="LITERAL"
>AccessExclusiveLocks</TT
> наложенные транзакциями в режиме восстановления. Следует отметить, что процесс запуска не запрашивает блокировки, чтобы внести изменения в базу данных, поэтому блокировки, отличные от <TT
CLASS="LITERAL"
>AccessExclusiveLocks</TT
> не показываются в <TT
CLASS="STRUCTNAME"
>pg_locks</TT
> для процесса запуска, подразумевается их существование.</P
><P
>Дополнение <SPAN
CLASS="PRODUCTNAME"
>check_pgsql</SPAN
> для <SPAN
CLASS="PRODUCTNAME"
>Nagios</SPAN
> работает, так как является простой проверкой на существование. Скрипт мониторинга <SPAN
CLASS="PRODUCTNAME"
>check_postgres</SPAN
> так же работает, хотя для некоторых выдаваемых показателей результаты могут различаться или вводить в заблуждение. Например, нельзя отследить время последней очистки, так как очистка не производится на резервном сервере. Очистка запускается на ведущем сервере и результаты её работы передаются резервному.</P
><P
>Команды контроля файлов WAL так же не будут работать во время восстановления, например: <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>, <CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
> и т. п.</P
><P
>Динамически загружаемые модули работать будут, включая <TT
CLASS="STRUCTNAME"
>pg_stat_statements</TT
>.</P
><P
>Рекомендательная блокировка работает обычно при восстановлении, включая обнаружение взаимных блокировок. Следует отметить, что рекомендательная блокировка никогда не попадает в WAL, таким образом для рекомендательной блокировки как на ведущем сервере, так и на резервном, невозможен конфликт с проигрыванием WAL. Но возможно получение рекомендательной блокировки на ведущем сервере, а затем получение подобной рекомендательной блокировки на резервном. Рекомендательная блокировка относится только к серверу, на котором она получена.</P
><P
>Системы репликации на базе триггеров, подобные <SPAN
CLASS="PRODUCTNAME"
>Slony</SPAN
>, <SPAN
CLASS="PRODUCTNAME"
>Londiste</SPAN
> и <SPAN
CLASS="PRODUCTNAME"
>Bucardo</SPAN
> не могут запускаться на резервном сервере вовсе, хотя они превосходно работают на ведущем до тех пор, пока не будет подана команда не пересылать изменения на резервный. Проигрывание WAL не основано на триггерах, поэтому поток WAL нельзя транслировать с резервного сервера в другую систему, которая требует дополнительной записи в БД или работает на основе триггеров.</P
><P
>Новые OID не могут быть выданы, хотя, например генераторы <ACRONYM
CLASS="ACRONYM"
>UUID</ACRONYM
> смогут работать, если они не пытаются записывать новое состояние в базу данных.</P
><P
>В настоящий момент создание временных таблиц недопустимо при транзакции только для чтения, в некоторых случаях существующий скрипт будет работать неверно. Это ограничение может быть ослаблено в следующих выпусках. Это одновременно требование SQL стандарта и техническое требование.</P
><P
>Команда <TT
CLASS="COMMAND"
>DROP TABLESPACE</TT
> может быть выполнена только если табличное пространство пусто. Некоторые пользователи резервного сервера могут активно использовать табличное пространство через параметр <TT
CLASS="VARNAME"
>temp_tablespaces</TT
>. Если имеются временные файлы в табличных пространствах, все активные запросы отменяются для обеспечения удаления временных файлов, затем табличное пространство может быть удалено и продолжено проигрывание WAL.</P
><P
>Выполнение команды <TT
CLASS="COMMAND"
>DROP DATABASE</TT
> или <TT
CLASS="COMMAND"
>ALTER DATABASE ... SET TABLESPACE</TT
> на ведущем сервере приводит к созданию записи в WAL, которая вызывает принудительное отключение всех пользователей, подключённых к этой базе данных на резервном. Это происходит немедленно, вне зависимости от значения <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>. Следует отметить, что команда <TT
CLASS="COMMAND"
>ALTER DATABASE ... RENAME</TT
> не приводит к отключению пользователей, так что обычно она действует незаметно, хотя в некоторых случаях возможны сбои программ, которые зависят от имени базы данных.</P
><P
>В обычном (не восстановительном) режиме, выполнение команды <TT
CLASS="COMMAND"
>DROP USER</TT
> или <TT
CLASS="COMMAND"
>DROP ROLE</TT
> для роли, которая обладает возможностью подключения и пользователь сейчас подключён, для этого пользователя ничего не происходит — он продолжает оставаться подключённым. Тем не менее, этот пользователь не сможет переподключиться. Это же поведение применяется так же и для восстановления, так же команда <TT
CLASS="COMMAND"
>DROP USER</TT
> на ведущем сервере не отключает пользователя на резервном.</P
><P
>Сборщик статистики работает во время восстановления. Все операции сканирования, чтения, блоки, использование индексов и т. п. будут записаны обычным образом на резервном сервере. Действия, происходящие при проигрывании, не будут дублировать действия на ведущем сервере, то есть проигрывание команды вставки не увеличит значение колонки Inserts в представлении pg_stat_user_tables. Файлы статистики удаляются с началом восстановления, таким образом, статистика на ведущем сервере и резервном будет разной. Это является особенностью, не ошибкой.</P
><P
>Автоматическая очистка не работает во время восстановления. Она запустится в обычном режиме после завершения восстановления.</P
><P
>Во время восстановления активен фоновый процесс записи, он обрабатывает точки перезапуска (подобно контрольным точкам на ведущем сервере) и выполняет обычную очистку блоков. В том числе он может обновлять вспомогательные биты, сохранённые на резервном. Во время восстановления принимается команда <TT
CLASS="COMMAND"
>CHECKPOINT</TT
>, но она производит точку перезапуска, а не создаёт новую точку восстановления.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="HOT-STANDBY-PARAMETERS"
>25.5.4. Ссылки на параметры горячего резерва</A
></H2
><P
>Различные параметры были упомянуты выше в <A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>Подразделе 25.5.2</A
> и <A
HREF="hot-standby.html#HOT-STANDBY-ADMIN"
>Подразделе 25.5.3</A
>.</P
><P
>На ведущем могут применяться параметры <A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
> и <A
HREF="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE"
>vacuum_defer_cleanup_age</A
>. Параметры <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY"
>max_standby_archive_delay</A
> и <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY"
>max_standby_streaming_delay</A
> на ведущем не действуют.</P
><P
>На резервном сервере могут применяться параметры <A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY"
>hot_standby</A
>, <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY"
>max_standby_archive_delay</A
> и <A
HREF="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY"
>max_standby_streaming_delay</A
>. Параметр <A
HREF="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE"
>vacuum_defer_cleanup_age</A
> на нём не действует, пока сервер остаётся в режиме резервного сервера. Но если он станет ведущим, его значение вступит в силу.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="HOT-STANDBY-CAVEATS"
>25.5.5. Ограничения</A
></H2
><P
>Имеются следующие ограничения горячего резерва. Они могут и скорее всего будут исправлены в следующих выпусках: <P
></P
></P><UL
><LI
><P
>Действия на hash индексах в настоящее время не попадают в журнал WAL, таким образом, проигрывание WAL не приводит к обновлению этих индексов.</P
></LI
><LI
><P
>Требуется информация о всех запущенных транзакциях перед тем как будет создан снимок данных. Транзакции, использующие большое количество подтранзакций (в настоящий момент больше 64), будут задерживать начало соединения только для чтения до завершения самой длинной пишущей транзакции. При возникновении этой ситуации поясняющее сообщение будет записано в журнал сервера.</P
></LI
><LI
><P
>Подходящие стартовые точки для запросов на резервном сервере создаются при каждой контрольной точке на главном. Если резервный сервер отключается, в то время как главный был в отключённом состоянии, может оказаться невозможным возобновить его работу в режиме горячего резерва, до того, как запустится ведущий и добавит следующие стартовые точки в журналы WAL. Подобная ситуация не является проблемой для большинства случаев, в которых она может произойти. Обычно, если ведущий сервер выключен и больше не доступен, это является следствием серьёзного сбоя и в любом случае требует преобразования резервного в новый ведущий. Так же в ситуации, когда ведущий отключён намеренно, проверка готовности резервного к преобразованию в ведущий тоже является обычной процедурой.</P
></LI
><LI
><P
>В конце восстановления блокировки <TT
CLASS="LITERAL"
>AccessExclusiveLocks</TT
>, вызванные подготовленными транзакциями, требуют удвоенное, в сравнении с нормальным, количество блокировок записей таблицы. Если планируется использовать либо большое количество конкурирующих подготовленных транзакций, обычно вызывающие <TT
CLASS="LITERAL"
>AccessExclusiveLocks</TT
>, либо большие транзакции с применением большого количества <TT
CLASS="LITERAL"
>AccessExclusiveLocks</TT
>, то рекомендуется выбрать большое значение параметра <TT
CLASS="VARNAME"
>max_locks_per_transaction</TT
>, возможно в два раза большее, чем значение параметра на ведущем сервере. Всё это не имеет значения, когда <TT
CLASS="VARNAME"
>max_prepared_transactions</TT
> равно 0.</P
></LI
><LI
><P
>Уровень изоляции транзакции Serializable в настоящее время недоступен в горячем резерве. (За подробностями обратитесь к <A
HREF="transaction-iso.html#XACT-SERIALIZABLE"
>Подразделу 13.2.3</A
> и <A
HREF="applevel-consistency.html#SERIALIZABLE-CONSISTENCY"
>Подразделу 13.4.1</A
>) Попытка выставить для транзакции такой уровень изоляции в режиме горячего резерва вызовет ошибку.</P
></LI
></UL
><P></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="log-shipping-alternative.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="recovery-config.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Другие методы трансляции журнала</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Конфигурация восстановления</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>