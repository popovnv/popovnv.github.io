<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Планирование запросов</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Настройка сервера"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Репликация"
HREF="runtime-config-replication.html"><LINK
REL="NEXT"
TITLE="Регистрация ошибок и протоколирование работы сервера"
HREF="runtime-config-logging.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Репликация"
HREF="runtime-config-replication.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 18. Настройка сервера</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Регистрация ошибок и протоколирование работы сервера"
HREF="runtime-config-logging.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-QUERY"
>18.7. Планирование запросов</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-QUERY-ENABLE"
>18.7.1. Конфигурация методов планировщика</A
></H2
><P
>Эти параметры конфигурации дают возможность грубо влиять на планы, выбираемые оптимизатором запросов. Если автоматически выбранный оптимизатором план конкретного запроса оказался неоптимальным, в качестве <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>временного</I
></SPAN
> решения можно воспользоваться одним из этих параметров и вынудить планировщик выбрать другой план. Улучшить качество планов, выбираемых планировщиком, можно и более подходящими способами, в частности, скорректировать константы стоимости (см. <A
HREF="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS"
>Подраздел 18.7.2</A
>), выполнить <A
HREF="sql-analyze.html"
>ANALYZE</A
> вручную, изменить значение параметра конфигурации <A
HREF="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET"
>default_statistics_target</A
> и увеличить объём статистики, собираемой для отдельных колонок, воспользовавшись командой <TT
CLASS="COMMAND"
>ALTER TABLE SET STATISTICS</TT
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-ENABLE-BITMAPSCAN"
></A
><TT
CLASS="VARNAME"
>enable_bitmapscan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов сканирования по битовой карте. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-HASHAGG"
></A
><TT
CLASS="VARNAME"
>enable_hashagg</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов агрегирования по хешу. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-HASHJOIN"
></A
><TT
CLASS="VARNAME"
>enable_hashjoin</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов соединения по хешу. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-INDEXSCAN"
></A
><TT
CLASS="VARNAME"
>enable_indexscan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов сканирования по индексу. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-INDEXONLYSCAN"
></A
><TT
CLASS="VARNAME"
>enable_indexonlyscan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов сканирования только индекса. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-MATERIAL"
></A
><TT
CLASS="VARNAME"
>enable_material</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование материализации при планировании запросов. Полностью исключить материализацию невозможно, но при выключении этого параметра планировщик не будет вставлять узлы материализации, за исключением случаев, где они требуются для правильности. По умолчанию этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-MERGEJOIN"
></A
><TT
CLASS="VARNAME"
>enable_mergejoin</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов соединения слиянием. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
><DT
><A
NAME="GUC-ENABLE-NESTLOOP"
></A
><TT
CLASS="VARNAME"
>enable_nestloop</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планировщиком планов соединения с вложенными циклами. Полностью исключить вложенные циклы невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
>.</P
></DD
><DT
><A
NAME="GUC-ENABLE-SEQSCAN"
></A
><TT
CLASS="VARNAME"
>enable_seqscan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планировщиком планов последовательного сканирования. Полностью исключить последовательное сканирование невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
>.</P
></DD
><DT
><A
NAME="GUC-ENABLE-SORT"
></A
><TT
CLASS="VARNAME"
>enable_sort</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планировщиком шагов с явной сортировкой. Полностью исключить явную сортировку невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <TT
CLASS="LITERAL"
>on</TT
>.</P
></DD
><DT
><A
NAME="GUC-ENABLE-TIDSCAN"
></A
><TT
CLASS="VARNAME"
>enable_tidscan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает использование планов сканирования <ACRONYM
CLASS="ACRONYM"
>TID</ACRONYM
>. По умолчанию имеет значение <TT
CLASS="LITERAL"
>on</TT
> (вкл.).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-QUERY-CONSTANTS"
>18.7.2. Константы стоимости для планировщика</A
></H2
><P
>Переменные <I
CLASS="FIRSTTERM"
>стоимости</I
>, описанные в данном разделе, задаются по произвольной шкале. Значение имеют только их отношения, поэтому умножение или деление всех переменных на один коэффициент никак не повлияет на выбор планировщика. По умолчанию эти переменные определяются относительно стоимости чтения последовательной страницы: то есть, переменную <TT
CLASS="VARNAME"
>seq_page_cost</TT
> удобно задать равной <TT
CLASS="LITERAL"
>1.0</TT
>, а все другие переменные стоимости определить относительно неё. Но при желании можно использовать и другую шкалу, например, выразить в миллисекундах фактическое время выполнения запросов на конкретной машине.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>К сожалению, какого-либо чётко определённого способа определения идеальных значений стоимости не существует. Лучше всего выбирать их как средние показатели при выполнении целого ряда разнообразных запросов, которые будет обрабатывать конкретная СУБД. Это значит, что менять их по результатам всего нескольких экспериментов очень рискованно.</P
></BLOCKQUOTE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SEQ-PAGE-COST"
></A
><TT
CLASS="VARNAME"
>seq_page_cost</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт приблизительную стоимость чтения одной страницы с диска, которое выполняется в серии последовательных чтений. Значение по умолчанию равно 1.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <A
HREF="sql-altertablespace.html"
>ALTER TABLESPACE</A
>).</P
></DD
><DT
><A
NAME="GUC-RANDOM-PAGE-COST"
></A
><TT
CLASS="VARNAME"
>random_page_cost</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт приблизительную стоимость чтения одной произвольной страницы с диска. Значение по умолчанию равно 4.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <A
HREF="sql-altertablespace.html"
>ALTER TABLESPACE</A
>).</P
><P
>При уменьшении этого значения по отношению к <TT
CLASS="VARNAME"
>seq_page_cost</TT
> система начинает предпочитать сканирование по индексу; при увеличении такое сканирование становится более дорогостоящим. Оба эти значения также можно увеличить или уменьшить одновременно, чтобы изменить стоимость операций ввода/вывода по отношению к стоимости процессорных операций, которая определяется следующими параметрами.</P
><P
>Произвольный доступ к механическому дисковому хранилищу обычно гораздо дороже последовательного доступа, более чем в четыре раза. Однако по умолчанию выбран небольшой коэффициент (4.0), в предположении, что большой объём данных при произвольном доступе, например, при чтении индекса, окажется в кеше. Таким образом, можно считать, что значение по умолчанию моделирует ситуацию, когда произвольный доступ в 40 раз медленнее последовательного, но 90% операций произвольного чтения удовлетворяются из кеша.</P
><P
>Если вы считаете, что для вашей рабочей нагрузки процент попаданий не достигает 90%, вы можете уменьшить параметр random_page_cost, чтобы он больше соответствовал реальной стоимости произвольного чтения. И напротив, если ваши данные могут полностью поместиться в кеше, например, когда размер базы меньше общего объёма памяти сервера, может иметь смысл уменьшить random_page_cost. С хранилищем, у которого стоимость произвольного чтения не намного выше последовательного, как например, у твердотельных накопителей, так же лучше выбрать меньшее значение random_page_cost.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Хотя система позволяет сделать <TT
CLASS="VARNAME"
>random_page_cost</TT
> меньше, чем <TT
CLASS="VARNAME"
>seq_page_cost</TT
>, это лишено физического смысла. Однако сделать их равными имеет смысл, если база данных полностью кешируется в ОЗУ, так как в этом случае с обращением к страницам в произвольном порядке не связаны никакие дополнительные издержки. Кроме того, для сильно загруженной базы данных оба этих параметра следует понизить по отношению к стоимости процессорных операций, так как стоимость выборки страницы, уже находящейся в ОЗУ, оказывается намного меньше, чем обычно.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-CPU-TUPLE-COST"
></A
><TT
CLASS="VARNAME"
>cpu_tuple_cost</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт приблизительную стоимость обработки каждой строки при выполнении запроса. Значение по умолчанию — 0.01.</P
></DD
><DT
><A
NAME="GUC-CPU-INDEX-TUPLE-COST"
></A
><TT
CLASS="VARNAME"
>cpu_index_tuple_cost</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт приблизительную стоимость обработки каждой записи индекса при сканировании индекса. Значение по умолчанию — 0.005.</P
></DD
><DT
><A
NAME="GUC-CPU-OPERATOR-COST"
></A
><TT
CLASS="VARNAME"
>cpu_operator_cost</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт приблизительную стоимость обработки оператора или функции при выполнении запроса. Значение по умолчанию — 0.0025.</P
></DD
><DT
><A
NAME="GUC-EFFECTIVE-CACHE-SIZE"
></A
><TT
CLASS="VARNAME"
>effective_cache_size</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Определяет представление планировщика об эффективном размере дискового кеша, доступном для одного запроса. Это представление влияет на оценку стоимости использования индекса; чем выше это значение, тем больше вероятность, что будет применяться сканирование по индексу, чем ниже, тем более вероятно, что будет выбрано последовательное сканирование. При установке этого параметра следует учитывать и объём разделяемых буферов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, и процент дискового кеша ядра, который будут занимать файлы данных <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Кроме того, следует принять во внимание ожидаемое число параллельных запросов к разным таблицам, так как общий размер будет разделяться между ними. Этот параметр не влияет на размер разделяемой памяти, выделяемой <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, или размер резервируемого кеша ядра; он используется только для целей оценки стоимости. При этом система не учитывает, что данные могут оставаться в дисковом кеше от запроса к запросу. Значение этого параметра по умолчанию — 4 гигабайта (<TT
CLASS="LITERAL"
>4GB</TT
>).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-QUERY-GEQO"
>18.7.3. Генетический оптимизатор запросов</A
></H2
><P
>Генетический оптимизатор запросов (GEnetic Query Optimizer, GEQO) осуществляет планирование запросов, применяя эвристический поиск. Это позволяет сократить время планирования для сложных запросов (в которых соединяются множество отношений), ценой того, что иногда полученные планы уступают по качеству планам, выбираемым при полном переборе. За дополнительными сведениями обратитесь к <A
HREF="geqo.html"
>Главе 54</A
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-GEQO"
></A
><TT
CLASS="VARNAME"
>geqo</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>) </DT
><DD
><P
>Включает или отключает генетическую оптимизацию запросов. По умолчанию она включена. В производственной среде её лучше не отключать; более гибко управлять GEQO можно с помощью переменной <TT
CLASS="VARNAME"
>geqo_threshold</TT
>.</P
></DD
><DT
><A
NAME="GUC-GEQO-THRESHOLD"
></A
><TT
CLASS="VARNAME"
>geqo_threshold</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт минимальное число элементов во <TT
CLASS="LITERAL"
>FROM</TT
>, при котором для планирования запроса будет привлечён генетический оптимизатор. (Заметьте, что конструкция <TT
CLASS="LITERAL"
>FULL OUTER JOIN</TT
> считается одним элементом списка <TT
CLASS="LITERAL"
>FROM</TT
>.) Значение по умолчанию — 12. Для более простых запросов часто лучше использовать обычный планировщик, производящий полный перебор, но для запросов со множеством таблиц полный перебор займёт слишком много времени, чаще гораздо больше, чем будет потеряно из-за выбора не самого эффективного плана. Таким образом, ограничение по размеру запроса даёт удобную возможность управлять GEQO.</P
></DD
><DT
><A
NAME="GUC-GEQO-EFFORT"
></A
><TT
CLASS="VARNAME"
>geqo_effort</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Управляет выбором между сокращением временем планирования и повышением качества плана запроса в GEQO. Это значение должна задаваться целым числом от 1 до 10. Значение по умолчанию равно пяти. Чем больше значение этого параметра, тем больше времени будет потрачено на планирование запроса, но и тем больше вероятность, что будет выбран эффективный план.</P
><P
>Параметр <TT
CLASS="VARNAME"
>geqo_effort</TT
> сам по себе ничего не делает, он используется только для вычисления значений по умолчанию для других переменных, влияющих на поведение GEQO (они описаны ниже). При желании эти переменные можно просто установить вручную.</P
></DD
><DT
><A
NAME="GUC-GEQO-POOL-SIZE"
></A
><TT
CLASS="VARNAME"
>geqo_pool_size</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт размер пула для алгоритма GEQO, то есть число особей в генетической популяции. Это число должно быть не меньше двух, но полезные значения обычно лежат в интервале от 100 до 1000. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из значения <TT
CLASS="VARNAME"
>geqo_effort</TT
> и числа таблиц в запросе.</P
></DD
><DT
><A
NAME="GUC-GEQO-GENERATIONS"
></A
><TT
CLASS="VARNAME"
>geqo_generations</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт число поколений для GEQO, то есть число итераций этого алгоритма. Оно должно быть не меньше единицы, но полезные значения находятся в том же диапазоне, что и размер пула. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из <TT
CLASS="VARNAME"
>geqo_pool_size</TT
>.</P
></DD
><DT
><A
NAME="GUC-GEQO-SELECTION-BIAS"
></A
><TT
CLASS="VARNAME"
>geqo_selection_bias</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт интенсивность селекции для GEQO, то есть селективное давление в популяции. Допустимые значения лежат в диапазоне от 1.50 до 2.00 (это значение по умолчанию).</P
></DD
><DT
><A
NAME="GUC-GEQO-SEED"
></A
><TT
CLASS="VARNAME"
>geqo_seed</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт начальное значение для генератора случайных чисел, который применяется в GEQO для выбора случайных путей в пространстве поиска порядка соединений. Может иметь значение от нуля (по умолчанию) до одного. При изменении этого значения меняется набор анализируемых путей, в результате чего может быть найден как более, так и менее оптимальный путь.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-QUERY-OTHER"
>18.7.4. Другие параметры планировщика</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-DEFAULT-STATISTICS-TARGET"
></A
><TT
CLASS="VARNAME"
>default_statistics_target</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Устанавливает целевое ограничение статистики по умолчанию, распространяющееся на колонки, для которых командой <TT
CLASS="COMMAND"
>ALTER TABLE SET STATISTICS</TT
> не заданы отдельные ограничения. Чем больше установленное значение, тем больше времени требуется для выполнения <TT
CLASS="COMMAND"
>ANALYZE</TT
>, но тем выше может быть качество оценок планировщика. Значение этого параметра по умолчанию &mdash; 100. За дополнительными сведениями об использовании статистики планировщиком запросов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> обратитесь к <A
HREF="planner-stats.html"
>Разделу 14.2</A
>.</P
></DD
><DT
><A
NAME="GUC-CONSTRAINT-EXCLUSION"
></A
><TT
CLASS="VARNAME"
>constraint_exclusion</TT
> (<TT
CLASS="TYPE"
>enum</TT
>) </DT
><DD
><P
>Управляет использованием ограничений таблиц для оптимизации запросов. Допустимые значения <TT
CLASS="VARNAME"
>constraint_exclusion</TT
>: <TT
CLASS="LITERAL"
>on</TT
> (задействовать ограничения всех таблиц), <TT
CLASS="LITERAL"
>off</TT
> (никогда не задействовать ограничения) и <TT
CLASS="LITERAL"
>partition</TT
> (задействовать ограничения только для дочерних таблиц и подзапросов <TT
CLASS="LITERAL"
>UNION ALL</TT
>). Значение по умолчанию — <TT
CLASS="LITERAL"
>partition</TT
>. Оно часто помогает увеличить производительность, когда применяются секционированные таблицы и наследование.</P
><P
>Когда данный параметр разрешает использовать ограничения таблицы, планировщик сравнивает условия запроса с ограничениями <TT
CLASS="LITERAL"
>CHECK</TT
> данной таблицы, и не сканирует её, если они оказываются несовместимыми. Например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;</PRE
><P> Если включено использование ограничений, команда <TT
CLASS="COMMAND"
>SELECT</TT
> не будет сканировать таблицу <TT
CLASS="STRUCTNAME"
>child1000</TT
>, в результате чего запрос выполнится быстрее.</P
><P
>В настоящее время использование ограничений-исключений разрешено по умолчанию только в условиях, возникающих при реализации секционированных таблиц. Включение этой возможности для всех таблиц влечёт дополнительные издержки на планирование, довольно заметные для простых запросов, но никакого выигрыша это не приносит. Если вы не применяете секционированные таблицы, лучше всего полностью отключить эту возможность.</P
><P
>За дополнительными сведениями об ограничениях-исключениях и секционировании таблиц обратитесь к <A
HREF="ddl-partitioning.html#DDL-PARTITIONING-CONSTRAINT-EXCLUSION"
>Подразделу 5.9.4</A
>.</P
></DD
><DT
><A
NAME="GUC-CURSOR-TUPLE-FRACTION"
></A
><TT
CLASS="VARNAME"
>cursor_tuple_fraction</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>) </DT
><DD
><P
>Задаёт для планировщика оценку процента строк, которые будут получены через курсор. Значение по умолчанию — 0.1 (10%). При меньших значениях планировщик будет склонен использовать для курсоров планы с <SPAN
CLASS="QUOTE"
>"быстрым стартом"</SPAN
>, позволяющие получать первые несколько строк очень быстро, хотя для выборки всех строк может уйти больше времени. При больших значениях планировщик стремится оптимизировать общее время запроса. При максимальном значении, равном 1.0, работа с курсорами планируется так же, как и обычные запросы — минимизируется только общее время, а не время получения первых строк.</P
></DD
><DT
><A
NAME="GUC-FROM-COLLAPSE-LIMIT"
></A
><TT
CLASS="VARNAME"
>from_collapse_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное число элементов в списке <TT
CLASS="LITERAL"
>FROM</TT
>, до которого планировщик будет объединять вложенные запросы с внешним запросом. При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным. По умолчанию это значение равно восьми. За дополнительными сведениями обратитесь к <A
HREF="explicit-joins.html"
>Разделу 14.3</A
>.</P
><P
>Если это значение сделать равным <A
HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD"
>geqo_threshold</A
> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <A
HREF="runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO"
>Подраздел 18.7.3</A
>.</P
></DD
><DT
><A
NAME="GUC-JOIN-COLLAPSE-LIMIT"
></A
><TT
CLASS="VARNAME"
>join_collapse_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>) </DT
><DD
><P
>Задаёт максимальное количество элементов в списке <TT
CLASS="LITERAL"
>FROM</TT
>, до достижения которого планировщик будет сносить в него явные конструкции <TT
CLASS="LITERAL"
>JOIN</TT
> (за исключением <TT
CLASS="LITERAL"
>FULL JOIN</TT
>). При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным.</P
><P
>По умолчанию эта переменная имеет то же значение, что и <TT
CLASS="VARNAME"
>from_collapse_limit</TT
>, и это приемлемо в большинстве случаев. При значении, равном 1, предложения <TT
CLASS="LITERAL"
>JOIN</TT
> переставляться не будут, так что явно заданный в запросе порядок соединений определит фактический порядок, в котором будут соединяться отношения. Так как планировщик не всегда выбирает оптимальный порядок соединений, опытные пользователи могут временно задать для этой переменной значение 1, а затем явно определить желаемый порядок. За дополнительными сведениями обратитесь к <A
HREF="explicit-joins.html"
>Разделу 14.3</A
>.</P
><P
>Если это значение сделать равным <A
HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD"
>geqo_threshold</A
> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <A
HREF="runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO"
>Подраздел 18.7.3</A
>.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-replication.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-logging.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Репликация</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Регистрация ошибок и протоколирование работы сервера</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>