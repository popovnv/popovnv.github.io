<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Составные типы</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Типы данных"
HREF="datatype.html"><LINK
REL="PREVIOUS"
TITLE="Массивы"
HREF="arrays.html"><LINK
REL="NEXT"
TITLE="Диапазонные типы"
HREF="rangetypes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Массивы"
HREF="arrays.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 8. Типы данных</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Диапазонные типы"
HREF="rangetypes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ROWTYPES"
>8.16. Составные типы</A
></H1
><P
><I
CLASS="FIRSTTERM"
>Составной тип</I
> представляет структуру табличной строки или записи; по сути это просто список имён полей и соответствующих типов данных. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет использовать составные типы во многом так же, как и простые типы. Например, в определении таблицы можно объявить колонку составного типа.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7785"
>8.16.1. Объявление составных типов</A
></H2
><P
>Ниже приведены два простых примера определения составных типов: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);</PRE
><P> Синтаксис очень похож на <TT
CLASS="COMMAND"
>CREATE TABLE</TT
>, за исключением того, что он допускает только названия полей и их типы, какие-либо ограничения (такие как <TT
CLASS="LITERAL"
>NOT NULL</TT
>) в настоящее время не поддерживаются. Заметьте, что ключевое слово <TT
CLASS="LITERAL"
>AS</TT
> здесь имеет значение; без него система будет считать, что подразумевается другой тип команды <TT
CLASS="COMMAND"
>CREATE TYPE</TT
>, и выдаст неожиданную синтаксическую ошибку.</P
><P
>Определив такие типы, мы можем использовать их в таблицах: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);</PRE
><P> или функциях: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;

SELECT price_extension(item, 10) FROM on_hand;</PRE
><P></P
><P
>Всякий раз, когда создаётся таблица, вместе с ней автоматически создаётся составной тип, представляющий тип строки таблицы, именем которого будет имя таблицы. Например, при выполнении команды: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE inventory_item (
    name            text,
    supplier_id     integer REFERENCES suppliers,
    price           numeric CHECK (price &gt; 0)
);</PRE
><P> будет создан составной тип <TT
CLASS="LITERAL"
>inventory_item</TT
>, в точности соответствующий тому, что был показан выше, и использовать его можно так же. Заметьте, что в текущей реализации есть один недостаток: так как с составным типом не могут быть связаны ограничения, описанные в определении таблицы ограничения <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не применяются</I
></SPAN
> к значениям составного типа вне таблицы. (В некоторой степени это можно обойти, используя в составных типах домены.)</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7800"
>8.16.2. Ввод значения составного типа</A
></H2
><P
>Чтобы записать значение составного типа в виде текстовой константы, его поля нужно заключить в круглые скобки и разделить их запятыми. Значение любого поля можно заключить в кавычки, а если оно содержит запятые или скобки, это делать обязательно. (Подробности описаны ниже.) Таким образом, в общем виде константа составного типа записывается так: </P><PRE
CLASS="SYNOPSIS"
>'( <TT
CLASS="REPLACEABLE"
><I
>значение1</I
></TT
> , <TT
CLASS="REPLACEABLE"
><I
>значение2</I
></TT
> , ... )'</PRE
><P> Например, эта запись: </P><PRE
CLASS="PROGRAMLISTING"
>'("fuzzy dice",42,1.99)'</PRE
><P> будет допустимой для описанного выше типа <TT
CLASS="LITERAL"
>inventory_item</TT
>. Чтобы присвоить NULL одному из полей, в соответствующем месте в списке нужно оставить пустое место. Например, эта константа задаёт значение для третьего поля: </P><PRE
CLASS="PROGRAMLISTING"
>'("fuzzy dice",42,)'</PRE
><P> Если же вместо NULL требуется вставить пустую строку, нужно записать пару кавычек: </P><PRE
CLASS="PROGRAMLISTING"
>'("",42,)'</PRE
><P> Здесь в первом поле окажется пустая строка, а в третьем &mdash; NULL.</P
><P
>(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай констант, описанных в <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC"
>Подразделе 4.1.2.7</A
>. Константа изначально воспринимается как строка и передаётся процедуре преобразования составного типа. При этом может потребоваться явно указать целевой тип.)</P
><P
>Значения составных типов также можно конструировать, используя синтаксис выражения <TT
CLASS="LITERAL"
>ROW</TT
>. В большинстве случае это значительно проще, чем записывать значения в строке, так как при этом не нужно беспокоиться о вложенности кавычек. Мы уже обсуждали этот метод ранее: </P><PRE
CLASS="PROGRAMLISTING"
>ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)</PRE
><P> Ключевое слово ROW на самом деле может быть необязательным, если в выражении определяются несколько полей, так что эту запись можно упростить до: </P><PRE
CLASS="PROGRAMLISTING"
>('fuzzy dice', 42, 1.99)
('', 42, NULL)</PRE
><P> Синтаксис выражения <TT
CLASS="LITERAL"
>ROW</TT
> более подробно рассматривается в <A
HREF="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS"
>Подразделе 4.2.13</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7821"
>8.16.3. Обращение к составным типам</A
></H2
><P
>Чтобы обратиться к полю колонки составного типа, после имени колонки нужно добавить точку и имя поля, подобно тому, как указывается колонка после имени таблицы. На самом деле, эти обращения неотличимы, так что часто бывает необходимо использовать скобки, чтобы команда была разобрана правильно. Например, можно попытаться выбрать поле колонки из тестовой таблицы <TT
CLASS="LITERAL"
>on_hand</TT
> таким образом: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT item.name FROM on_hand WHERE item.price &gt; 9.99;</PRE
><P> Но это не будет работать, так как согласно правилам SQL имя <TT
CLASS="LITERAL"
>item</TT
> здесь воспринимается как имя таблицы, а не колонки в таблице <TT
CLASS="LITERAL"
>on_hand</TT
>. Поэтому этот запрос нужно переписать так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;</PRE
><P> либо указать также и имя таблицы (например, в запросе с многими таблицами), примерно так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;</PRE
><P> В результате объект в скобках будет правильно интерпретирован как ссылка на колонку <TT
CLASS="LITERAL"
>item</TT
>, из которой выбирается поле.</P
><P
>При выборке поля из значения составного типа также возможны подобные синтаксические казусы. Например, чтобы выбрать одно поле из результата функции, возвращающей составное значение, потребуется написать что-то подобное: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT (my_func(...)).field FROM ...</PRE
><P> Без дополнительных скобок в этом запросе произойдёт синтаксическая ошибка.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7833"
>8.16.4. Изменение составных типов</A
></H2
><P
>Ниже приведены примеры правильных команд добавления и изменения значений составных колонок. Первые команды иллюстрируют добавление или изменение всей колонки: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO mytab (complex_col) VALUES((1.1,2.2));

UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;</PRE
><P> В первом примере опущено ключевое слово <TT
CLASS="LITERAL"
>ROW</TT
>, а во втором оно есть; присутствовать или отсутствовать оно может в обоих случаях.</P
><P
>Мы можем изменить также отдельное поле составной колонки: </P><PRE
CLASS="PROGRAMLISTING"
>UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;</PRE
><P> Заметьте, что при этом не нужно (и на самом деле даже нельзя) заключать в скобки имя колонки, следующее сразу за предложением <TT
CLASS="LITERAL"
>SET</TT
>, но в ссылке на ту же колонку в выражении, находящемся по правую сторону знака равенства, скобки обязательны.</P
><P
>И мы также можем указать поля в качестве цели команды <TT
CLASS="COMMAND"
>INSERT</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);</PRE
><P> Если при этом мы не укажем значения для всех полей колонки, оставшиеся поля будут заполнены значениями NULL.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ROWTYPES-IO-SYNTAX"
>8.16.5. Синтаксис вводимых и выводимых значений составного типа</A
></H2
><P
>Внешнее текстовое представление составного значения состоит из записи элементов, интерпретируемых по правилам ввода/вывода для соответствующих типов полей, и оформления структуры составного типа. Оформление состоит из круглых скобок (<TT
CLASS="LITERAL"
>(</TT
> и <TT
CLASS="LITERAL"
>)</TT
>) окружающих всё значение, и запятых (<TT
CLASS="LITERAL"
>,</TT
>) между его элементами. Пробельные символы вне скобок игнорируются, но внутри они считаются частью соответствующего элемента и могут учитываться или не учитываться в зависимости от правил преобразования вводимых данных для типа этого элемента. Например, в записи: </P><PRE
CLASS="PROGRAMLISTING"
>'(  42)'</PRE
><P> пробелы будут игнорироваться, если соответствующее поле имеет целочисленный тип, но не текстовый.</P
><P
>Как было показано ранее, записывая составное значение, любой его элемент можно заключить в кавычки. Это <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>нужно</I
></SPAN
> делать, если при разборе этого значения без кавычек возможна неоднозначность. Например, в кавычки нужно заключать элементы, содержащие скобки, кавычки, запятую или обратную косую черту. Чтобы включить в поле составного значения, заключённое в кавычки, такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавычки в значении поля, заключённого в кавычки, воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть синтаксиса составного значения, с помощью спецпоследовательностей.</P
><P
>Значение NULL в этой записи представляется пустым местом (когда между запятыми или скобками нет никаких символов). Чтобы ввести именно пустую строку, а не NULL, нужно написать <TT
CLASS="LITERAL"
>""</TT
>.</P
><P
>Функция вывода составного значения заключает значения полей в кавычки, если они представляют собой пустые строки, либо содержат скобки, запятые, кавычки или обратную косую черту, либо состоят из одних пробелов. (В последнем случае можно обойтись без кавычек, но они добавляются для удобочитаемости.) Кавычки и обратная косая черта, заключённые в значения полей, при выводе дублируются.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая строка, а затем как составное значение. Вследствие этого число символов обратной косой черты удваивается (если используются спецпоследовательности). Например, чтобы ввести в поле составной колонки значение типа <TT
CLASS="TYPE"
>text</TT
> с обратной косой чертой и кавычками, команду нужно будет записать так: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT ... VALUES (E'("\\"\\\\")');</PRE
><P> Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой черты, так что анализатор составного значения получает на вход <TT
CLASS="LITERAL"
>("\"\\")</TT
>. В свою очередь, он передаёт эту строку процедуре ввода значения типа <TT
CLASS="TYPE"
>text</TT
>, где она преобразуются в <TT
CLASS="LITERAL"
>"\</TT
>. (Если бы мы работали с типом данных, процедура ввода которого также интерпретирует обратную косую черту особым образом, например <TT
CLASS="TYPE"
>bytea</TT
>, нам могло бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в поле составного значения.) Во избежание такого дублирования спецсимволов строки можно заключать в доллары (см. <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING"
>Подраздел 4.1.2.4</A
>).</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Записывать составные значения в командах SQL часто бывает удобнее с помощью конструктора <TT
CLASS="LITERAL"
>ROW</TT
>. В <TT
CLASS="LITERAL"
>ROW</TT
> отдельные значения элементов записываются так же, как если бы они не были членами составного выражения.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="rangetypes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Массивы</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Диапазонные типы</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>