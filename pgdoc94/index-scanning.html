<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Сканирование индекса</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Определение интерфейса для методов доступа индекса"
HREF="indexam.html"><LINK
REL="PREVIOUS"
TITLE="Функции для метода доступа индекса"
HREF="index-functions.html"><LINK
REL="NEXT"
TITLE="Замечания о блокировке с индексами"
HREF="index-locking.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Функции для метода доступа индекса"
HREF="index-functions.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexam.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 55. Определение интерфейса для методов доступа индекса</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Замечания о блокировке с индексами"
HREF="index-locking.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INDEX-SCANNING"
>55.3. Сканирование индекса</A
></H1
><P
>В процессе сканирования метод доступа индекса отвечает только за выдачу идентификаторов всех кортежей, которые по его представлению соответствуют <I
CLASS="FIRSTTERM"
>ключам сканирования</I
>. Метод доступа <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> участвует в самой процедуре выборки этих кортежей из основной таблицы и не определяет, удовлетворяют ли эти кортежи условиям видимости или другим ограничениям.</P
><P
>Ключом сканирования является внутреннее представление предложения <TT
CLASS="LITERAL"
>WHERE</TT
> в виде <TT
CLASS="REPLACEABLE"
><I
>ключ_индекса</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>константа</I
></TT
>, где ключ индекса — одна из колонок индекса, а оператор — один из членов семейства операторов, связанного с типом данной колонки. При сканировании по индексу могут задаваться несколько или ноль ключей сканирования, результаты поиска которых должны неявно объединяться операцией AND &mdash; ожидается, что возвращаемые кортежи будут удовлетворять всем заданным условиям.</P
><P
>Метод доступа для конкретного запроса может сообщить, что индекс является <I
CLASS="FIRSTTERM"
>неточным</I
> или, другими словами, требует перепроверки. Это подразумевает, что при сканировании индекса будут возвращены все записи, соответствующие ключу сканирования, плюс, возможно, дополнительные записи, которые ему не соответствуют. Внутренний механизм сканирования затем повторно применит условия индекса к кортежу данных, чтобы проверить, нужно ли его выбирать на самом деле. Если признак перепроверки не установлен, при сканировании индекса должны возвращаться только соответствующие ключам записи.</P
><P
>Заметьте, что именно метод доступа должен гарантировать, что корректно будут найдены все и только те записи, которые соответствуют всем переданным ключам сканирования. Также учтите, что ядро системы просто передаёт все предложения <TT
CLASS="LITERAL"
>WHERE</TT
> с подходящими ключами индекса и семействами операторов, не проводя семантический анализ на предмет их избыточности или противоречивости. Например, с условием <TT
CLASS="LITERAL"
>WHERE x &gt; 4 AND x &gt; 14</TT
>, где <TT
CLASS="LITERAL"
>x</TT
> — колонка с индексом-B-деревом, именно самой функции <CODE
CLASS="FUNCTION"
>amrescan</CODE
> в методе B-дерева предоставляется возможность понять, что первый ключ сканирования избыточный и может быть отброшен. Объём предварительной обработки, которую нужно произвести для этого в <CODE
CLASS="FUNCTION"
>amrescan</CODE
>, зависит от того, до какой степени метод доступа должен сводить ключи к <SPAN
CLASS="QUOTE"
>"нормализованной"</SPAN
> форме.</P
><P
>Некоторые методы доступа возвращают записи индекса в чётко определённом порядке, в отличие от других. Фактически есть два различных варианта реализации упорядоченного вывода некоторым методом доступа: <P
></P
></P><UL
><LI
><P
>Для методов доступа, которые всегда возвращают записи в порядке их естественной сортировки (как например, в B-дереве), устанавливается признак <TT
CLASS="STRUCTNAME"
>pg_am</TT
>.<TT
CLASS="STRUCTFIELD"
>amcanorder</TT
>. В настоящее время операторам проверки равенства и упорядочивания при этом должны назначаться номера соответствующих стратегий B-дерева.</P
></LI
><LI
><P
>Для методов доступа, которые поддерживают операторы упорядочивания, устанавливается признак <TT
CLASS="STRUCTNAME"
>pg_am</TT
>.<TT
CLASS="STRUCTFIELD"
>amcanorderbyop</TT
>. Он показывает, что индекс может возвращать записи в порядке, определяемом предложением <TT
CLASS="LITERAL"
>ORDER BY</TT
> <TT
CLASS="REPLACEABLE"
><I
>ключ_индекса</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>константа</I
></TT
>. Модификаторы для такого сканирования могут передаваться в <CODE
CLASS="FUNCTION"
>amrescan</CODE
>, как описывалось ранее.</P
></LI
></UL
><P></P
><P
>У функции <CODE
CLASS="FUNCTION"
>amgettuple</CODE
> есть аргумент <TT
CLASS="LITERAL"
>direction</TT
>, который может принимать значение <TT
CLASS="LITERAL"
>ForwardScanDirection</TT
> (обычный вариант, сканирование вперёд) или <TT
CLASS="LITERAL"
>BackwardScanDirection</TT
> (сканирование назад). Если в первом вызове после <CODE
CLASS="FUNCTION"
>amrescan</CODE
> указывается <TT
CLASS="LITERAL"
>BackwardScanDirection</TT
>, то множество соответствующих записей индекса сканируется от конца к началу, а не в обычном направлении от начала к концу. В этом случае <CODE
CLASS="FUNCTION"
>amgettuple</CODE
> должна вернуть последний соответствующий кортеж индекса, а не первый как обычно. (Это распространяется только на методы доступа с установленным признаком <TT
CLASS="STRUCTFIELD"
>amcanorder</TT
>.) После первого вызова <CODE
CLASS="FUNCTION"
>amgettuple</CODE
> должна быть готова продолжать сканирование в любом направлении от записи, выданной последней до этого. (Но если признак <TT
CLASS="STRUCTNAME"
>pg_am</TT
>.<TT
CLASS="STRUCTFIELD"
>amcanbackward</TT
> не установлен, при всех последующих вызовах должно сохраняться то же направление, что было в первом.)</P
><P
>Методы доступа, которые поддерживают упорядоченное сканирование, должны уметь <SPAN
CLASS="QUOTE"
>"помечать"</SPAN
> позицию сканирования и затем возвращаться к помеченной позиции (возможно, несколько раз к одной и той же позиции). Но запоминаться должна только одна позиция в ходе сканирования; последующий вызов <CODE
CLASS="FUNCTION"
>ammarkpos</CODE
> переопределяет ранее сохранённую позицию. Метод доступа, не поддерживающий упорядоченное сканирование, тоже может предоставить функции для отметки и восстановления позиции в <TT
CLASS="STRUCTNAME"
>pg_am</TT
>, но будет достаточно, если эти функции при вызове будут просто выдавать ошибки.</P
><P
>И позиция сканирования, и отмеченная позиция (при наличии) должны поддерживаться в согласованном состоянии с учётом одновременных добавлений или удалений записей в индексе. Не будет ошибкой, если только что вставленная запись не будет выдана при сканировании, которое могло бы найти эту запись, если бы она существовала до его начала, либо если сканирование выдаст такую запись после перезапуска или возврата, даже если она не была выдана в первый раз. Подобным образом, параллельное удаление может отражаться, а может и не отражаться в результатах сканирования. Важно только, чтобы при таких операциях добавления или удаления не происходило потерь или дублирования записей, которые в этих операциях не участвовали.</P
><P
>Если индекс сохраняет исходные индексируемые значения данных (а не их искажённое представление), обычно полезно поддержать сканирование только индекса, в котором индекс возвращает фактические данные, а не только TID кортежа данных. Это будет работать, только если карта видимости показывает, что TID относится к полностью видимой странице; в противном случае всё равно придётся посетить кортеж, чтобы проверить его видимость для MVCC. Но это не является заботой метода доступа.</P
><P
>Вместо <CODE
CLASS="FUNCTION"
>amgettuple</CODE
>, сканирование индекса может осуществляться функцией <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
>, которая выбирает все кортежи за один вызов. Это может быть значительно эффективнее <CODE
CLASS="FUNCTION"
>amgettuple</CODE
>, так как позволяет избежать циклов блокировки/разблокировки в методе доступа. В принципе, <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
> должна давать тот же эффект, что и многократные вызовы <CODE
CLASS="FUNCTION"
>amgettuple</CODE
>, но простоты ради мы накладываем ряд дополнительных ограничений. Во-первых, <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
> возвращает все кортежи сразу и не поддерживает пометку позиций и возвращение к ним. Во-вторых, кортежи, возвращаемые в битовой карте, не упорядочиваются каким-либо определённым образом, поэтому <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
> не принимает аргумент <TT
CLASS="LITERAL"
>direction</TT
>. (И операторы упорядочивания никогда не будут передаваться для такого сканирования.) Кроме того, сканирование только индекса с <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
> неосуществимо, так как нет никакой возможности возвратить содержимое кортежей индекса. Наконец, <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
> не гарантирует, что будут установлены какие-либо блокировки для возвращаемых кортежей, и следствия этого описаны в <A
HREF="index-locking.html"
>Разделе 55.4</A
>.</P
><P
>Заметьте, что метод доступа может реализовывать только функцию <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
>, но не <CODE
CLASS="FUNCTION"
>amgettuple</CODE
>, и наоборот, если его внутренняя реализация несовместима с одной из этих функций.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index-functions.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="index-locking.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Функции для метода доступа индекса</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indexam.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Замечания о блокировке с индексами</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>