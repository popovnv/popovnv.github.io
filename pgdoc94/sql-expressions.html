<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Выражения значения</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Синтаксис SQL"
HREF="sql-syntax.html"><LINK
REL="PREVIOUS"
TITLE="Лексическая структура"
HREF="sql-syntax-lexical.html"><LINK
REL="NEXT"
TITLE="Вызов функций"
HREF="sql-syntax-calling-funcs.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Лексическая структура"
HREF="sql-syntax-lexical.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 4. Синтаксис SQL</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Вызов функций"
HREF="sql-syntax-calling-funcs.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SQL-EXPRESSIONS"
>4.2. Выражения значения</A
></H1
><P
>Выражения значения применяются в самых разных контекстах, например в списке результатов команды <TT
CLASS="COMMAND"
>SELECT</TT
>, в значениях колонок в <TT
CLASS="COMMAND"
>INSERT</TT
> или <TT
CLASS="COMMAND"
>UPDATE</TT
> или в условиях поиска во многих командах. Результат такого выражения иногда называют <I
CLASS="FIRSTTERM"
>скаляром</I
>, чтобы отличить его от результата табличного выражения (который представляет собой таблицу). А сами выражения значения часто называют <I
CLASS="FIRSTTERM"
>скалярными</I
> (или просто <I
CLASS="FIRSTTERM"
>выражениями</I
>). Синтаксис таких выражений позволяет вычислять значения из примитивных частей, используя арифметические, логические и другие операции.</P
><P
>Выражениями значения являются: <P
></P
></P><UL
><LI
><P
>Константа или непосредственное значение</P
></LI
><LI
><P
>Ссылка на колонку</P
></LI
><LI
><P
>Ссылка на позиционный параметр в теле определения функции или подготовленного оператора</P
></LI
><LI
><P
>Выражение с индексом</P
></LI
><LI
><P
>Выражение выбора поля</P
></LI
><LI
><P
>Применение оператора</P
></LI
><LI
><P
>Вызов функции</P
></LI
><LI
><P
>Агрегатное выражение</P
></LI
><LI
><P
>Вызов оконной функции</P
></LI
><LI
><P
>Приведение типов</P
></LI
><LI
><P
>Применение правил сортировки</P
></LI
><LI
><P
>Скалярный подзапрос</P
></LI
><LI
><P
>Конструктор массива</P
></LI
><LI
><P
>Конструктор табличной строки</P
></LI
><LI
><P
>Кроме того, выражением значения являются скобки (предназначенные для группировки подвыражений и переопределения приоритета )</P
></LI
></UL
><P></P
><P
>В дополнение к этому списку есть ещё несколько конструкций, которые можно классифицировать как выражения, хотя они не соответствуют общим синтаксическим правилам. Они обычно имеют вид функции или оператора и будут рассмотрены в соответствующем разделе <A
HREF="functions.html"
>Главы 9</A
>. Пример такой конструкции &mdash; предложение <TT
CLASS="LITERAL"
>IS NULL</TT
>.</P
><P
>Мы уже обсудили константы в <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS"
>Подразделе 4.1.2</A
>. В следующих разделах рассматриваются остальные варианты.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-EXPRESSIONS-COLUMN-REFS"
>4.2.1. Ссылки на колонки</A
></H2
><P
>Ссылку на колонку можно записать в форме: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>отношение</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
></PRE
><P></P
><P
>Здесь <TT
CLASS="REPLACEABLE"
><I
>отношение</I
></TT
> &mdash; имя таблицы (возможно, полное, с именем схемы) или её псевдоним, определённый в предложении <TT
CLASS="LITERAL"
>FROM</TT
>. Это имя и разделяющую точку можно опустить, если имя колонки уникально среди всех таблиц, задействованных в текущем запросе. (См. также <A
HREF="queries.html"
>Главу 7</A
>.)</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-EXPRESSIONS-PARAMETERS-POSITIONAL"
>4.2.2. Позиционные параметры</A
></H2
><P
>Ссылка на позиционный параметр применяется для обращения к значению, переданному в SQL-оператор извне. Параметры используются в определениях SQL-функций и подготовленных операторов. Некоторые клиентские библиотеки также поддерживают передачу значений данных отдельно от самой SQL-команды, и в этом случае параметры позволяют ссылаться на такие значения. Ссылка на параметр записывается в следующей форме: </P><PRE
CLASS="SYNOPSIS"
>$<TT
CLASS="REPLACEABLE"
><I
>число</I
></TT
></PRE
><P></P
><P
>Например, рассмотрим следующее определение функции <CODE
CLASS="FUNCTION"
>dept</CODE
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;</PRE
><P> Здесь <TT
CLASS="LITERAL"
>$1</TT
> всегда будет ссылаться на значение первого аргумента функции.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-EXPRESSIONS-SUBSCRIPTS"
>4.2.3. Индексы элементов</A
></H2
><P
>Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, написав: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
>[<TT
CLASS="REPLACEABLE"
><I
>индекс</I
></TT
>]</PRE
><P> или несколько соседних элементов (<SPAN
CLASS="QUOTE"
>"срез массива"</SPAN
>): </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
>[<TT
CLASS="REPLACEABLE"
><I
>нижний_индекс</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>верхний_индекс</I
></TT
>]</PRE
><P> (Здесь квадратные скобки <TT
CLASS="LITERAL"
>[ ]</TT
> должны быть в явном виде.) Каждый <TT
CLASS="REPLACEABLE"
><I
>индекс</I
></TT
> сам по себе является выражением, результатом которого должно быть целое число.</P
><P
>В общем случае <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> массива должно заключаться в круглые скобки, но их можно опустить, когда выражение с индексом &mdash; это просто ссылка на колонку или позиционный параметр. Кроме того, можно соединить несколько индексов, если исходный массив многомерный. Например: </P><PRE
CLASS="PROGRAMLISTING"
>моя_таблица.колонка_массив[4]
моя_таблица.колонка_массив_2d[17][34]
$1[10:42]
(функция_массив(a,b))[42]</PRE
><P> В последней строке круглые скобки необходимы. Подробнее массивы рассматриваются в <A
HREF="arrays.html"
>Разделе 8.15</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FIELD-SELECTION"
>4.2.4. Выбор поля</A
></H2
><P
>Если результат выражения &mdash; значение составного типа (строка таблицы), тогда определённое поле этой строки можно извлечь, написав:</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>имя_поля</I
></TT
></PRE
><P></P
><P
>В общем случае <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> такого типа должно заключаться в круглые скобки, но их можно опустить, когда это ссылка на таблицу или позиционный параметр. Например: </P><PRE
CLASS="PROGRAMLISTING"
>моя_таблица.колонка
$1.колонка
(функция_кортеж(a,b)).кол3</PRE
><P> (Таким образом, полная ссылка на колонку &mdash; это просто частный случай выбора поля.) Важный особый случай здесь &mdash; извлечение поля из колонки составного типа: </P><PRE
CLASS="PROGRAMLISTING"
>(составная_колонка).поле
(моя_таблица.составная_колонка).поле</PRE
><P> Здесь скобки нужны, чтобы показать, что <TT
CLASS="STRUCTFIELD"
>составная_колонка</TT
> &mdash; это имя колонки, а не таблицы, и что <TT
CLASS="STRUCTNAME"
>моя_таблица</TT
> &mdash; имя таблицы, а не схемы.</P
><P
>В списке выборки (см. <A
HREF="queries-select-lists.html"
>Раздел 7.3</A
>) вы можете запросить все поля составного значения, написав <TT
CLASS="LITERAL"
>.*</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>(составная_колонка).*</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-EXPRESSIONS-OPERATOR-CALLS"
>4.2.5. Применение оператора</A
></H2
><P
>Существуют три возможных синтаксиса применения операторов: <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> (бинарный инфиксный оператор)</TD
></TR
><TR
><TD
><TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> (унарный префиксный оператор)</TD
></TR
><TR
><TD
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> (унарный постфиксный оператор)</TD
></TR
></TBODY
></TABLE
><P
></P
>где <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> соответствует синтаксическим правилам, описанным в <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS"
>Подразделе 4.1.3</A
>, либо это одно из ключевых слов <TT
CLASS="TOKEN"
>AND</TT
>, <TT
CLASS="TOKEN"
>OR</TT
> и <TT
CLASS="TOKEN"
>NOT</TT
>, либо полное имя оператора в форме: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="LITERAL"
>OPERATOR(</TT
><TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
><TT
CLASS="LITERAL"
>.</TT
><TT
CLASS="REPLACEABLE"
><I
>имя_оператора</I
></TT
><TT
CLASS="LITERAL"
>)</TT
></PRE
><P> Существование конкретных операторов и их тип (унарный или бинарный) зависит от того, как и какие операторы определены системой и пользователем. Встроенные операторы описаны в <A
HREF="functions.html"
>Главе 9</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-EXPRESSIONS-FUNCTION-CALLS"
>4.2.6. Вызовы функций</A
></H2
><P
>Вызов функции записывается просто как имя функции (возможно, дополненное именем схемы) и список аргументов в скобках: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ... </SPAN
>]</SPAN
>])</PRE
><P></P
><P
>Например, так вычисляется квадратный корень из 2: </P><PRE
CLASS="PROGRAMLISTING"
>sqrt(2)</PRE
><P></P
><P
>Список встроенных функций приведён в <A
HREF="functions.html"
>Главе 9</A
>. Пользователь также может определить и другие функции.</P
><P
>Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. <A
HREF="sql-syntax-calling-funcs.html"
>Раздел 4.3</A
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Функцию, принимающую один аргумент составного типа, можно также вызывать, используя синтаксис выбора поля, и наоборот, выбор поля можно записать в функциональном стиле. То есть записи <TT
CLASS="LITERAL"
>col(table)</TT
> и <TT
CLASS="LITERAL"
>table.col</TT
> равносильны и взаимозаменяемы. Это поведение не оговорено стандартом SQL, но реализовано в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, так как это позволяет использовать функции для эмуляции <SPAN
CLASS="QUOTE"
>"вычисляемых полей"</SPAN
>. Подробнее это описано в <A
HREF="xfunc-sql.html#XFUNC-SQL-COMPOSITE-FUNCTIONS"
>Подразделе 35.4.3</A
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYNTAX-AGGREGATES"
>4.2.7. Агрегатные выражения</A
></H2
><P
><I
CLASS="FIRSTTERM"
>Агрегатное выражение</I
> представляет собой применение агрегатной функции к строкам, выбранным запросом. Агрегатная функция сводит множество входных значений к одному выходному, как например, сумма или среднее. Агрегатное выражение может записываться следующим образом: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> ] ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ]
<TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> (ALL <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> ] ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ]
<TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> (DISTINCT <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> ] ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ]
<TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> ( * ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ]
<TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [ , ... ] ] ) WITHIN GROUP ( <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ]</PRE
><P> Здесь <TT
CLASS="REPLACEABLE"
><I
>агрегатная_функция</I
></TT
> &mdash; имя ранее определённой агрегатной функции (возможно, дополненное именем схемы), <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> &mdash; любое выражение значения, не содержащее в себе агрегатного выражения или вызова оконной функции. Необязательные предложения <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> описываются ниже.</P
><P
>В первой форме агрегатного выражения агрегатная функция вызывается для каждой строки. Вторая форма эквивалентна первой, так как указание <TT
CLASS="LITERAL"
>ALL</TT
> подразумевается по умолчанию. В третьей форме агрегатная функция вызывается для всех различных значений выражения (или набора различных значений, для нескольких выражений), выделенных во входных данных. В четвёртой форме агрегатная функция вызывается для каждой строки, так как никакого конкретного значения не указано (обычно это имеет смысл только для функции <CODE
CLASS="FUNCTION"
>count(*)</CODE
>). В последней форме используются <I
CLASS="FIRSTTERM"
>сортирующие</I
> агрегатные функции, которые будут описаны ниже.</P
><P
>Большинство агрегатных функций игнорируют значения NULL, так что строки, для которых выражения выдают одно или несколько значений NULL, отбрасываются. Это можно считать истинным для всех встроенных операторов, если явно не говорится об обратном.</P
><P
>Например, <TT
CLASS="LITERAL"
>count(*)</TT
> подсчитает общее количество строк, а <TT
CLASS="LITERAL"
>count(f1)</TT
> только количество строк, в которых <TT
CLASS="LITERAL"
>f1</TT
> не NULL (так как <CODE
CLASS="FUNCTION"
>count</CODE
> игнорирует NULL), а <TT
CLASS="LITERAL"
>count(distinct f1)</TT
> подсчитает число различных и отличных от NULL значений колонки <TT
CLASS="LITERAL"
>f1</TT
>.</P
><P
>Обычно строки данных передаются агрегатной функции в неопределённом порядке и во многих случаях это не имеет значения, например функция <CODE
CLASS="FUNCTION"
>min</CODE
> выдаёт один и тот же результат независимо от порядка поступающих данных. Однако некоторые агрегатные функции (такие как <CODE
CLASS="FUNCTION"
>array_agg</CODE
> и <CODE
CLASS="FUNCTION"
>string_agg</CODE
>) выдают результаты, зависящие от порядка данных. Для таких агрегатных функций можно добавить <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> и задать нужный порядок. Это <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> имеет тот же синтаксис, что и предложение <TT
CLASS="LITERAL"
>ORDER BY</TT
> на уровне запроса, как описано в <A
HREF="queries-order.html"
>Разделе 7.5</A
>, за исключением того, что его выражения должны быть просто выражениями, а не именами результирующих колонок или числами. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT array_agg(a ORDER BY b DESC) FROM table;</PRE
><P></P
><P
>Заметьте, что при использовании агрегатных функций с несколькими аргументами, предложение <TT
CLASS="LITERAL"
>ORDER BY</TT
> идёт после всех аргументов. Например, надо писать так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT string_agg(a, ',' ORDER BY a) FROM table;</PRE
><P> а не так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT string_agg(a ORDER BY a, ',') FROM table;  -- неправильно</PRE
><P> Последний вариант синтаксически допустим, но он представляет собой вызов агрегатной функции одного аргумента с двумя ключами <TT
CLASS="LITERAL"
>ORDER BY</TT
> (при этом второй не имеет смысла, так как это константа).</P
><P
>Если <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> дополнено указанием <TT
CLASS="LITERAL"
>DISTINCT</TT
>, тогда все выражения <TT
CLASS="LITERAL"
>ORDER BY</TT
> должны соответствовать обычным аргументам агрегатной функции; то есть вы не можете сортировать строки по выражению, не включённому в список <TT
CLASS="LITERAL"
>DISTINCT</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Возможность указывать и <TT
CLASS="LITERAL"
>DISTINCT</TT
>, и <TT
CLASS="LITERAL"
>ORDER BY</TT
> в агрегатной функции &mdash; это расширение <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></BLOCKQUOTE
></DIV
><P
>При добавлении <TT
CLASS="LITERAL"
>ORDER BY</TT
> в обычный список аргументов агрегатной функции, описанном до этого, выполняется сортировка строк для <SPAN
CLASS="QUOTE"
>"обычной"</SPAN
> агрегатной функции, для которой сортировка необязательна. Но есть подмножество агрегатных функций, <I
CLASS="FIRSTTERM"
>сортирующие агрегатные функции</I
>, для которых <TT
CLASS="REPLACEABLE"
><I
>предложение_order</I
></TT
> является <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>обязательным</I
></SPAN
>, обычно потому, что вычисление этой функции имеет смысл только при определённой сортировке входных строк. Типичными примерами сортирующих агрегатных функций являются вычисления ранга и перцентиля. Для сортирующей агрегатной функции <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> записывается внутри <TT
CLASS="LITERAL"
>WITHIN GROUP (...)</TT
>, что иллюстрирует последний пример, приведённый выше. Выражения в <TT
CLASS="REPLACEABLE"
><I
>предложении_order_by</I
></TT
> вычисляются однократно для каждой входной строки как аргументы обычной агрегатной функции, сортируемые в соответствии с требованием <TT
CLASS="REPLACEABLE"
><I
>предложения_order_by</I
></TT
>, и поступают в агрегатную функции как входящие аргументы. (Если же <TT
CLASS="REPLACEABLE"
><I
>предложение_order_by</I
></TT
> находится не в <TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>, оно не передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы, предшествующие <TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>, (если они есть), называются <I
CLASS="FIRSTTERM"
>прямыми аргументами</I
>, а выражения, указанные в <TT
CLASS="REPLACEABLE"
><I
>предложении_order_by</I
></TT
> &mdash; <I
CLASS="FIRSTTERM"
>агрегируемыми аргументами</I
>. В отличие от аргументов обычной агрегатной функции, прямые аргументы вычисляются однократно для каждого вызова функции, а не для каждой строки. Это значит, что они могут содержать переменные, только если эти переменные сгруппированы в <TT
CLASS="LITERAL"
>GROUP BY</TT
>; это суть то же ограничение, что действовало бы, будь эти прямые аргументы вне агрегатного выражения. Прямые аргументы обычно используются, например, для указания значения перцентили, которое имеет смысл, только если это конкретное число для всего расчёта агрегатной функции. Список прямых аргументов может быть пуст; в этом случае запишите просто <TT
CLASS="LITERAL"
>()</TT
>, но не <TT
CLASS="LITERAL"
>(*)</TT
>. (На самом деле <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> примет обе записи, но только первая соответствует стандарту SQL.) Пример вызова сортирующей агрегатной функции: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489</PRE
><P> Здесь получается 50-ая перцентиль (или медиана) значения колонки <TT
CLASS="STRUCTFIELD"
>income</TT
> (доход) из таблицы <TT
CLASS="STRUCTNAME"
>households</TT
> (домочадцы). В данном случае, <TT
CLASS="LITERAL"
>0.5</TT
> &mdash; прямой аргумент; выражение не имело бы смысла, если бы этот аргумент зависел от обрабатываемых строк.</P
><P
>Если добавлено предложение <TT
CLASS="LITERAL"
>FILTER</TT
>, агрегатной функции подаются только те входные строки, для которых <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> вычисляется как истинное; другие строки отбрасываются. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)</PRE
><P></P
><P
>Предопределённые агрегатные функции описаны в <A
HREF="functions-aggregate.html"
>Разделе 9.20</A
>. Пользователь также может определить другие агрегатные функции.</P
><P
>Агрегатное выражение может фигурировать только в списке результатов или в предложении <TT
CLASS="LITERAL"
>HAVING</TT
> команды <TT
CLASS="COMMAND"
>SELECT</TT
>. Во всех остальных предложениях, например <TT
CLASS="LITERAL"
>WHERE</TT
>, они запрещены, так как эти предложения логически вычисляются до того, как формируются результаты агрегатных функций.</P
><P
>Когда агрегатное выражение используется в подзапросе (см. <A
HREF="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES"
>Подраздел 4.2.11</A
> и <A
HREF="functions-subquery.html"
>Раздел 9.22</A
>), оно обычно вычисляется для всех строк подзапроса. Но если в аргументах (или в <TT
CLASS="REPLACEABLE"
><I
>условии_filter</I
></TT
>) агрегатной функции есть только переменные внешнего уровня, агрегатная функция относится к ближайшему внешнему уровню и вычисляется для всех строк соответствующего запроса. Такое агрегатное выражение в целом является внешней ссылкой для своего подзапроса и на каждом вычислении считается константой. При этом допустимое положение агрегатной функции ограничивается списком результатов и предложением <TT
CLASS="LITERAL"
>HAVING</TT
> на том уровне запросов, где она находится.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYNTAX-WINDOW-FUNCTIONS"
>4.2.8. Вызовы оконных функций</A
></H2
><P
><I
CLASS="FIRSTTERM"
>Вызов оконной функции</I
> представляет собой применение функции, подобной агрегатной, к некоторому набору строк, выбранному запросом. В отличие от обычных агрегатных функций, оконные функции не связаны с группировкой выбранных строк в одну &mdash; каждая строка остаётся отдельной в результате запроса. Однако оконная функция может просканировать все строки, вошедшие в группу текущей строки согласно указанию (списку <TT
CLASS="LITERAL"
>PARTITION BY</TT
>) при вызове оконной функции. Вызов оконной функции может иметь следующие формы: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ... </SPAN
>]</SPAN
>]) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ] OVER <TT
CLASS="REPLACEABLE"
><I
>имя_окна</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ... </SPAN
>]</SPAN
>]) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ] OVER ( <TT
CLASS="REPLACEABLE"
><I
>определение_окна</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> ( * ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ] OVER <TT
CLASS="REPLACEABLE"
><I
>имя_окна</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> ( * ) [ FILTER ( WHERE <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> ) ] OVER ( <TT
CLASS="REPLACEABLE"
><I
>определение_окна</I
></TT
> )</PRE
><P> Здесь <TT
CLASS="REPLACEABLE"
><I
>определение_окна</I
></TT
> записывается в виде: </P><PRE
CLASS="SYNOPSIS"
>[ <TT
CLASS="REPLACEABLE"
><I
>имя_существующего_окна</I
></TT
> ]
[ PARTITION BY <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [, ...] ]
[ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <TT
CLASS="REPLACEABLE"
><I
>определение_рамки</I
></TT
> ]</PRE
><P> и необязательное <TT
CLASS="REPLACEABLE"
><I
>определение_рамки</I
></TT
> может иметь вид: </P><PRE
CLASS="SYNOPSIS"
>[ RANGE | ROWS ] <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
>
[ RANGE | ROWS ] BETWEEN <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> AND <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
></PRE
><P> Здесь <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
> задаются одним из следующих способов: </P><PRE
CLASS="SYNOPSIS"
>UNBOUNDED PRECEDING
<TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> PRECEDING
CURRENT ROW
<TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> FOLLOWING
UNBOUNDED FOLLOWING</PRE
><P></P
><P
>Здесь <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> &mdash; это любое выражение значения, не содержащее вызовов оконных функций.</P
><P
><TT
CLASS="REPLACEABLE"
><I
>имя_окна</I
></TT
> &mdash; ссылка на именованное окно, определённое предложением <TT
CLASS="LITERAL"
>WINDOW</TT
> в данном запросе. Также возможно написать в скобках полное <TT
CLASS="REPLACEABLE"
><I
>определение_окна</I
></TT
>, используя тот же синтаксис определения именованного окна в предложении <TT
CLASS="LITERAL"
>WINDOW</TT
>; подробнее это описано в справке по <A
HREF="sql-select.html"
>SELECT</A
>. Стоит отметить, что запись <TT
CLASS="LITERAL"
>OVER имя_окна</TT
> не полностью равнозначна <TT
CLASS="LITERAL"
>OVER (имя_окна)</TT
>; последний вариант подразумевает копирование и изменение определения окна и не будет допустимым, если определение этого окна включает определение рамки.</P
><P
>Указание <TT
CLASS="LITERAL"
>PARTITION BY</TT
> группирует строки запроса в <I
CLASS="FIRSTTERM"
>разделы</I
>, которые затем обрабатываются оконной функцией независимо друг от друга. <TT
CLASS="LITERAL"
>PARTITION BY</TT
> работает подобно предложению <TT
CLASS="LITERAL"
>GROUP BY</TT
> на уровне запроса, за исключением того, что его аргументы всегда просто выражения, а не имена выходных колонок или числа. Без <TT
CLASS="LITERAL"
>PARTITION BY</TT
> все строки, выдаваемые запросом, рассматриваются как один раздел. Указание <TT
CLASS="LITERAL"
>ORDER BY</TT
> определяет порядок, в котором оконная функция обрабатывает строки раздела. Оно так же подобно предложению <TT
CLASS="LITERAL"
>ORDER BY</TT
> на уровне запроса и так же не принимает имена выходных колонок или числа. Без <TT
CLASS="LITERAL"
>ORDER BY</TT
> строки обрабатываются в неопределённом порядке.</P
><P
><TT
CLASS="REPLACEABLE"
><I
>определение_рамки</I
></TT
> задаёт набор строк, образующих <I
CLASS="FIRSTTERM"
>рамку окна</I
>, которая представляет собой подмножество строк текущего раздела и используется для оконных функций, работающих с рамкой, а не со всем разделом. Рамку можно указать в режимах <TT
CLASS="LITERAL"
>RANGE</TT
> или <TT
CLASS="LITERAL"
>ROWS</TT
>; в любом случае она начинается с положения <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> и заканчивается положением <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
>. Если <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
> опущен, подразумевается <TT
CLASS="LITERAL"
>CURRENT ROW</TT
> (текущая строка).</P
><P
>Если <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> задано как <TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>, рамка начинается с первой строки раздела, а если <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
> определён как <TT
CLASS="LITERAL"
>UNBOUNDED FOLLOWING</TT
>, рамка заканчивается последней строкой раздела.</P
><P
>В режиме <TT
CLASS="LITERAL"
>RANGE</TT
> <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
>, заданное как <TT
CLASS="LITERAL"
>CURRENT ROW</TT
>, определяет в качестве начала первую <I
CLASS="FIRSTTERM"
>родственную</I
> строку (строку, которую <TT
CLASS="LITERAL"
>ORDER BY</TT
> считает равной текущей), тогда как <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
>, заданный как <TT
CLASS="LITERAL"
>CURRENT ROW</TT
>, определяет концом рамки последнюю родственную (для <TT
CLASS="LITERAL"
>ORDER BY</TT
>) строку. В режиме <TT
CLASS="LITERAL"
>ROWS</TT
> вариант <TT
CLASS="LITERAL"
>CURRENT ROW</TT
> просто обозначает текущую строку.</P
><P
>Варианты <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> <TT
CLASS="LITERAL"
>PRECEDING</TT
> и <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> <TT
CLASS="LITERAL"
>FOLLOWING</TT
> допускаются только в режиме <TT
CLASS="LITERAL"
>ROWS</TT
>. Они указывают, что рамка начинается или заканчивается со сдвигом на заданное число строк перед или после заданной строки. Здесь <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> должно быть целочисленным выражением, не содержащим переменные, агрегатные или оконные функции, и может быть нулевым, что будет означать выбор текущей строки.</P
><P
>По умолчанию рамка определяется как <TT
CLASS="LITERAL"
>RANGE UNBOUNDED PRECEDING</TT
>, что равносильно расширенному определению <TT
CLASS="LITERAL"
>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</TT
>. С указанием <TT
CLASS="LITERAL"
>ORDER BY</TT
> это означает, что рамка будет включать все строки от начала раздела до последней строки, родственной текущей (для <TT
CLASS="LITERAL"
>ORDER BY</TT
>). Без <TT
CLASS="LITERAL"
>ORDER BY</TT
> в рамку включаются все строки раздела, так как все они считаются родственными текущей.</P
><P
>Действуют также ограничения: <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> не может определяться как <TT
CLASS="LITERAL"
>UNBOUNDED FOLLOWING</TT
>, а <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
> &mdash; <TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>, и <TT
CLASS="REPLACEABLE"
><I
>конец_рамки</I
></TT
> не может определяться раньше, чем <TT
CLASS="REPLACEABLE"
><I
>начало_рамки</I
></TT
> &mdash; например, запись <TT
CLASS="LITERAL"
>RANGE BETWEEN CURRENT ROW AND <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> PRECEDING</TT
> недопустима.</P
><P
>Если добавлено предложение <TT
CLASS="LITERAL"
>FILTER</TT
>, оконной функции подаются только те входные строки, для которых <TT
CLASS="REPLACEABLE"
><I
>условие_фильтра</I
></TT
> вычисляется как истинное; другие строки отбрасываются. Предложение <TT
CLASS="LITERAL"
>FILTER</TT
> допускается только для агрегирующих оконных функций.</P
><P
>Встроенные оконные функции описаны в <A
HREF="functions-window.html#FUNCTIONS-WINDOW-TABLE"
>Таблице 9-53</A
>, но этот набор можно расширить, создавая собственные функции. Кроме того, в качестве оконных функций можно использовать любые встроенные или пользовательские обычные агрегатные функции (сортирующие агрегатные функции использовать в качестве оконных нельзя).</P
><P
>Запись со звёздочкой (<TT
CLASS="LITERAL"
>*</TT
>) применяется при вызове агрегатных функций в качестве оконных, например <TT
CLASS="LITERAL"
>count(*) OVER (PARTITION BY x ORDER BY y)</TT
>. Звёздочка (<TT
CLASS="LITERAL"
>*</TT
>) обычно не применяется для не агрегатных оконных функций. Агрегатные оконные функции, в отличие от обычных агрегатных функций, не допускают использования <TT
CLASS="LITERAL"
>DISTINCT</TT
> и <TT
CLASS="LITERAL"
>ORDER BY</TT
> в списке аргументов.</P
><P
>Вызовы оконных функций разрешены в запросах только в списке <TT
CLASS="LITERAL"
>SELECT</TT
> и в предложении <TT
CLASS="LITERAL"
>ORDER BY</TT
>.</P
><P
>Дополнительно об оконных функциях можно узнать в <A
HREF="tutorial-window.html"
>Разделе 3.5</A
>, <A
HREF="functions-window.html"
>Разделе 9.21</A
> и <A
HREF="queries-table-expressions.html#QUERIES-WINDOW"
>Подразделе 7.2.4</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-TYPE-CASTS"
>4.2.9. Приведения типов</A
></H2
><P
>Приведение типа определяет преобразование данных из одного типа в другой. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> воспринимает две равносильные записи приведения типов: </P><PRE
CLASS="SYNOPSIS"
>CAST ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>тип</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
>::<TT
CLASS="REPLACEABLE"
><I
>тип</I
></TT
></PRE
><P> Запись с <TT
CLASS="LITERAL"
>CAST</TT
> соответствует стандарту SQL, тогда как вариант с <TT
CLASS="LITERAL"
>::</TT
> &mdash; историческое наследие <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
><P
>Когда приведению подвергается значение выражения известного типа, происходит преобразование типа во время выполнения. Это приведение будет успешным, только если определён подходящий оператор преобразования типов. Обратите внимание на небольшое отличие от приведения констант, описанного в <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC"
>Подразделе 4.1.2.7</A
>. Приведение строки в чистом виде представляет собой начальное присваивание строковой константы и оно будет успешным для любого типа (конечно, если строка содержит значение, приемлемое для данного типа данных).</P
><P
>Неявное приведение типа можно опустить, если возможно однозначно определить, какой тип должно иметь выражение (например, когда оно присваивается колонке таблицы); в таких случаях система автоматически преобразует тип. Однако автоматическое преобразование выполняется только для приведений с пометкой <SPAN
CLASS="QUOTE"
>"допускается неявное применение"</SPAN
> в системных каталогах. Все остальные приведения должны записываться явно. Это ограничение позволяет избежать сюрпризов с неявным преобразованием.</P
><P
>Также можно записать приведение типа как вызов функции: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> )</PRE
><P> Однако это будет работать только для типов, имена которых являются также допустимыми именами функций. Например, <TT
CLASS="LITERAL"
>double precision</TT
> так использовать нельзя, а <TT
CLASS="LITERAL"
>float8</TT
> (альтернативное название того же типа) &mdash; можно. Кроме того, имена типов <TT
CLASS="LITERAL"
>interval</TT
>, <TT
CLASS="LITERAL"
>time</TT
> и <TT
CLASS="LITERAL"
>timestamp</TT
> из-за синтаксического конфликта можно использовать в такой записи только в кавычках. Таким образом, запись приведения типа в виде вызова функции провоцирует несоответствия и, возможно, лучше будет её не применять.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Приведение типа, представленное в виде вызова функции, на самом деле соответствует внутреннему механизму. Даже при использовании двух стандартных типов записи внутри происходит вызов зарегистрированной функции, выполняющей преобразование. По соглашению именем такой функции преобразования является имя выходного типа, и таким образом запись <SPAN
CLASS="QUOTE"
>"в виде вызова функции"</SPAN
> есть не что иное, как прямой вызов нижележащей функции преобразования. При создании переносимого приложения на это поведение, конечно, не следует рассчитывать. Подробнее это описано в справке <A
HREF="sql-createcast.html"
>CREATE CAST</A
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-COLLATE-EXPRS"
>4.2.10. Применение правил сортировки</A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> переопределяет правило сортировки выражения. Оно добавляется после выражения: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
></PRE
><P> где <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> &mdash; идентификатор правила, возможно дополненный именем схемы. Предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> связывает выражение сильнее, чем операторы, так что при необходимости следует использовать скобки.</P
><P
>Если правило сортировки не определено явно, система либо выбирает его по колонкам, которые используются в выражении, либо, если таких колонок нет, переключается на установленное для базы данных правило сортировки по умолчанию.</P
><P
>Предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> имеет два распространённых применения: переопределение порядка сортировки в предложении <TT
CLASS="LITERAL"
>ORDER BY</TT
>, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</PRE
><P> и переопределение правил сортировки при вызове функций или операторов, возвращающих языкозависимые результаты, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";</PRE
><P> Заметьте, что в последнем случае предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> добавлено к аргументу оператора, на действие которого мы хотим повлиять. При этом не имеет значения, к какому именно аргументу оператора или функции добавляется <TT
CLASS="LITERAL"
>COLLATE</TT
>, так как правило сортировки, применяемое к оператору или функции, выбирается при рассмотрении всех аргументов, а явное предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> переопределяет правила сортировки для всех других аргументов. (Однако добавление разных предложений <TT
CLASS="LITERAL"
>COLLATE</TT
> к нескольким аргументам будет ошибкой. Подробнее об этом см. <A
HREF="collation.html"
>Раздел 22.2</A
>.) Таким образом, эта команда выдаст тот же результат: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</PRE
><P> Но это будет ошибкой: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</PRE
><P> здесь правило сортировки нельзя применить к результату оператора <TT
CLASS="LITERAL"
>&gt;</TT
>, который имеет несравниваемый тип данных <TT
CLASS="TYPE"
>boolean</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-SCALAR-SUBQUERIES"
>4.2.11. Скалярные подзапросы</A
></H2
><P
>Скалярный подзапрос &mdash; это обычный запрос <TT
CLASS="COMMAND"
>SELECT</TT
> в скобках, который возвращает ровно одну строку и одну колонку. (Написание запросов освещается в <A
HREF="queries.html"
>Главе 7</A
>.) После выполнения запроса <TT
CLASS="COMMAND"
>SELECT</TT
> его единственный результат используется в окружающем его выражении. В качестве скалярного подзапроса нельзя использовать запросы, возвращающие более одной строки или колонки. (Но если в результате выполнения подзапрос не вернёт строк, скалярный результат считается равным NULL.) В подзапросе можно ссылаться на переменные из окружающего запроса; в процессе одного вычисления подзапроса они будут считаться константами. Другие выражения с подзапросами описаны в <A
HREF="functions-subquery.html"
>Разделе 9.22</A
>.</P
><P
>Например, следующий запрос находит самый населённый город в каждом штате: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-ARRAY-CONSTRUCTORS"
>4.2.12. Конструкторы массивов</A
></H2
><P
>Конструктор массива &mdash; это выражение, которое создаёт массив, определяя значения его элементов. Конструктор простого массива состоит из ключевого слова <TT
CLASS="LITERAL"
>ARRAY</TT
>, открывающей квадратной скобки <TT
CLASS="LITERAL"
>[</TT
>, списка выражений (разделённых запятыми), задающих значения элементов массива, и закрывающей квадратной скобки <TT
CLASS="LITERAL"
>]</TT
>. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</PRE
><P> По умолчанию типом элементов массива считается общий тип для всех выражений, определённый по правилам, действующим и для конструкций <TT
CLASS="LITERAL"
>UNION</TT
> и <TT
CLASS="LITERAL"
>CASE</TT
> (см. <A
HREF="typeconv-union-case.html"
>Раздел 10.5</A
>). Вы можете переопределить его явно, приведя конструктор массива к требуемому типу, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</PRE
><P> Это равносильно тому, что привести к нужному типу каждое выражение по отдельности. Подробнее приведение типов описано в <A
HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS"
>Подразделе 4.2.9</A
>.</P
><P
>Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При этом во внутренних конструкторах слово <TT
CLASS="LITERAL"
>ARRAY</TT
> можно опускать. Например, результат работы этих конструкторов одинаков: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</PRE
><P> Многомерные массивы должны быть прямоугольными, и поэтому внутренние конструкторы одного уровня должны создавать вложенные массивы одинаковой размерности. Любое приведение типа, применённое к внешнему конструктору <TT
CLASS="LITERAL"
>ARRAY</TT
>, автоматически распространяется на все внутренние.</P
><P
>Элементы многомерного массива можно создавать не только вложенными конструкторами <TT
CLASS="LITERAL"
>ARRAY</TT
>, но и другими способами, позволяющими получить массивы нужного типа. Например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</PRE
><P></P
><P
>Вы можете создать и пустой массив, но так как массив не может быть не типизированным, вы должны явно привести пустой массив к нужному типу. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</PRE
><P></P
><P
>Также возможно создать запрос из результатов подзапроса. В этом случае конструктор массива записывается так же с ключевым словом <TT
CLASS="LITERAL"
>ARRAY</TT
>, за которым в круглых скобках следует подзапрос. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)</PRE
><P> Такой подзапрос должен возвращать одну колонку. Результирующий одномерный массив будет включать элементы для каждой строки-результата подзапроса и типом элемента будет тип колонки результата.</P
><P
>Индексы массива, созданного конструктором <TT
CLASS="LITERAL"
>ARRAY</TT
>, всегда начинаются с одного. Подробнее о массивах вы узнаете в <A
HREF="arrays.html"
>Разделе 8.15</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-ROW-CONSTRUCTORS"
>4.2.13. Конструкторы табличных строк</A
></H2
><P
>Конструктор табличной строки &mdash; это выражение, создающее строку или кортеж (или составное значение) из значений его аргументов-полей. Конструктор строки состоит из ключевого слова <TT
CLASS="LITERAL"
>ROW</TT
>, открывающей круглой скобки, нуля или нескольких выражений (разделённых запятыми), определяющих значения полей, и закрывающей скобки. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ROW(1,2.5,'this is a test');</PRE
><P> Если в списке более одного выражения, ключевое слово <TT
CLASS="LITERAL"
>ROW</TT
> можно опустить.</P
><P
>Конструктор строки поддерживает запись <TT
CLASS="REPLACEABLE"
><I
>составное_значение</I
></TT
><TT
CLASS="LITERAL"
>.*</TT
>, при этом данное значение будет развёрнуто в список элементов, так же, как в записи <TT
CLASS="LITERAL"
>.*</TT
> на верхнем уровне списка <TT
CLASS="COMMAND"
>SELECT</TT
>. Например, если таблица <TT
CLASS="LITERAL"
>t</TT
> содержит колонки <TT
CLASS="LITERAL"
>f1</TT
> и <TT
CLASS="LITERAL"
>f2</TT
>, эти записи эквивалентны: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;</PRE
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>До версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.2 запись <TT
CLASS="LITERAL"
>.*</TT
> не разворачивалась, так что выражение <TT
CLASS="LITERAL"
>ROW(t.*, 42)</TT
> создавало составное значение из двух полей, в котором первое поле так же было составным. Новое поведение обычно более полезно. Если вам нужно создать строку из двух полей так, чтобы первое поле содержало строку, напишите внутреннее значение без <TT
CLASS="LITERAL"
>.*</TT
>, например <TT
CLASS="LITERAL"
>ROW(t, 42)</TT
>.</P
></BLOCKQUOTE
></DIV
><P
>По умолчанию значение, созданное выражением <TT
CLASS="LITERAL"
>ROW</TT
>, имеет тип анонимной записи. Если необходимо, его можно привести к именованному составному типу &mdash; либо к типу строки таблицы, либо составному типу, созданному оператором <TT
CLASS="COMMAND"
>CREATE TYPE AS</TT
>. Явное приведение может потребоваться для достижения однозначности. Например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Приведение не требуется, так как существует только одна getf1()
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Теперь приведение необходимо для однозначного выбора функции:
SELECT getf1(ROW(1,2.5,'this is a test'));
ОШИБКА:  функция getf1(record) не уникальна

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)</PRE
><P></P
><P
>Используя конструктор строк (кортежей), можно создавать составное значение для сохранения в колонке составного типа или для передачи функции, принимающей составной параметр. Также вы можете сравнить два составных значения или проверить их с помощью <TT
CLASS="LITERAL"
>IS NULL</TT
> или <TT
CLASS="LITERAL"
>IS NOT NULL</TT
>, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

  -- выбрать все строки, содержащие только NULL
SELECT ROW(table.*) IS NULL FROM table;</PRE
><P> Подробнее см. <A
HREF="functions-comparisons.html"
>Раздел 9.23</A
>. Конструкторы строк также могут использоваться в сочетании с подзапросами, как описано в <A
HREF="functions-subquery.html"
>Разделе 9.22</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYNTAX-EXPRESS-EVAL"
>4.2.14. Правила вычисления выражений</A
></H2
><P
>Порядок вычисления подвыражений не определён. В частности, аргументы оператора или функции не обязательно вычисляются слева направо или в любом другом фиксированном порядке.</P
><P
>Более того, если результат выражения можно получить, вычисляя только некоторые его части, тогда другие подвыражения не будут вычисляться вовсе. Например, если написать: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT true OR somefunc();</PRE
><P> тогда функция <TT
CLASS="LITERAL"
>somefunc()</TT
> не будет вызываться (возможно). То же самое справедливо для записи: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT somefunc() OR true;</PRE
><P> Заметьте, что это отличается от <SPAN
CLASS="QUOTE"
>"оптимизации"</SPAN
> вычисления логических операторов слева направо, реализованной в некоторых языках программирования.</P
><P
>Как следствие, в сложных выражениях не стоит использовать функции с побочными эффектами. Особенно опасно рассчитывать на порядок вычисления или побочные эффекты в предложениях <TT
CLASS="LITERAL"
>WHERE</TT
> и <TT
CLASS="LITERAL"
>HAVING</TT
>, так как эти предложения тщательно оптимизируются при построении плана выполнения. Логические выражения (сочетания <TT
CLASS="LITERAL"
>AND</TT
>/<TT
CLASS="LITERAL"
>OR</TT
>/<TT
CLASS="LITERAL"
>NOT</TT
>) в этих предложениях могут быть видоизменены любым способом, допустимым законами Булевой алгебры.</P
><P
>Когда порядок вычисления важен, его можно зафиксировать с помощью конструкции <TT
CLASS="LITERAL"
>CASE</TT
> (см. <A
HREF="functions-conditional.html"
>Раздел 9.17</A
>). Например, такой способ избежать деления на ноль в предложении <TT
CLASS="LITERAL"
>WHERE</TT
> ненадёжен: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</PRE
><P> Безопасный вариант: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</PRE
><P> Применяемая так конструкция <TT
CLASS="LITERAL"
>CASE</TT
> защищает выражение от оптимизации, поэтому использовать её нужно только при необходимости. (В данном случае было бы лучше решить проблему, переписав условие как <TT
CLASS="LITERAL"
>y &gt; 1.5*x</TT
>.)</P
><P
>Однако, <TT
CLASS="LITERAL"
>CASE</TT
> не всегда спасает в подобных случаях. Показанный выше приём плох тем, что не предотвращает раннее вычисление константных подвыражений. Как описано в <A
HREF="xfunc-volatility.html"
>Разделе 35.6</A
>, функции и операторы, помеченные как <TT
CLASS="LITERAL"
>IMMUTABLE</TT
>, могут вычисляться при планировании, а не выполнении запроса. Поэтому в примере </P><PRE
CLASS="PROGRAMLISTING"
>SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</PRE
><P>, скорее всего, произойдёт деление на ноль из-за того, что планировщик попытается упростить константное подвыражение, даже если во всех строках в таблице <TT
CLASS="LITERAL"
>x &gt; 0</TT
>, а значит во время выполнения ветвь <TT
CLASS="LITERAL"
>ELSE</TT
> никогда не будет выполняться.</P
><P
>Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в которых неявно появляются константы, могут возникать и в запросах внутри функций, так как значения аргументов функции и локальных переменных при планировании могут быть заменены константами. Поэтому например, в функциях <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> гораздо безопаснее для защиты от рискованных вычислений использовать конструкцию <TT
CLASS="LITERAL"
>IF</TT
>-<TT
CLASS="LITERAL"
>THEN</TT
>-<TT
CLASS="LITERAL"
>ELSE</TT
>, чем выражение <TT
CLASS="LITERAL"
>CASE</TT
>.</P
><P
>Ещё один подобный недостаток этого подхода в том, что <TT
CLASS="LITERAL"
>CASE</TT
> не может предотвратить вычисление заключённого в нём агрегатного выражения, так как агрегатные выражения вычисляются перед всеми остальными в списке <TT
CLASS="LITERAL"
>SELECT</TT
> или предложении <TT
CLASS="LITERAL"
>HAVING</TT
>. Например, в следующем запросе может возникнуть ошибка деления на ноль, несмотря на то, что он вроде бы защищён от неё: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT CASE WHEN min(employees) &gt; 0
            THEN avg(expenses / employees)
       END
    FROM departments;</PRE
><P> Агрегатные функции <CODE
CLASS="FUNCTION"
>min()</CODE
> и <CODE
CLASS="FUNCTION"
>avg()</CODE
> вычисляются независимо по всем входным строкам, так что если в какой-то строке поле <TT
CLASS="STRUCTFIELD"
>employees</TT
> окажется равным нулю, деление на ноль произойдёт раньше, чем станет возможным проверить результат функции <CODE
CLASS="FUNCTION"
>min()</CODE
>. Поэтому, чтобы проблемные входные строки изначально не попали в агрегатную функцию, следует воспользоваться предложениями <TT
CLASS="LITERAL"
>WHERE</TT
> или <TT
CLASS="LITERAL"
>FILTER</TT
>.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax-lexical.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-syntax-calling-funcs.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Лексическая структура</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Вызов функций</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>