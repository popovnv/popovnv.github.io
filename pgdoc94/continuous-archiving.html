<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Резервное копирование и восстановление"
HREF="backup.html"><LINK
REL="PREVIOUS"
TITLE="Резервное копирование на уровне файлов"
HREF="backup-file.html"><LINK
REL="NEXT"
TITLE="Отказоустойчивость, балансировка нагрузки и репликация"
HREF="high-availability.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Резервное копирование на уровне файлов"
HREF="backup-file.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 24. Резервное копирование и восстановление</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Отказоустойчивость, балансировка нагрузки и репликация"
HREF="high-availability.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONTINUOUS-ARCHIVING"
>24.3. Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)</A
></H1
><P
>Всё время в процессе работы <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> ведёт <I
CLASS="FIRSTTERM"
>журнал упреждающей записи</I
> (WAL), который расположен в подкаталоге <TT
CLASS="FILENAME"
>pg_xlog/</TT
> каталога с данными кластера баз данных. В этот журнал записываются все изменения, вносимые в файлы данных. Прежде всего, журнал существует для безопасного восстановления после краха сервера: если происходит крах, целостность СУБД может быть восстановлена в результате <SPAN
CLASS="QUOTE"
>"воспроизведения"</SPAN
> записей, зафиксированных после последней контрольной точки. Однако наличие журнала делает возможным использование третьей стратегии копирования баз данных: можно сочетать резервное копирование на уровне файловой системы с копированием файлов WAL. Если потребуется восстановить данные, мы можем восстановить копию файлов, а затем воспроизвести журнал из скопированных файлов WAL, и таким образом привести систему в нужное состояние. Такой подход более сложен для администрирования, чем любой из описанных выше, но он имеет значительные преимущества: <P
></P
></P><UL
><LI
><P
>В качестве начальной точки для восстановления необязательно иметь полностью согласованную копию на уровне файлов. Внутренняя несогласованность копии будет исправлена при воспроизведении журнала (практически то же самое происходит при восстановлении после краха). Таким образом, согласованный снимок файловой системы не требуется, вполне можно использовать <SPAN
CLASS="APPLICATION"
>tar</SPAN
> или похожие средства архивации.</P
></LI
><LI
><P
>Поскольку при воспроизведении можно обрабатывать неограниченную последовательность файлов WAL, непрерывную резервную копию можно получить, просто продолжая архивировать файлы WAL. Это особенно ценно для больших баз данных, полные резервные копии которых делать как минимум неудобно.</P
></LI
><LI
><P
>Воспроизводить все записи WAL до самого конца нет необходимости. Воспроизведение можно остановить в любой точке и получить целостный снимок базы данных на этот момент времени. Таким образом, данная технология поддерживает <I
CLASS="FIRSTTERM"
>восстановление на момент времени</I
>: можно восстановить состояние базы данных на любое время с момента создания резервной копии.</P
></LI
><LI
><P
>Если непрерывно передавать последовательность файлов WAL другому серверу, получившему данные из базовой копии того же кластера, получается система <I
CLASS="FIRSTTERM"
>тёплого резерва</I
>: в любой момент мы можем запустить второй сервер и он будет иметь практически текущую копию баз данных.</P
></LI
></UL
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Программы <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> и <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> не создают копии на уровне файловой системы и не могут применяться как часть решения по непрерывной архивации. Создаваемые ими копии являются логическими и не содержат информации, необходимой для воспроизведения WAL.</P
></BLOCKQUOTE
></DIV
><P
>Как и обычное резервное копирование файловой системы, этот метод позволяет восстанавливать только весь кластер баз данных целиком, но не его части. Кроме того, для архивов требуется большое хранилище: базовая резервная копия может быть объёмной, а нагруженные системы будут генерировать многие мегабайты трафика WAL, который необходимо архивировать. Тем не менее, этот метод резервного копирования предпочитается во многих ситуациях, где необходима высокая надёжность.</P
><P
>Для успешного восстановления с применением непрерывного архивирования (также называемого <SPAN
CLASS="QUOTE"
>"оперативным резервным копированием"</SPAN
> многими разработчиками СУБД), вам необходима непрерывная последовательность заархивированных файлов WAL, начинающаяся не позже, чем с момента начала копирования. Так что для начала вы должны настроить и протестировать процедуру архивирования файлов WAL <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>до того</I
></SPAN
>, как получите первую базовую копию. Соответственно, сначала мы обсудим механику архивирования файлов WAL.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-ARCHIVING-WAL"
>24.3.1. Настройка архивирования WAL</A
></H2
><P
>В абстрактном смысле, запущенная СУБД <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> производит неограниченно длинную последовательность записей WAL. СУБД физически делит эту последовательность на <I
CLASS="FIRSTTERM"
>файлы-сегменты</I
> WAL, которые обычно имеют размер в 16 МиБ (хотя размер сегмента может быть изменён при сборке <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>). Файлы-сегменты получают цифровые имена, которые отражают их позицию в абстрактной последовательности WAL. Когда архивирование WAL не применяется, система обычно создаёт только несколько файлов-сегментов и затем <SPAN
CLASS="QUOTE"
>"перерабатывает"</SPAN
> их, меняя номер в имени более не нужного файла-сегмента на больший. Предполагается, что файлы-сегменты, чьё содержимое предшествует последней контрольной точке, уже не представляют интереса и могут быть переработаны.</P
><P
>При архивировании данных WAL необходимо считывать содержимое каждого файла-сегмента, как только он заполняется, и сохранять эти данные куда-то, прежде чем файл-сегмент будет переработан и использован повторно. В зависимости от применения и доступного аппаратного обеспечения, возможны разные способы <SPAN
CLASS="QUOTE"
>"сохранить данные куда-то"</SPAN
>: можно скопировать файлы-сегменты в смонтированный по NFS каталог на другую машину, записать их на ленту (убедившись, что у вас есть способ идентифицировать исходное имя каждого файла) или собрать их в пакет и записать на CD, либо какие-то совсем другие варианты. Чтобы у администратора баз данных была гибкость в этом плане, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> пытается не делать каких-либо предположений о том, как будет выполняться архивация. Вместо этого, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет администратору указать команду оболочки, которая будет запускаться для копирования завершённого файла-сегмента в нужное место. Эта команда может быть простой как <TT
CLASS="LITERAL"
>cp</TT
>, а может вызывать сложный скрипт оболочки &mdash; это решать вам.</P
><P
>Чтобы включить архивирование WAL, установите в параметре конфигурации <A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
> уровень <TT
CLASS="LITERAL"
>archive</TT
> (или выше), в <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
> — значение <TT
CLASS="LITERAL"
>on</TT
>, и задайте желаемую команду оболочки в параметре <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>. На практике эти параметры всегда задаются в файле <TT
CLASS="FILENAME"
>postgresql.conf</TT
>. В <TT
CLASS="VARNAME"
>archive_command</TT
> символы <TT
CLASS="LITERAL"
>%p</TT
> заменяются полным путём к файлу, подлежащему архивации, а <TT
CLASS="LITERAL"
>%f</TT
> заменяются только именем файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога данных кластера). Если в команду нужно включить сам символ <TT
CLASS="LITERAL"
>%</TT
>, запишите <TT
CLASS="LITERAL"
>%%</TT
>. Простейшая команда, которая может быть полезна, такая: </P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</PRE
><P> Она будет копировать архивируемые сегменты WAL в каталог /mnt/server/archivedir. (Команда дана как пример, а не как рекомендация, и может не работать на всех платформах.) После замены параметров <TT
CLASS="LITERAL"
>%p</TT
> и <TT
CLASS="LITERAL"
>%f</TT
> фактически запускаемая команда может выглядеть так: </P><PRE
CLASS="PROGRAMLISTING"
>test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</PRE
><P> Подобная команда будет генерироваться для каждого следующего архивируемого файла.</P
><P
>Команда архивирования будет запущена от имени того же пользователя, от имени которого работает сервер <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Поскольку архивируемые последовательности файлов WAL фактически содержат всё, что есть в вашей базе данных, вам нужно будет защитить архивируемые данные от посторонних глаз; например, сохраните архив в каталог, чтение которого запрещено для группы и остальных пользователей.</P
><P
>Важно, чтобы команда архивирования возвращала нулевой код завершения, если и только если она завершилась успешно. Получив нулевой результат, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет полагать, что файл успешно заархивирован и удалит его или переработает. Однако, ненулевой код состояния скажет <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, что файл не заархивирован; попытки заархивировать его будут периодически повторяться, пока это не удастся.</P
><P
>Команда архивирования обычно разрабатывается так, чтобы не допускать перезаписи любых существующих архивных файлов. Это важная мера безопасности, позволяющая сохранить целостность архива в случае ошибки администратора (например, если архивируемые данные двух разных серверов будут сохраняться в одном каталоге).</P
><P
>Рекомендуется протестировать команду архивирования, чтобы убедиться, что она действительно не перезаписывает существующие файлы, и что она <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>возвращает ненулевое состояние в этом случае</I
></SPAN
>. В показанной выше команде для Unix для этого добавлен отдельный шаг <TT
CLASS="COMMAND"
>test</TT
>. На некоторых платформах Unix у <TT
CLASS="COMMAND"
>cp</TT
> есть ключ <TT
CLASS="OPTION"
>-i</TT
>, который позволяет сделать то же, но менее явно; но не проверив, какой код состояния при этом возвращается, полагаться на этот ключ не следует. (В частности, GNU <TT
CLASS="COMMAND"
>cp</TT
> возвратит нулевой код состояния, если используется ключ <TT
CLASS="OPTION"
>-i</TT
> и целевой файл существует, а это <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не то</I
></SPAN
>, что нужно.)</P
><P
>Разрабатывая схему архивирования, подумайте, что произойдёт, если команда архивирования начнёт постоянно выдавать ошибку, потому что требуется вмешательство оператора или для архивирования не хватает места. Например, это может произойти, если вы записываете архивы на ленточное устройство без механизма автозамены; когда лента заполняется полностью, больше ничего архивироваться не будет, пока вы не замените кассету. Вы должны убедиться, что любые возникающие ошибки или обращения к человеку (оператору), обрабатываются так, чтобы проблема решалась достаточно быстро. Пока она не разрешится, каталог <TT
CLASS="FILENAME"
>pg_xlog/</TT
> продолжит наполняться файлами-сегментами WAL. (Если файловая система, в которой находится каталог <TT
CLASS="FILENAME"
>pg_xlog/</TT
> заполнится до конца, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> завершит свою работу аварийно. Зафиксированные транзакции не потеряются, но база данных не будет работать, пока вы не освободите место.)</P
><P
>Не важно, с какой скоростью работает команда архивирования, если только она не ниже средней скорости, с которой сервер генерирует записи WAL. Обычно работа продолжается, даже если процесс архивирования немного отстаёт. Если же архивирование отстаёт значительно, это приводит к увеличению объёма данных, которые могут быть потеряны в случае аварии. При этом каталог <TT
CLASS="FILENAME"
>pg_xlog/</TT
> будет содержать большое количество ещё не заархивированных файлов-сегментов, которые в конце концов могут занять всё доступное дисковое пространство. Поэтому рекомендуется контролировать процесс архивации и следить за тем, чтобы он выполнялся как задумано.</P
><P
>При написании команды архивирования вы должны иметь в виду, что имена файлов для архивирования могут иметь длину до 64 символов и содержать любые комбинации из цифр, точек и букв ASCII. Сохранять исходный относительный путь (<TT
CLASS="LITERAL"
>%p</TT
>) необязательно, но необходимо сохранять имя файла (<TT
CLASS="LITERAL"
>%f</TT
>).</P
><P
>Обратите внимание, что хотя архивирование WAL позволяет сохранить любые изменения данных, произведённые в базе данных <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, оно не затрагивает изменения, внесённые в конфигурационные файлы (такие как <TT
CLASS="FILENAME"
>postgresql.conf</TT
>, <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> и <TT
CLASS="FILENAME"
>pg_ident.conf</TT
>), поскольку эти изменения выполняются вручную, а не через SQL. Поэтому имеет смысл разместить конфигурационные файлы там, где они будут заархивированы обычными процедурами копирования файлов. Как перемещать конфигурационные файлы, рассказывается в <A
HREF="runtime-config-file-locations.html"
>Разделе 18.2</A
>.</P
><P
>Команда архивирования вызывается, только когда сегмент WAL заполнен до конца. Таким образом, если сервер постоянно генерирует небольшой трафик WAL (или есть продолжительные периоды, когда это происходит), между завершением транзакций и их безопасным сохранением в архиве может образоваться большая задержка. Чтобы ограничить время жизни неархивированных данных, можно установить <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT"
>archive_timeout</A
>, чтобы сервер переключался на новый файл сегмента WAL как минимум с заданной частотой. Заметьте, что неполные файлы, архивируемые досрочно из-за принудительного переключения по таймауту, будут иметь тот же размер, что и заполненные файлы. Таким образом, устанавливать очень маленький <TT
CLASS="VARNAME"
>archive_timeout</TT
> &mdash; неразумно; это приведёт к неэффективному заполнению архива. Обычно подходящее значение <TT
CLASS="VARNAME"
>archive_timeout</TT
> — минута или около того.</P
><P
>Также вы можете принудительно переключить сегмент WAL вручную с помощью <CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
>, если хотите, чтобы только что завершённая транзакция заархивировалась как можно скорее. Другие полезные функции, относящиеся к управлению WAL, перечисляются в <A
HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE"
>Таблице 9-65</A
>.</P
><P
>Когда <TT
CLASS="VARNAME"
>wal_level</TT
> имеет значение <TT
CLASS="LITERAL"
>minimal</TT
>, некоторые команды SQL выполняются в обход журнала WAL, как описывается в <A
HREF="populate.html#POPULATE-PITR"
>Подразделе 14.4.7</A
>. Если архивирование или потоковая репликация были включены во время выполнения таких операторов, WAL не будет содержать информацию, необходимую для восстановления. (На восстановление после краха это не распространяется). Поэтому <TT
CLASS="VARNAME"
>wal_level</TT
> можно изменить только при запуске сервера. Однако, чтобы изменить команду <TT
CLASS="VARNAME"
>archive_command</TT
>, достаточно перезагрузить файл конфигурации. Если вы хотите на время остановить архивирование, это можно сделать, например, задав в качестве значения <TT
CLASS="VARNAME"
>archive_command</TT
> пустую строку (''). В результате файлы WAL будут накапливаться в каталоге <TT
CLASS="FILENAME"
>pg_xlog/</TT
>, пока не будет восстановлена действующая команда <TT
CLASS="VARNAME"
>archive_command</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-BASE-BACKUP"
>24.3.2. Создание базовой резервной копии</A
></H2
><P
>Проще всего получить базовую резервную копию, используя программу <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>. Эта программа сохраняет базовую копию в виде обычных файлов или в архиве tar. Если гибкости <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
> не хватает, вы также можете получить базовую резервную копию, используя низкоуровневый API (см. <A
HREF="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP"
>Подраздел 24.3.3</A
>).</P
><P
>Продолжительность создания резервной копии обычно не имеет большого значения. Однако, если вы эксплуатируете сервер с отключённым режимом <TT
CLASS="VARNAME"
>full_page_writes</TT
>, вы можете заметить падение производительности в процессе резервного копирования, так как режим <TT
CLASS="VARNAME"
>full_page_writes</TT
> включается принудительно на время резервного копирования.</P
><P
>Чтобы резервной копией можно было пользоваться, нужно сохранить все файлы сегментов WAL, сгенерированные во время и после копирования файлов. Для облегчения этой задачи, процесс создания базовой резервной копии записывает <I
CLASS="FIRSTTERM"
>файл истории резервного копирования</I
>, который немедленно сохраняется в области архивации WAL. Данный файл получает имя по имени файла первого сегмента WAL, который потребуется для восстановления скопированных файлов. Например, если начальный файл WAL назывался <TT
CLASS="LITERAL"
>0000000100001234000055CD</TT
>, файл истории резервного копирования получит имя <TT
CLASS="LITERAL"
>0000000100001234000055CD.007C9330.backup</TT
>. (Вторая часть имени файла обозначает точную позицию внутри файла WAL и обычно может быть проигнорирована.) Как только вы заархивировали копии файлов данных и файлов сегментов WAL, полученных в процессе копирования (по сведениям в файле истории резервного копирования), все заархивированные сегменты WAL с именами, меньшими по номеру, становятся ненужными для восстановления файловой копии и могут быть удалены. Но всё же рассмотрите возможность хранения нескольких наборов резервных копий, чтобы быть абсолютно уверенными, что вы сможете восстановить ваши данные.</P
><P
>Файл истории резервного копирования &mdash; это просто небольшой текстовый файл. В него записывается метка, которая была передана <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>, а также время и текущие сегменты WAL в момент начала и завершения резервной копии. Если вы связали с данной меткой соответствующий файл дампа, то заархивированного файла истории достаточно, чтобы найти файл дампа, нужный для восстановления.</P
><P
>Поскольку необходимо хранить все заархивированные файлы WAL с момента последней базовой резервной копии, интервал базового резервного копирования обычно выбирается в зависимости от того, сколько места может быть выделено для архива файлов WAL. Также стоит отталкиваться от того, сколько вы готовы ожидать восстановления, если оно понадобится — системе придётся воспроизвести все эти сегменты WAL, а этот процесс может быть долгим, если с момента последней базовой копии прошло много времени.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP"
>24.3.3. Создание базовой резервной копии через низкоуровневый API</A
></H2
><P
>Процедура создания базовой резервной копии с использованием низкоуровневого API содержит чуть больше шагов, чем метод <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>, но всё же относительно проста. Очень важно, чтобы эти шаги выполнялись по порядку, и следующий шаг выполнялся, только если предыдущий успешен. <P
></P
></P><OL
TYPE="1"
><LI
><P
>Убедитесь, что архивирование WAL включено и работает.</P
></LI
><LI
><P
>Подключитесь к базе данных как суперпользователь и выполните команду: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label');</PRE
><P> где <TT
CLASS="LITERAL"
>label</TT
> &mdash; любая метка, по которой можно однозначно идентифицировать данную операцию резервного копирования. (Хорошей практикой является использование полного пути, куда будет помещён файл дампа.) Функция <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> создаёт в каталоге кластера <I
CLASS="FIRSTTERM"
>файл метки резервного копии</I
>, называемый <TT
CLASS="FILENAME"
>backup_label</TT
>, в который помещается информация о резервной копии, включая время начала и строку метки. Этот файл важен для целостности резервной копии, если вам понадобится восстановить её.</P
><P
>Для этой команды не важно, к какой базе данных в кластере вы подключаетесь. Вы можете игнорировать результат, возвращаемый данной функцией; но если происходит ошибка, уделите ей внимание, прежде чем продолжить.</P
><P
>По умолчанию <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> может выполняться длительное время. Это объясняется тем, что функция выполняет контрольную точку, а операции ввода/вывода, требуемые для этого, распределяются в интервале времени, по умолчанию равном половине интервала между контрольными точками (см. параметр <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>). Обычно это вполне приемлемо, так как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите начать резервное копирование максимально быстро, выполните: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label', true);</PRE
><P> При этом контрольная точка будет выполнена как можно скорее.</P
></LI
><LI
><P
>Скопируйте файлы, используя любое удобное средство резервного копирования, например, <SPAN
CLASS="APPLICATION"
>tar</SPAN
> или <SPAN
CLASS="APPLICATION"
>cpio</SPAN
> (не <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> или <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>). В процессе копирования останавливать работу базы данных не требуется, это ничего не даёт.</P
></LI
><LI
><P
>Снова подключитесь к базе данных как суперпользователь и выполните команду: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_stop_backup();</PRE
><P> Сервер выйдет из режима резервного копирования и автоматически переключится на следующий сегмент WAL. Это переключение выполняется для того, чтобы файл последнего сегмента WAL, записанного во время копирования, был готов к архивации.</P
></LI
><LI
><P
>После этого останется заархивировать файлы сегментов WAL, активных во время создания резервной копии, и процедура резервного копирования будет завершена. Функция <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> возвращает указание на файл последнего сегмента, который требуется для формирования полного набора файлов резервной копии. Если включён режим архивации (параметр <TT
CLASS="VARNAME"
>archive_mode</TT
>), функция <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> не завершится, пока не будет заархивирован последний сегмент. В этом случае файлы будут заархивированы автоматически, поскольку также должна быть настроена команда <TT
CLASS="VARNAME"
>archive_command</TT
>. Чаще всего это происходит быстро, но мы советуем наблюдать за системой архивации и проверять, не возникают ли задержки. Если архивирование остановится из-за ошибок команды архивации, попытки архивации будут продолжаться до успешного завершения, и только тогда резервная копия будет завершена. Если вы хотите ограничить время выполнения <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>, установите соответствующее значение в <TT
CLASS="VARNAME"
>statement_timeout</TT
>.</P
></LI
></OL
><P></P
><P
>Некоторые средства резервного копирования файлов выдают предупреждения или ошибки, если файлы, которые они пытаются скопировать, изменяются в процессе копирования. При получении базовой резервной копии активной базы данных это вполне нормально и не является ошибкой. Однако, вам нужно знать, как отличить ошибки такого рода от реальных ошибок. Например, некоторые версии <SPAN
CLASS="APPLICATION"
>rsync</SPAN
> возвращают отдельный код выхода для ситуации <SPAN
CLASS="QUOTE"
>"исчезнувшие исходные файлы"</SPAN
>, и вы можете написать управляющий скрипт, который примет этот код как не ошибочный. Также некоторые версии GNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
> возвращают код выхода, неотличимый от кода фатальной ошибки, если файл был усечён, когда <SPAN
CLASS="APPLICATION"
>tar</SPAN
> копировал его. К счастью, GNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
> версий 1.16 и более поздних завершается с кодом 1, если файл был изменён во время копирования, и 2 в случае других ошибок. С GNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
> версии 1.23 и более поздними, вы можете использовать следующие ключи <TT
CLASS="LITERAL"
>--warning=no-file-changed --warning=no-file-removed</TT
>, чтобы скрыть соответствующие предупреждения.</P
><P
>Убедитесь, что ваша резервная копия включает все файлы из каталога кластера баз данных (например, <TT
CLASS="FILENAME"
>/usr/local/pgsql/data</TT
>). Если вы используете табличные пространства, которые находятся не внутри этого каталога, не забудьте включить и их в резервную копию (также важно, чтобы при создании резервной копии символьные ссылки сохранялись как ссылки, иначе табличные пространства будут повреждены при восстановлении).</P
><P
>Вы можете, однако, исключить из резервной копии файлы в подкаталоге данных кластера <TT
CLASS="FILENAME"
>pg_xlog/</TT
>. Эту небольшую корректировку стоит внести для снижения риска ошибок при восстановлении. Это легко организовать, если <TT
CLASS="FILENAME"
>pg_xlog/</TT
> — символическая ссылка на каталог за пределами каталога данных (так часто делают из соображений производительности). Также имеет смысл исключить файлы <TT
CLASS="FILENAME"
>postmaster.pid</TT
> и <TT
CLASS="FILENAME"
>postmaster.opts</TT
>, содержащие информацию о работающем процессе <SPAN
CLASS="APPLICATION"
>postmaster</SPAN
> (а не о том процессе <SPAN
CLASS="APPLICATION"
>postmaster</SPAN
>, который будет восстанавливать эту копию). (Эти файлы могут ввести <SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
> в заблуждение.)</P
><P
>Часто также стоит исключать из резервной копии каталог <TT
CLASS="FILENAME"
>pg_replslot/</TT
> кластера, чтобы слоты репликации, существующие на главном сервере, не попадали в копию. В противном случае, при последующем восстановлении копии на резервном сервере может получиться так, что он будет неограниченно долго сохранять файлы WAL, а главный не будет очищаться, если он следит за горячим резервом, так как клиенты этих слотов репликации будут продолжать подключаться и изменять состояние слотов на главном, а не резервном сервере. Даже если резервная копия предназначена только для создания нового главного сервера, копирование слотов репликации вряд ли принесёт пользу, так как к моменту включения в работу этого нового сервера содержимое этих слотов станет абсолютно неактуальным.</P
><P
>Также стоит отметить, что функция <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> создаёт в каталоге кластера файл <TT
CLASS="FILENAME"
>backup_label</TT
> (затем он удаляется функцией <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>). Данный файл, разумеется, заархивируется и войдёт в состав резервной копии. В этот файл записывается метка, заданная при вызове <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>, время запуска функции <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> и имя начального файла WAL. Таким образом, в случае сомнений можно заглянуть внутрь архива резервной копии и точно определить, в каком сеансе резервного копирования он был создан. Но этот файл не только к вашему сведению; его существование и содержание важны для правильного проведения процесса восстановления системы.</P
><P
>Вы также можете создать резервную копию, когда сервер остановлен. В этом случае, вы, очевидно, не сможете вызвать <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> или <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>, и следовательно, вам надо будет самостоятельно как-то идентифицировать резервные копии и понимать, какие файлы WAL должны быть заархивированы. Поэтому обычно всё-таки лучше следовать вышеописанной процедуре непрерывного архивирования.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-PITR-RECOVERY"
>24.3.4. Восстановление непрерывной архивной копии</A
></H2
><P
>Допустим, худшее случилось и вам необходимо восстановить базу данных из резервной копии. Порядок действий таков: <P
></P
></P><OL
TYPE="1"
><LI
><P
>Остановите сервер баз данных, если он запущен.</P
></LI
><LI
><P
>Если у вас есть место для этого, скопируйте весь текущий каталог кластера баз данных и все табличные пространства во временный каталог на случай, если они вам понадобятся. Учтите, что эта мера предосторожности требует, чтобы свободного места на диске было достаточно для размещения двух копий существующих данных. Если места недостаточно, необходимо сохранить как минимум содержимое подкаталога <TT
CLASS="FILENAME"
>pg_xlog</TT
> каталога кластера, так как он может содержать журналы, не попавшие в архив перед остановкой системы.</P
></LI
><LI
><P
>Удалите все существующие файлы и подкаталоги из каталога кластера и из корневых каталогов используемых табличных пространств.</P
></LI
><LI
><P
>Восстановите файлы базы данных из архивной копии файлов. Важно, чтобы у восстановленных файлов были правильные разрешения и правильный владелец (пользователь, запускающий сервер, а не <TT
CLASS="LITERAL"
>root</TT
>!). Если вы используете табличные пространства, убедитесь также, что символьные ссылки в <TT
CLASS="FILENAME"
>pg_tblspc/</TT
> восстановились корректно.</P
></LI
><LI
><P
>Удалите все файлы из <TT
CLASS="FILENAME"
>pg_xlog/</TT
>; они восстановились из резервной копии файлов и поэтому, скорее всего, будут старее текущих. Если вы вовсе не архивировали <TT
CLASS="FILENAME"
>pg_xlog/</TT
>, создайте этот каталог с правильными правами доступа, но если это была символьная ссылка, восстановите её.</P
></LI
><LI
><P
>Если на шаге 2 вы сохранили незаархивированные файлы с сегментами WAL, скопируйте их в <TT
CLASS="FILENAME"
>pg_xlog/</TT
>. (Лучше всего именно копировать, а не перемещать их, чтобы у вас остались неизменённые файлы на случай, если возникнет проблема и всё придётся начинать сначала.)</P
></LI
><LI
><P
>Создайте командный файл восстановления <TT
CLASS="FILENAME"
>recovery.conf</TT
> в каталоге кластера баз данных (см. <A
HREF="recovery-config.html"
>Главу 26</A
>). Вы можете также временно изменить <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>, чтобы обычные пользователи не могли подключаться, пока вы не будете уверены, что восстановление завершилось успешно.</P
></LI
><LI
><P
>Запустите сервер. Сервер запустится в режиме восстановления и начнёт считывать необходимые ему архивные файлы WAL. Если восстановление будет прервано из-за внешней ошибки, сервер можно просто перезапустить и он продолжит восстановление. По завершении процесса восстановления сервер переименует файл <TT
CLASS="FILENAME"
>recovery.conf</TT
> в <TT
CLASS="FILENAME"
>recovery.done</TT
> (чтобы предотвратить повторный запуск режима восстановления), а затем перейдёт к обычной работе с базой данных.</P
></LI
><LI
><P
>Просмотрите содержимое базы данных, чтобы убедиться, что вы вернули её к желаемому состоянию. Если это не так, вернитесь к шагу 1. Если всё хорошо, разрешите пользователям подключаться к серверу, восстановив обычный файл <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>.</P
></LI
></OL
><P></P
><P
>Ключевой момент этой процедуры заключается в создании файла конфигурации восстановления, описывающего, как будет выполняться восстановление и до какой точки. В качестве прототипа вы можете использовать файл <TT
CLASS="FILENAME"
>recovery.conf.sample</TT
> (он обычно помещается в каталог <TT
CLASS="FILENAME"
>share/</TT
> после установки). Единственное, что совершенно необходимо указать в <TT
CLASS="FILENAME"
>recovery.conf</TT
> &mdash; это команду <TT
CLASS="VARNAME"
>restore_command</TT
>, которая говорит <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, как получать из архива файл-сегменты WAL. Как и <TT
CLASS="VARNAME"
>archive_command</TT
>, это командная строка для оболочки. Она может содержать символы <TT
CLASS="LITERAL"
>%f</TT
>, которые заменятся именем требующегося файла журнала, и <TT
CLASS="LITERAL"
>%p</TT
>, которые заменятся целевым путём для копирования этого файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога кластера данных.) Если вам нужно включить в команду сам символ <TT
CLASS="LITERAL"
>%</TT
>, напишите <TT
CLASS="LITERAL"
>%%</TT
>. Простейшая команда, которая может быть полезна, такая: </P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'cp /mnt/server/archivedir/%f %p'</PRE
><P> Эта команда копирует заархивированные ранее сегменты WAL из каталога <TT
CLASS="FILENAME"
>/mnt/server/archivedir</TT
>. Разумеется, вы можете использовать что-то более сложное, возможно, даже скрипт оболочки, который укажет оператору установить соответствующую ленту.</P
><P
>Важно, чтобы данная команда возвращала ненулевой код возврата в случае ошибки. Эта команда <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>будет</I
></SPAN
> вызываться и с запросом файлов, отсутствующих в архиве; в этом случае она должна вернуть ненулевое значение и это считается штатной ситуацией. В исключительной ситуации, когда команда была прервана сигналом (кроме <SPAN
CLASS="SYSTEMITEM"
>SIGTERM</SPAN
>, который применяется в процессе остановки сервера базы данных) или произошла ошибка оболочки (например, команда не найдена), восстановление будет прервано и сервер не запустится.</P
><P
>Не все запрашиваемые файлы будут сегментами WAL; следует также ожидать запросов файлов с суффиксом <TT
CLASS="LITERAL"
>.backup</TT
> или <TT
CLASS="LITERAL"
>.history</TT
>. Также учтите, что базовое имя пути <TT
CLASS="LITERAL"
>%p</TT
> будет отличаться от <TT
CLASS="LITERAL"
>%f</TT
>; не думайте, что они взаимозаменяемы.</P
><P
>Сегменты WAL, которые не найдутся в архиве, система будет искать в <TT
CLASS="FILENAME"
>pg_xlog/</TT
>; благодаря этому можно использовать последние незаархивированные сегменты. Однако файлы в <TT
CLASS="FILENAME"
>pg_xlog/</TT
> будут менее предпочтительными, если такие сегменты окажутся в архиве.</P
><P
>Обычно при восстановлении обрабатываются все доступные сегменты WAL и, таким образом, база данных восстанавливается до последнего момента времени (или максимально близкого к нему, в зависимости от наличия сегментов WAL). Таким образом, восстановление обычно завершается с сообщением <SPAN
CLASS="QUOTE"
>"файл не найден"</SPAN
>; точный текст сообщения об ошибке зависит от того, что делает <TT
CLASS="VARNAME"
>restore_command</TT
>. Вы также можете увидеть сообщение об ошибке в начале восстановления для файла с именем типа <TT
CLASS="FILENAME"
>00000001.history</TT
>. Это также нормально и обычно не говорит о какой-либо проблеме при восстановлении в простых ситуациях; подробнее об этом рассказывается в <A
HREF="continuous-archiving.html#BACKUP-TIMELINES"
>Подразделе 24.3.5</A
>.</P
><P
>Если вы хотите восстановить базу на какой-то момент времени (скажем, до момента, когда неопытный администратор базы данных удалил основную таблицу транзакций), просто укажите требуемую <A
HREF="recovery-target-settings.html"
>точку остановки</A
> в <TT
CLASS="FILENAME"
>recovery.conf</TT
>. Вы можете задать точку останова, так называемую <SPAN
CLASS="QUOTE"
>"цель восстановления"</SPAN
>, по дате/времени, именованной точке восстановления или определённому идентификатору транзакции. На момент написания этой документации полезными могут быть только указания даты/времени или имени точки восстановления, пока нет никаких средств, позволяющих точно определить, какой идентификатор транзакции нужно выбрать.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Точка останова должна указывать на момент после окончания базового копирования, т. е. после времени завершения <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>. Использовать базовую резервную копию для восстановления на момент времени, когда она ещё только создавалась, нельзя. (Чтобы восстановить данные на этот момент времени, придётся вернуться к предыдущей базовой резервной копии и накатывать изменения с этой позиции.)</P
></BLOCKQUOTE
></DIV
><P
>Если при восстановлении обнаруживаются повреждённые данные WAL, восстановление прерывается в этом месте и сервер не запускается. В этом случае процесс восстановления можно перезапустить с начала, указав <SPAN
CLASS="QUOTE"
>"цель восстановления"</SPAN
> до точки повреждения, чтобы восстановление могло завершиться нормально. Если восстановление завершается ошибкой из-за внешней причины, например, из-за краха системы или недоступности архива WAL, его можно просто перезапустить, и оно продолжится с того места, где было прервано. Перезапуск восстановления реализован по тому же принципу, что и контрольные точки при обычной работе: сервер периодически сохраняет всё текущее состояние на диске и отражает это в файле <TT
CLASS="FILENAME"
>pg_control</TT
>, чтобы уже обработанные данные WAL не приходилось сканировать снова.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIMELINES"
>24.3.5. Линии времени</A
></H2
><P
>Возможность восстановить базу данных на некий предыдущий момент времени создаёт некоторые сложности, сродни научно-фантастическим историям о путешествиях во времени и параллельных мирах. Например, предположим, что в начальной истории базы данных вы удалили важную таблицу в 17:15 во вторник, но осознали эту ошибку только в среду в полдень. Вы можете спокойно взять резервную копию, восстановить данные на 17:14 во вторник и запустить сервер. В <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>этой</I
></SPAN
> истории мира базы данных вы никогда не удаляли вышеупомянутую таблицу. Но предположим, что позже вы заметили, что это была не такая уж хорошая идея и захотели вернуться к утру среды в первоначальной истории базы данных. Вы не сможете сделать это, если в процессе работы базы данных она успеет перезаписать какие-либо файлы-сегменты WAL, приводящие к моменту времени, к которому вы хотите вернуться теперь. Таким образом, для получения желаемого результата необходимо как-то отличать последовательности записей WAL, добавленные после восстановления на какой-то момент времени от тех, что существовали в начальной истории базы данных.</P
><P
>Для решения этой проблемы в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть такое понятие, как <I
CLASS="FIRSTTERM"
>линия времени</I
>. Всякий раз, когда завершается восстановление из архива, создаётся новая линия времени, позволяющая идентифицировать последовательность записей WAL, добавленных после этого восстановления. Номер линии времени включается в имя файлов-сегментов WAL, так что файлы новой линии времени не перезаписывают файлы WAL, сгенерированные предыдущими линиями времени. Фактически это позволяет архивировать много различных линий времени. Хотя это может показаться бесполезной возможностью, на самом деле она часто бывает спасительной. Представьте, что вы не определились, какую точку времени выбрать для восстановления, и таким образом должны проводить восстановление методом проб и ошибок, пока не найдёте лучший момент для ответвления от старой истории. Без линий времени этот процесс быстро стал бы очень запутанным. А благодаря линиям времени, вы можете вернуться к <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>любому</I
></SPAN
> предыдущему состоянию, включая состояния в ветках линий времени, покинутых ранее.</P
><P
>Каждый раз, когда образуется новая линия времени, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> создаёт файл <SPAN
CLASS="QUOTE"
>"истории линии времени"</SPAN
>, показывающий, от какой линии времени ответвилась данная и когда. Эти файлы истории нужны, чтобы система могла выбрать правильные файлы-сегменты WAL при восстановлении из архива, содержащего несколько линий времени. Таким образом, они помещаются в область архивов WAL так же, как и файлы сегментов WAL. Файлы истории представляют собой небольшие текстовые файлы, так что они не занимают много места и их вполне можно сохранять неограниченно долго (в отличие от файлов сегментов, имеющих большой размер). Если хотите, вы можете добавлять в файл истории комментарии, свои собственные заметки о том, как и почему была создана эта конкретная линия времени. Такие комментарии будут особенно ценны, если в результате экспериментов у вас образуется хитросплетение разных линий времени.</P
><P
>По умолчанию при восстановлении восстанавливается та же линия времени, которая была текущей при создании базовой резервной копии. Если вы хотите восстановить состояние на какой-либо дочерней линии времени, (то есть, хотите вернуться к некоторому состоянию, которое тоже было получено в результате попытки восстановления), вам необходимо указать идентификатор целевой линии времени в <TT
CLASS="FILENAME"
>recovery.conf</TT
>. Восстановить состояние в линии времени, ответвившейся раньше, чем была сделана базовая резервная копия, нельзя.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIPS"
>24.3.6. Советы и примеры</A
></H2
><P
>Ниже мы дадим несколько советов по настройке непрерывного архивирования.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-STANDALONE"
>24.3.6.1. Обособленные горячие резервные копии</A
></H3
><P
>Средства резервного копирования <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> можно применять для создания обособленных горячих копий. Эти копии нельзя использовать для восстановления на момент времени, но создаются и восстанавливаются они обычно гораздо быстрее, чем дампы <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. (Они также намного больше, чем дампы <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, так что в некоторых случаях выигрыш в скорости может быть потерян.)</P
><P
>Как и базовые резервные копии, обособленную горячую копию проще всего получить, используя программу <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>. Если вы вызовете эту программу с параметром <TT
CLASS="LITERAL"
>-X</TT
>, в эту копию автоматически будет включён весь журнал транзакций, необходимый для её использования, так что никакие особые действия для восстановления не потребуются.</P
><P
>Если нужна дополнительная гибкость в процессе копирования файлов, создавать обособленные горячие копии можно также на более низком уровне. Чтобы подготовиться к получению такой копии на низком уровне, установите в <TT
CLASS="VARNAME"
>wal_level</TT
> уровень <TT
CLASS="LITERAL"
>archive</TT
> (или выше), в <TT
CLASS="VARNAME"
>archive_mode</TT
> значение <TT
CLASS="LITERAL"
>on</TT
> и настройте команду <TT
CLASS="VARNAME"
>archive_command</TT
>, которая будет выполнять архивацию, только когда существует <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>файл-переключатель</I
></SPAN
>. Например: </P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'</PRE
><P> Данная команда выполнит архивацию, если будет существовать файл <TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
>, а в противном случае просто вернёт нулевой код возврата (и тогда <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> сможет переработать ненужный файл WAL).</P
><P
>После такой подготовки резервную копию можно создать, например таким скриптом: </P><PRE
CLASS="PROGRAMLISTING"
>touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/</PRE
><P> Сначала создаётся файл-переключатель <TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
>, включающий архивирование заполненных файлов WAL. По окончании резервного копирования файл-переключатель удаляется. Затем заархивированные файлы WAL тоже добавляются в резервную копию, так что в одном архиве <SPAN
CLASS="APPLICATION"
>tar</SPAN
> оказывается и базовая резервная копия, и все требуемые файлы WAL. Пожалуйста, не забудьте добавить в ваши скрипты резервного копирования обработку ошибок.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="COMPRESSED-ARCHIVE-LOGS"
>24.3.6.2. Сжатие журналов в архиве</A
></H3
><P
>Если размер архива имеет большое значение, можно воспользоваться <SPAN
CLASS="APPLICATION"
>gzip</SPAN
> и сжимать архивные файлы: </P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'</PRE
><P> При этом для восстановления придётся использовать <SPAN
CLASS="APPLICATION"
>gunzip</SPAN
>: </P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'</PRE
><P></P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-SCRIPTS"
>24.3.6.3. Скрипты <TT
CLASS="VARNAME"
>archive_command</TT
></A
></H3
><P
>Многие в качестве команды <TT
CLASS="VARNAME"
>archive_command</TT
> используют скрипты, так что запись в <TT
CLASS="FILENAME"
>postgresql.conf</TT
> оказывается очень простой: </P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'local_backup_script.sh "%p" "%f"'</PRE
><P> Применять отдельный файла скрипта целесообразно всегда, когда вы хотите использовать в процедуре архивирования несколько команд. Это позволяет управлять сложностью этой процедуры в рамках одного скрипта, который можно написать на любом популярном языке скриптов, например на <SPAN
CLASS="APPLICATION"
>bash</SPAN
> или <SPAN
CLASS="APPLICATION"
>perl</SPAN
>.</P
><P
>В частности, с помощью скриптов можно решить такие задачи: <P
></P
></P><UL
><LI
><P
>Копирование данных в безопасное внешнее хранилище</P
></LI
><LI
><P
>Пакетная обработка файлов WAL, чтобы они передавались каждые три часа, а не по одному</P
></LI
><LI
><P
>Взаимодействие с другими приложениями резервного копирования и восстановления</P
></LI
><LI
><P
>Взаимодействие со средствами мониторинга, регистрация ошибок</P
></LI
></UL
><P></P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Когда в <TT
CLASS="VARNAME"
>archive_command</TT
> используется скрипт, желательно включить <A
HREF="runtime-config-logging.html#GUC-LOGGING-COLLECTOR"
>logging_collector</A
>. Тогда все сообщения, которые скрипт выведет в <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>, будут записываться в журнал сервера баз данных, что позволит легко диагностировать ошибки в сложных конфигурациях.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONTINUOUS-ARCHIVING-CAVEATS"
>24.3.7. Ограничения</A
></H2
><P
>На момент написания документации методика непрерывного архивирования имеет несколько ограничений. Они могут быть ликвидированы в будущих версиях: <P
></P
></P><UL
><LI
><P
>Операции с хеш-индексами в настоящее время не проходят через WAL, так что при воспроизведении WAL эти индексы не меняются. Это означает, что добавление данных будет игнорироваться индексом, изменяемые строки будут исчезать, а на удалённые строки сохранятся ссылки. Другими словами, если вы изменяете таблицу, для которой есть хеш-индекс, на резервном сервере вы будете получать некорректные результаты запросов. Поэтому по завершении восстановления рекомендуется вручную выполнить <A
HREF="sql-reindex.html"
>REINDEX</A
> для каждого такого индекса.</P
></LI
><LI
><P
>Если во время создания базовой резервной копии выполняется команда <A
HREF="sql-createdatabase.html"
>CREATE DATABASE</A
>, а затем база-шаблон, задействованная в <TT
CLASS="COMMAND"
>CREATE DATABASE</TT
>, изменяется, пока продолжается копирование, возможно, что при восстановлении эти изменения распространятся также и на созданную базу данных. Конечно, это нежелательно. Во избежание подобных рисков, лучше всего не изменять никакие базы-шаблоны во время получения базовой резервной копии.</P
></LI
><LI
><P
>Команды <A
HREF="sql-createtablespace.html"
>CREATE TABLESPACE</A
> записываются в WAL с абсолютным путём и, таким образом, при воспроизведении WAL будут выполнены с тем же абсолютным путём. Это может быть нежелательно, если журнал воспроизводится на другой машине. Но опасность есть, даже если журнал воспроизводится на той же машине, но в другом каталоге данных: при воспроизведении будет так же перезаписано содержимое исходных табличных пространств. Чтобы избежать потенциальных проблем такого рода, лучше всего делать новую базовую резервную копию после создания или удаления табличных пространств.</P
></LI
></UL
><P></P
><P
>Также следует заметить, что стандартный формат <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> не очень компактный, так как включает много снимков дисковых страниц. Эти снимки страниц предназначены для поддержки восстановления после сбоя, на случай, если понадобится исправить страницы, записанные на диск частично. В зависимости от аппаратного и программного обеспечения вашей системы, риск частичной записи может быть достаточно мал, так что его можно игнорировать, и в этом случае можно существенно уменьшить общий объём архивируемых журналов, выключив снимки страниц с помощью параметра <A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>. (Прежде чем делать это, прочтите замечания и предупреждения в <A
HREF="wal.html"
>Главе 29</A
>.) Выключение снимков страниц не препятствует использованию журналов для восстановления PITR. Одним из направлений разработки в будущем является сжатие архивируемых данных WAL, путём удаления ненужных копий страниц даже при включённом режиме <TT
CLASS="VARNAME"
>full_page_writes</TT
>. Тем временем администраторы могут сократить количество снимков страниц, включаемых в WAL, увеличив параметры интервала контрольных точек в разумных пределах.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup-file.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Резервное копирование на уровне файлов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Отказоустойчивость, балансировка нагрузки и репликация</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>