<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Функции на языке запросов (SQL)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Расширение SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Пользовательские функции"
HREF="xfunc.html"><LINK
REL="NEXT"
TITLE="Перегрузка функций"
HREF="xfunc-overload.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Пользовательские функции"
HREF="xfunc.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 35. Расширение <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Перегрузка функций"
HREF="xfunc-overload.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-SQL"
>35.4. Функции на языке запросов (<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>)</A
></H1
><P
>SQL-функции выполняют произвольный список операторов SQL и возвращают результат последнего запроса в списке. В простом случае (не с множеством) будет возвращена первая строка результата последнего запроса. (Помните, что понятие <SPAN
CLASS="QUOTE"
>"первая строка"</SPAN
> в наборе результатов с несколькими строками определено точно, только если присутствует <TT
CLASS="LITERAL"
>ORDER BY</TT
>.) Если последний запрос вообще не вернёт строки, будет возвращено значение NULL.</P
><P
>Кроме того, можно объявить SQL-функцию как возвращающую множество (то есть, несколько строк), указав в качестве возвращаемого типа функции <TT
CLASS="LITERAL"
>SETOF <TT
CLASS="REPLACEABLE"
><I
>некий_тип</I
></TT
></TT
>, либо объявив её с указанием <TT
CLASS="LITERAL"
>RETURNS TABLE(<TT
CLASS="REPLACEABLE"
><I
>колонки</I
></TT
>)</TT
>. В этом случае будут возвращены все строки результата последнего запроса. Подробнее это описывается ниже.</P
><P
>Тело SQL-функции должно представлять собой список SQL-операторов, разделённых точкой с запятой. Точка с запятой после последнего оператора может отсутствовать. Если только функция не объявлена как возвращающая <TT
CLASS="TYPE"
>void</TT
>, последним оператором должен быть <TT
CLASS="COMMAND"
>SELECT</TT
>, либо <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
> или <TT
CLASS="COMMAND"
>DELETE</TT
> с предложением <TT
CLASS="LITERAL"
>RETURNING</TT
>.</P
><P
>Любой набор команд на языке <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> можно скомпоновать вместе и обозначить как функцию. Помимо запросов <TT
CLASS="COMMAND"
>SELECT</TT
>, эти команды могут включать запросы, изменяющие данные (<TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
> и <TT
CLASS="COMMAND"
>DELETE</TT
>), а также другие SQL-команды. (В <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-функциях нельзя использовать команды управления транзакциями, например <TT
CLASS="COMMAND"
>COMMIT</TT
>, <TT
CLASS="COMMAND"
>SAVEPOINT</TT
>, и некоторые вспомогательные команды, в частности <TT
CLASS="LITERAL"
>VACUUM</TT
>.) Однако последней командой должна быть <TT
CLASS="COMMAND"
>SELECT</TT
> или команда с предложением <TT
CLASS="LITERAL"
>RETURNING</TT
>, возвращающая результат с типом возврата функции. Если же вы хотите определить функцию SQL, выполняющую действия, но не возвращающую полезное значение, вы можете объявить её как возвращающую тип <TT
CLASS="TYPE"
>void</TT
>. Например, эта функция удаляет строки с отрицательным жалованьем из таблицы <TT
CLASS="LITERAL"
>emp</TT
>: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)</PRE
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Прежде чем начинается выполнение команд, разбирается всё тело SQL-функции. Когда SQL-функция содержит команды, модифицирующие системные каталоги (например, <TT
CLASS="COMMAND"
>CREATE TABLE</TT
>), действие таких команд не будет видимо на стадии анализа последующих команд этой функции. Так, например, команды <TT
CLASS="LITERAL"
>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</TT
> не будут работать, как ожидается, если их упаковать в одну SQL-функцию, так как <TT
CLASS="STRUCTNAME"
>foo</TT
> не будет существовать к моменту разбору команды <TT
CLASS="COMMAND"
>INSERT</TT
>. В подобных ситуациях вместо SQL-функции рекомендуется использовать <SPAN
CLASS="APPLICATION"
>PL/PgSQL</SPAN
>.</P
></BLOCKQUOTE
></DIV
><P
>Синтаксис команды <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> требует, чтобы тело функции было записано как строковая константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING"
>Подраздел 4.1.2.4</A
>). Если вы решите использовать обычный синтаксис с заключением строки в апострофы, вам придётся дублировать апострофы (<TT
CLASS="LITERAL"
>'</TT
>) и обратную косую черту (<TT
CLASS="LITERAL"
>\</TT
>) (предполагается синтаксис спецпоследовательностей) в теле функции (см. <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS"
>Подраздел 4.1.2.1</A
>).</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-FUNCTION-ARGUMENTS"
>35.4.1. Аргументы <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-функций</A
></H2
><P
>К аргументам SQL-функции можно обращаться в теле функции по именам или номерам. Ниже приведены примеры обоих вариантов.</P
><P
>Чтобы использовать имя, объявите аргумент функции как именованный, а затем просто пишите это имя в теле функции. Если имя аргумента совпадает с именем какой-либо колонки в текущей SQL-команде внутри функции, имя колонки будет иметь приоритет. Чтобы всё же перекрыть имя колонки, дополните имя аргумента именем самой функции, то есть запишите его в виде <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>имя_аргумента</I
></TT
></TT
>. (Если и это имя будет конфликтовать с полным именем колонки, снова выиграет имя колонки. Неоднозначности в этом случае вы можете избежать, выбрав другой псевдоним для таблицы в SQL-команде.)</P
><P
>Старый подход с нумерацией позволяет обращаться к аргументам, применяя запись <TT
CLASS="LITERAL"
>$<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></TT
>: <TT
CLASS="LITERAL"
>$1</TT
> обозначает первый аргумент, <TT
CLASS="LITERAL"
>$2</TT
> — второй и т. д. Это будет работать и в том случае, если данному аргументу назначено имя.</P
><P
>Если аргумент имеет составной тип, то для обращения к его атрибутам можно использовать запись с точкой, например: <TT
CLASS="LITERAL"
>аргумент.поле</TT
> или <TT
CLASS="LITERAL"
>$1.поле</TT
>. И опять же, при этом может потребоваться дополнить имя аргумента именем функции, чтобы сделать имя аргумента однозначным.</P
><P
>Аргументы SQL-функции могут использоваться только как значения данных, но не как идентификаторы. Например, это приемлемо: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO mytable VALUES ($1);</PRE
><P> а это не будет работать: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO $1 VALUES (42);</PRE
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Возможность обращаться к аргументам SQL-функций по именам появилась в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.2. В функциях, которые должны работать со старыми серверами, необходимо применять запись <TT
CLASS="LITERAL"
>$<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-BASE-FUNCTIONS"
>35.4.2. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> с базовыми типами</A
></H2
><P
>Простейшая возможная функция <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> не имеет аргументов и просто возвращает базовый тип, например <TT
CLASS="TYPE"
>integer</TT
>: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- Альтернативная запись строковой константы:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1</PRE
><P></P
><P
>Заметьте, что мы определили псевдоним колонки в теле функции для её результата (дали ему имя <TT
CLASS="LITERAL"
>result</TT
>), но этот псевдоним не виден снаружи функции. Вследствие этого, колонка результата получила имя <TT
CLASS="LITERAL"
>one</TT
>, а не <TT
CLASS="LITERAL"
>result</TT
>.</P
><P
>Практически так же легко определяются функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, которые принимают в аргументах базовые типы: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3</PRE
><P></P
><P
>Мы также можем отказаться от имён аргументов и обращаться к ним по номерам: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3</PRE
><P></P
><P
>Вот более полезная функция, которую можно использовать, чтобы дебетовать банковский счёт: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;</PRE
><P> Пользователь может выполнить эту функцию, чтобы дебетовать счёт 17 на 100 долларов, так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT tf1(17, 100.0);</PRE
><P></P
><P
>В этом примере мы выбрали имя <TT
CLASS="LITERAL"
>accountno</TT
> для первого аргумента, но это же имя имеет колонка в таблице <TT
CLASS="LITERAL"
>bank</TT
>. В команде <TT
CLASS="COMMAND"
>UPDATE</TT
> имя <TT
CLASS="LITERAL"
>accountno</TT
> относится к колонке <TT
CLASS="LITERAL"
>bank.accountno</TT
>, так для обращения к аргументу нужно записать <TT
CLASS="LITERAL"
>tf1.accountno</TT
>. Конечно, мы могли бы избежать этого, выбрав другое имя для аргумента.</P
><P
>На практике обычно желательно получать от функции более полезный результат, чем константу 1, поэтому более реалистично такое определение: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;</PRE
><P> Эта функция изменяет баланс и возвращает полученное значение. То же самое можно сделать в одной команде, применив <TT
CLASS="LITERAL"
>RETURNING</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-COMPOSITE-FUNCTIONS"
>35.4.3. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> со сложными типами</A
></H2
><P
>В функциях с аргументами составных типов мы должны указывать не только, какой аргумент, но и какой атрибут (поле) этого аргумента нам нужен. Например, предположим, что <TT
CLASS="TYPE"
>emp</TT
> — таблица, содержащая данные работников, и это же имя составного типа, представляющего каждую строку таблицы. Следующая функция <CODE
CLASS="FUNCTION"
>double_salary</CODE
> вычисляет, каким было бы чьё-либо жалование в случае увеличения вдвое: </P><PRE
CLASS="SCREEN"
>CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400</PRE
><P></P
><P
>Обратите внимание на запись <TT
CLASS="LITERAL"
>$1.salary</TT
>, позволяющую выбрать одно поле из значения строки аргумента. Также заметьте, что в вызывающей команде <TT
CLASS="COMMAND"
>SELECT</TT
> указание <TT
CLASS="LITERAL"
>*</TT
> выбирает всю текущую строку таблицы как составное значение. На строку таблицы можно сослаться и просто по имени таблицы, например так: </P><PRE
CLASS="SCREEN"
>SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';</PRE
><P> Однако это использование считается устаревшим, так как провоцирует путаницу.</P
><P
>Иногда бывает удобно образовать составное значение аргумента на лету. Это позволяет сделать конструкция <TT
CLASS="LITERAL"
>ROW</TT
>. Например, так можно изменить данные, передаваемые функции: </P><PRE
CLASS="SCREEN"
>SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;</PRE
><P></P
><P
>Также возможно создать функцию, возвращающую составной тип. Например, эта функция возвращает одну строку <TT
CLASS="TYPE"
>emp</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;</PRE
><P> В этом примере мы задали для каждого атрибута постоянное значение, но вместо этих констант можно подставить любые вычисления.</P
><P
>Учтите два важных требования относительно определения функции: <P
></P
></P><UL
><LI
><P
>Порядок в списке выборки внутреннего запроса должен в точности совпадать с порядком следования колонок в таблице, связанной с составным типом. (Имена колонок, как показывает пример выше, для системы значения не имеют.)</P
></LI
><LI
><P
>Вы должны привести выражения в соответствие с определением составного типа, либо вы получите такие ошибки: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>ERROR:  function declared to return emp returns varchar instead of text at column 1</SAMP
></PRE
><P> (ОШИБКА:  функция, объявленная как возвращающая emp, возвращает varchar вместо text в колонке 1)</P
></LI
></UL
><P></P
><P
>Ту же функцию можно определить другим способом: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;</PRE
><P> Здесь мы записали <TT
CLASS="COMMAND"
>SELECT</TT
>, который возвращает одну колонку нужного составного типа. В данной ситуации этот вариант на самом деле не лучше, но в некоторых случаях он может быть удобной альтернативой &mdash; например, если нам нужно вычислить результат, вызывая другую функцию, которая возвращает нужное составное значение.</P
><P
>Мы можем вызвать эту функцию напрямую двумя способами: </P><PRE
CLASS="SCREEN"
>SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")

SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)</PRE
><P> Второй способ описан более подробно в <A
HREF="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS"
>Подразделе 35.4.7</A
>.</P
><P
>Когда используется функция, возвращающая составной тип, может возникнуть желание получить из её результата только одно поле (атрибут). Это можно сделать, применяя такую запись: </P><PRE
CLASS="SCREEN"
>SELECT (new_emp()).name;

 name
------
 None</PRE
><P> Дополнительные скобки необходимы во избежание неоднозначности при разборе запроса. Если вы попытаетесь выполнить запрос без них, вы получите ошибку: </P><PRE
CLASS="SCREEN"
>SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^</PRE
><P>
(ОШИБКА:  синтаксическая ошибка (примерное положение: "."))</P
><P
>В качестве ещё одного варианта можно использовать функциональную запись для извлечения атрибута. Проще всего это можно объяснить, отметив, что записи <TT
CLASS="LITERAL"
>атрибут(таблица)</TT
> и <TT
CLASS="LITERAL"
>таблица.атрибут</TT
> взаимозаменяемы. </P><PRE
CLASS="SCREEN"
>SELECT name(new_emp());

 name
------
 None</PRE
><P>

</P><PRE
CLASS="SCREEN"
>-- Это то же самое:
-- SELECT emp.name AS youngster FROM emp WHERE emp.age &lt; 30;

SELECT name(emp) AS youngster FROM emp WHERE age(emp) &lt; 30;

 youngster
-----------
 Sam
 Andy</PRE
><P></P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Равнозначность функциональной записи и записи с атрибутом позволяет использовать функции с составными типами для имитации <SPAN
CLASS="QUOTE"
>"вычисляемых полей"</SPAN
>.  Например, используя предыдущее определение <TT
CLASS="LITERAL"
>double_salary(emp)</TT
>, мы можем записать </P><PRE
CLASS="SCREEN"
>SELECT emp.name, emp.double_salary FROM emp;</PRE
><P> Приложению, использующему такой запрос, не обязательно определённо знать, что <TT
CLASS="LITERAL"
>double_salary</TT
> — это не настоящая колонка таблицы. (Вычисляемые поля также можно имитировать в представлениях.)</P
><P
>Вследствие такого поведения, функции, которая принимает один аргумент составного типа, не стоит давать имя, совпадающее с именем одного из полей этого составного типа.</P
></BLOCKQUOTE
></DIV
><P
>Ещё один вариант использования функции, возвращающей составной тип, заключается в передаче её результата другой функции, которая принимает этот тип строки на вход: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)</PRE
><P></P
><P
>И ещё один способ использовать функцию, возвращающую составной тип — вызвать её как табличную функцию, как описано в <A
HREF="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS"
>Подразделе 35.4.7</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-OUTPUT-PARAMETERS"
>35.4.4. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> с выходными параметрами</A
></H2
><P
>Альтернативный способ описать результаты функции — определить её с <I
CLASS="FIRSTTERM"
>выходными параметрами</I
>, как в этом примере: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)</PRE
><P> Это по сути не отличается от версии <TT
CLASS="LITERAL"
>add_em</TT
>, показанной в <A
HREF="xfunc-sql.html#XFUNC-SQL-BASE-FUNCTIONS"
>Подразделе 35.4.2</A
>. Действительная ценность выходных параметров в том, что они позволяют удобным способом определить функции, возвращающие несколько колонок. Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)</PRE
><P> Фактически здесь мы определили анонимный составной тип для результата функции. Показанный выше пример даёт тот же конечный результат, что и команды: </P><PRE
CLASS="SCREEN"
>CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;</PRE
><P> Но предыдущий вариант зачастую удобнее, так как он не требует отдельно заниматься определением составного типа. Заметьте, что имена, назначаемые выходным параметрам, не просто декоративные, а определяют имена колонок анонимного составного типа. (Если вы опустите имя выходного параметра, система выберет имя сама.)</P
><P
>Заметьте, что выходные параметры не включаются в список аргументов при вызове такой функции из SQL. Это объясняется тем, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> определяет сигнатуру вызова функции, рассматривая только входные параметры. Это также значит, что при таких операциях, как удаление функции, в ссылках на функцию учитываются только типы входных параметров. Таким образом, удалить эту конкретную функцию можно любой из этих команд: </P><PRE
CLASS="SCREEN"
>DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);</PRE
><P></P
><P
>Параметры функции могут быть объявлены как <TT
CLASS="LITERAL"
>IN</TT
> (по умолчанию), <TT
CLASS="LITERAL"
>OUT</TT
>, <TT
CLASS="LITERAL"
>INOUT</TT
> или <TT
CLASS="LITERAL"
>VARIADIC</TT
>. Параметр <TT
CLASS="LITERAL"
>INOUT</TT
> действует как входной (является частью списка аргументов при вызове) и как выходной (часть типа записи результата). Параметры <TT
CLASS="LITERAL"
>VARIADIC</TT
> являются входными, но обрабатывается специальным образом, как описано далее.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-VARIADIC-FUNCTIONS"
>35.4.5. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> с переменным числом аргументов</A
></H2
><P
>Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> могут быть объявлены как принимающие переменное число аргументов, с условием, что все <SPAN
CLASS="QUOTE"
>"необязательные"</SPAN
> аргументы имеют один тип данных. Необязательные аргументы будут переданы такой функции в виде массива. Для этого в объявлении функции последний параметр помечается как <TT
CLASS="LITERAL"
>VARIADIC</TT
>; при этом он должен иметь тип массива. Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)</PRE
><P> По сути, все фактические аргументы, начиная с позиции <TT
CLASS="LITERAL"
>VARIADIC</TT
>, собираются в одномерный массив, как если бы вы написали </P><PRE
CLASS="SCREEN"
>SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- это не будет работать</PRE
><P> На самом деле так вызвать эту функцию нельзя, или, по крайней мере, это не будет соответствовать определению функции. Параметру <TT
CLASS="LITERAL"
>VARIADIC</TT
> соответствуют одно или несколько вхождений типа его элемента, но не его собственного типа.</P
><P
>Но иногда бывает полезно передать функции с переменными параметрами уже подготовленный массив; особенно когда одна функция с переменными параметрами хочет передавать свой массив параметров другой. Это можно сделать, указав <TT
CLASS="LITERAL"
>VARIADIC</TT
> в вызове: </P><PRE
CLASS="SCREEN"
>SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);</PRE
><P> Это предотвращает разворачивание переменного множества параметров функции в базовый тип, что позволяет сопоставить с ним значение типа массива. <TT
CLASS="LITERAL"
>VARIADIC</TT
> можно добавить только к последнему фактическому аргументу вызова функции.</P
><P
>Также указание <TT
CLASS="LITERAL"
>VARIADIC</TT
> даёт единственную возможность передать пустой массив функции с переменными параметрами, например, так: </P><PRE
CLASS="SCREEN"
>SELECT mleast(VARIADIC ARRAY[]::numeric[]);</PRE
><P> Простой вызов <TT
CLASS="LITERAL"
>SELECT mleast()</TT
> не будет работать, так как переменным параметрам должен соответствовать минимум один фактический аргумент. (Можно определить вторую функцию с таким же именем <TT
CLASS="LITERAL"
>mleast</TT
>, но без параметров, если вы хотите выполнять такие вызовы.)</P
><P
>Элементы массива, создаваемые из переменных параметров, считаются не имеющими собственных имён. Это означает, что передать функции с переменными параметрами именованные аргументы нельзя (см. <A
HREF="sql-syntax-calling-funcs.html"
>Раздел 4.3</A
>), если только при вызове не добавлено <TT
CLASS="LITERAL"
>VARIADIC</TT
>. Например, этот вариант будет работать: </P><PRE
CLASS="SCREEN"
>SELECT mleast(VARIADIC arr := ARRAY[10, -1, 5, 4.4]);</PRE
><P> А эти варианты нет: </P><PRE
CLASS="SCREEN"
>SELECT mleast(arr := 10);
SELECT mleast(arr := ARRAY[10, -1, 5, 4.4]);</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-PARAMETER-DEFAULTS"
>35.4.6. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> со значениями аргументов по умолчанию</A
></H2
><P
>Функции могут быть объявлены со значениями по умолчанию для некоторых или всех входных аргументов. Значения по умолчанию подставляются, когда функция вызывается с недостаточным количеством фактических аргументов. Так как аргументы можно опускать только с конца списка фактических аргументов, все параметры после параметра со значением по умолчанию также получат значения по умолчанию. (Хотя запись с именованными аргументами могла бы ослабить это ограничение, оно всё же остаётся в силе, чтобы позиционные ссылки на аргументы оставались действительными.)</P
><P
>Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

SELECT foo();  -- не работает из-за отсутствия значения по умолчанию для первого аргумента
ERROR:  function foo() does not exist</PRE
><P> (ОШИБКА: функция foo() не существует) Вместо ключевого слова <TT
CLASS="LITERAL"
>DEFAULT</TT
> можно использовать знак <TT
CLASS="LITERAL"
>=</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-TABLE-FUNCTIONS"
>35.4.7. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, порождающие таблицы</A
></H2
><P
>Все функции SQL можно использовать в предложении <TT
CLASS="LITERAL"
>FROM</TT
> запросов, но наиболее полезно это для функций, возвращающих составные типы. Если функция объявлена как возвращающая базовый тип, она возвращает таблицу с одной колонкой. Если же функция объявлена как возвращающая составной тип, она возвращает таблицу с колонками для каждого атрибута составного типа.</P
><P
>Например: </P><PRE
CLASS="SCREEN"
>CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)</PRE
><P> Как показывает этот пример, мы можем работать с колонками результата функции так же, как если бы это были колонки обычной таблицы.</P
><P
>Заметьте, что мы получаем из данной функции только одну строку. Это объясняется тем, что мы не использовали указание <TT
CLASS="LITERAL"
>SETOF</TT
>. Оно описывается в следующем разделе.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-FUNCTIONS-RETURNING-SET"
>35.4.8. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, возвращающие множества</A
></H2
><P
>Когда SQL-функция объявляется как возвращающая <TT
CLASS="LITERAL"
>SETOF <TT
CLASS="REPLACEABLE"
><I
>некий_тип</I
></TT
></TT
>, конечный запрос функции выполняется до завершения и каждая строка выводится как элемент результирующего множества.</P
><P
>Это обычно используется, когда функция вызывается в предложении <TT
CLASS="LITERAL"
>FROM</TT
>. В этом случае каждая строка, возвращаемая функцией, становится строкой таблицы, появляющейся в запросе. Например, в предположении, что таблица <TT
CLASS="LITERAL"
>foo</TT
> имеет то же содержимое, что и раньше, мы выполняем: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;</PRE
><P> Тогда в ответ мы получим: </P><PRE
CLASS="SCREEN"
> fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)</PRE
><P></P
><P
>Также возможно выдать несколько строк с колонками, определяемыми выходными параметрами, следующим образом: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)</PRE
><P> Здесь ключевая особенность заключается в записи <TT
CLASS="LITERAL"
>RETURNS SETOF record</TT
>, показывающей, что функция возвращает множество строк вместо одной. Если существует только один выходной параметр, укажите тип этого параметра вместо <TT
CLASS="TYPE"
>record</TT
>.</P
><P
>Часто бывает полезно сконструировать результат запроса, вызывая функцию, возвращающую множество, несколько раз, передавая при каждом вызове параметры из очередных строк таблицы или подзапроса. Для этого рекомендуется применить ключевое слово <TT
CLASS="LITERAL"
>LATERAL</TT
>, описываемое в <A
HREF="queries-table-expressions.html#QUERIES-LATERAL"
>Подразделе 7.2.1.5</A
>. Ниже приведён пример использования функции, возвращающей множество, для перечисления элементов древовидной структуры: </P><PRE
CLASS="SCREEN"
>SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)</PRE
><P> В этом примере не делается ничего такого, что мы не могли бы сделать, применив простое соединение, но для более сложных вычислений возможность поместить некоторую логику в функцию может быть весьма удобной.</P
><P
>В настоящее время функции, возвращающие множества, могут также вызываться в списке выборки запроса. Для каждой строки, которая генерируется самим запросом, вызывается функция, возвращающая множество, и для каждого элемента набора её результатов генерируется отдельная строка. Заметьте, однако, что эта возможность считается устаревшей и может быть ликвидирована в будущих выпусках. Предыдущий пример можно было бы также переписать с применением запросов следующим образом: </P><PRE
CLASS="SCREEN"
>SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)</PRE
><P> Заметьте, что в последней команде <TT
CLASS="COMMAND"
>SELECT</TT
> для <TT
CLASS="LITERAL"
>Child2</TT
>, <TT
CLASS="LITERAL"
>Child3</TT
> и т. д. строки не выдаются. Это происходит потому, что <CODE
CLASS="FUNCTION"
>listchildren</CODE
> возвращает пустое множество для этих аргументов, так что строки результата не генерируются. Это же поведение мы получаем при внутреннем соединении с результатом функции с применением <TT
CLASS="LITERAL"
>LATERAL</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Если последняя команда функции — <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
> или <TT
CLASS="COMMAND"
>DELETE</TT
> с <TT
CLASS="LITERAL"
>RETURNING</TT
>, эта команда будет всегда выполняться до завершения, даже если функция не объявлена с указанием <TT
CLASS="LITERAL"
>SETOF</TT
> или вызывающий запрос не выбирает все строки результата. Все дополнительные строки, выданные предложением <TT
CLASS="LITERAL"
>RETURNING</TT
>, просто игнорируются, но соответствующие изменения в таблице всё равно произойдут (и будут завершены до выхода из функции).</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Ключевая проблема использования функций, возвращающих множества, в списке выборки, а не в предложении <TT
CLASS="LITERAL"
>FROM</TT
>, заключается в том, что при вызове в одном списке выборки нескольких таких функций, результат будет не вполне разумным. (На самом деле, если вы сделаете это, вы получите выходные строки в количестве, равном наименьшему общему кратному чисел строк, которые будут выданы всеми функциями, возвращающими множества.) Синтаксис <TT
CLASS="LITERAL"
>LATERAL</TT
> даёт более ожидаемые результаты при вызове нескольких таких функций и поэтому рекомендуется использовать его.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-SQL-FUNCTIONS-RETURNING-TABLE"
>35.4.9. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, возвращающие таблицы (<TT
CLASS="LITERAL"
>TABLE</TT
>)</A
></H2
><P
>Есть ещё один способ объявить функцию, возвращающую множества, — использовать синтаксис <TT
CLASS="LITERAL"
>RETURNS TABLE(<TT
CLASS="REPLACEABLE"
><I
>колонки</I
></TT
>)</TT
>. Это равнозначно использованию одного или нескольких параметров <TT
CLASS="LITERAL"
>OUT</TT
> с объявлением функции как возвращающей <TT
CLASS="LITERAL"
>SETOF record</TT
> (или <TT
CLASS="LITERAL"
>SETOF</TT
> тип единственного параметра, если это применимо). Этот синтаксис описан в последних версиях стандарта SQL, так что этот вариант может быть более портируемым, чем <TT
CLASS="LITERAL"
>SETOF</TT
>.</P
><P
>Например, предыдущий пример с суммой и произведением можно также переписать так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;</PRE
><P> Запись <TT
CLASS="LITERAL"
>RETURNS TABLE</TT
> не позволяет явно указывать <TT
CLASS="LITERAL"
>OUT</TT
> и <TT
CLASS="LITERAL"
>INOUT</TT
> для параметров &mdash; все выходные колонки необходимо записать в списке <TT
CLASS="LITERAL"
>TABLE</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN55160"
>35.4.10. Полиморфные функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></A
></H2
><P
>Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> могут быть объявлены как принимающие и возвращающие полиморфные типы <TT
CLASS="TYPE"
>anyelement</TT
>, <TT
CLASS="TYPE"
>anyarray</TT
>, <TT
CLASS="TYPE"
>anynonarray</TT
>, <TT
CLASS="TYPE"
>anyenum</TT
> и <TT
CLASS="TYPE"
>anyrange</TT
>. За более подробным объяснением полиморфизма функций обратитесь к <A
HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC"
>Подразделу 35.2.5</A
>. В следующем примере полиморфная функция <CODE
CLASS="FUNCTION"
>make_array</CODE
> создаёт массив из двух элементов произвольных типов: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)</PRE
><P></P
><P
>Обратите внимание на приведение типа <TT
CLASS="LITERAL"
>'a'::text</TT
>, определяющее, что аргумент имеет тип <TT
CLASS="TYPE"
>text</TT
>. Оно необходимо, если аргумент задаётся просто строковой константой, так как иначе он будет воспринят как имеющий тип <TT
CLASS="TYPE"
>unknown</TT
>, а массив типов <TT
CLASS="TYPE"
>unknown</TT
> является недопустимым. Без этого приведения вы получите такую ошибку: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>ERROR:  could not determine polymorphic type because input has type "unknown"</SAMP
></PRE
><P> (ОШИБКА:  не удалось определить полиморфный тип, так как входные аргументы имеют тип "unknown")</P
><P
>Функция с полиморфными аргументами может иметь фиксированный тип результата, однако обратное не допускается. Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A function returning a polymorphic type must have at least one polymorphic argument.</PRE
><P> (ОШИБКА: не удалось определить тип результата; ПОДРОБНОСТИ: Функция, возвращающая полиморфный тип, должна иметь минимум один полиморфный аргумент.")</P
><P
>Полиморфизм можно применять и с функциями, имеющими выходные аргументы. Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)</PRE
><P></P
><P
>Полиморфизм также можно применять с функциями с переменными параметрами. Например: </P><PRE
CLASS="SCREEN"
>CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN55186"
>35.4.11. Функции <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> с правилами сортировки</A
></H2
><P
>Когда функция SQL принимает один или несколько параметров сортируемых типов данных, правило сортировки определяется при каждом вызове функции, в зависимости от правил сортировки, связанных с фактическими аргументами, как описано в <A
HREF="collation.html"
>Разделе 22.2</A
>. Если правило сортировки определено успешно (то есть не возникло конфликтов между неявно установленными правилами сортировки аргументов), оно неявно назначается для всех сортируемых параметров. Выбранное правило будет определять поведение операций, связанных с сортировкой, в данной функции. Например, для показанной выше функции <CODE
CLASS="FUNCTION"
>anyleast</CODE
>, результат </P><PRE
CLASS="PROGRAMLISTING"
>SELECT anyleast('abc'::text, 'ABC');</PRE
><P> будет зависеть от правила сортировки по умолчанию, заданного в базе данных. С локалью <TT
CLASS="LITERAL"
>C</TT
> результатом будет строка <TT
CLASS="LITERAL"
>ABC</TT
>, но со многими другими локалями это будет <TT
CLASS="LITERAL"
>abc</TT
>. Нужное правило сортировки можно установить принудительно, добавив предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> к одному из аргументов функции, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT anyleast('abc'::text, 'ABC' COLLATE "C");</PRE
><P> С другой стороны, если вы хотите, чтобы функция работала с определённым правилом сортировки, вне зависимости от того, с каким она была вызвана, вставьте предложения <TT
CLASS="LITERAL"
>COLLATE</TT
> где требуется в определении функции. Эта версия <CODE
CLASS="FUNCTION"
>anyleast</CODE
> всегда будет сравнивать строки по правилам локали <TT
CLASS="LITERAL"
>en_US</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;</PRE
><P> Но заметьте, что при попытке применить правило к несортируемому типу данных, возникнет ошибка.</P
><P
>Если для фактических аргументов не удаётся определить общее правило сортировки, функция SQL считает, что им назначено правило сортировки по умолчанию для их типа данных (обычно это то же правило сортировки, что определено по умолчанию для базы данных, но оно может быть и другим для параметров доменных типов).</P
><P
>Поведение сортируемых параметров можно воспринимать как ограниченную форму полиморфизма, применимую только к текстовым типам данных.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xfunc-overload.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Пользовательские функции</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Перегрузка функций</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>