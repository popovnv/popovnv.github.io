<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>COPY</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="COMMIT PREPARED"
HREF="sql-commit-prepared.html"><LINK
REL="NEXT"
TITLE="CREATE AGGREGATE"
HREF="sql-createaggregate.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="COMMIT PREPARED"
HREF="sql-commit-prepared.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE AGGREGATE"
HREF="sql-createaggregate.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-COPY"
></A
>COPY</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN71615"
></A
><H2
>Название</H2
>COPY&nbsp;--&nbsp;копировать данные между файлом и таблицей</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN71618"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>COPY <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ) ]
    FROM { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | PROGRAM '<TT
CLASS="REPLACEABLE"
><I
>команда</I
></TT
>' | STDIN }
    [ [ WITH ] ( <TT
CLASS="REPLACEABLE"
><I
>параметр</I
></TT
> [, ...] ) ]

COPY { <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ) ] | ( <TT
CLASS="REPLACEABLE"
><I
>запрос</I
></TT
> ) }
    TO { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | PROGRAM '<TT
CLASS="REPLACEABLE"
><I
>команда</I
></TT
>' | STDOUT }
    [ [ WITH ] ( <TT
CLASS="REPLACEABLE"
><I
>параметр</I
></TT
> [, ...] ) ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>Здесь допускается <TT
CLASS="REPLACEABLE"
><I
>параметр</I
></TT
>:</SPAN
></SPAN
>

    FORMAT <TT
CLASS="REPLACEABLE"
><I
>имя_формата</I
></TT
>
    OIDS [ <TT
CLASS="REPLACEABLE"
><I
>boolean</I
></TT
> ]
    FREEZE [ <TT
CLASS="REPLACEABLE"
><I
>boolean</I
></TT
> ]
    DELIMITER '<TT
CLASS="REPLACEABLE"
><I
>символ_разделитель</I
></TT
>'
    NULL '<TT
CLASS="REPLACEABLE"
><I
>маркер_NULL</I
></TT
>'
    HEADER [ <TT
CLASS="REPLACEABLE"
><I
>boolean</I
></TT
> ]
    QUOTE '<TT
CLASS="REPLACEABLE"
><I
>символ_кавычек</I
></TT
>'
    ESCAPE '<TT
CLASS="REPLACEABLE"
><I
>символ_экранирования</I
></TT
>'
    FORCE_QUOTE { ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ) | * }
    FORCE_NOT_NULL ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] )
    FORCE_NULL ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] )
    ENCODING '<TT
CLASS="REPLACEABLE"
><I
>имя_кодировки</I
></TT
>'</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71645"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>COPY</TT
> перемещает данные между таблицами <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> и традиционными файлами. <TT
CLASS="COMMAND"
>COPY TO</TT
> копирует содержимое таблицы <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>в</I
></SPAN
> файл, а <TT
CLASS="COMMAND"
>COPY FROM</TT
> — <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>из</I
></SPAN
> файла в таблицу (добавляет данные к тем, что уже содержались в таблице). <TT
CLASS="COMMAND"
>COPY TO</TT
> может также скопировать результаты запроса <TT
CLASS="COMMAND"
>SELECT</TT
>.</P
><P
>Если указывается список колонок, <TT
CLASS="COMMAND"
>COPY</TT
> скопирует в или из файла только данные указанных колонок. Если в таблице есть колонки, отсутствующие в этом списке, <TT
CLASS="COMMAND"
>COPY FROM</TT
> заполнит эти колонки значениями по умолчанию.</P
><P
><TT
CLASS="COMMAND"
>COPY</TT
> с именем файла указывает серверу <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> читать или записывать непосредственно этот файл. Заданный файл должен быть доступен пользователю <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> (тому пользователю, от имени которого работает сервер) и это имя должно быть определено с точки зрения сервера. Когда указывается параметр <TT
CLASS="LITERAL"
>PROGRAM</TT
>, сервер выполняет заданную команду и читает данные из стандартного вывода программы, либо записывает их в стандартный ввод. Команда должна определяться с точки зрения сервера и быть доступной для исполнения пользователю <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Когда указывается <TT
CLASS="LITERAL"
>STDIN</TT
> или <TT
CLASS="LITERAL"
>STDOUT</TT
>, данные передаются через соединение клиента с сервером.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71667"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) существующей таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
></DT
><DD
><P
>Необязательный список колонок, данные которых будут копироваться. Если этот список отсутствует, копируются все колонки таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>запрос</I
></TT
></DT
><DD
><P
>Команда <A
HREF="sql-select.html"
>SELECT</A
> или <A
HREF="sql-values.html"
>VALUES</A
>, результаты которой будут скопированы. Заметьте, что запрос должен заключаться в скобки.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
></DT
><DD
><P
>Путь входного или выходного файла. Путь входного файла может быть абсолютным или относительным, но путь выходного должен быть только абсолютным. Пользователям Windows следует использовать формат <TT
CLASS="LITERAL"
>E''</TT
> и продублировать каждую обратную черту в пути файла.</P
></DD
><DT
><TT
CLASS="LITERAL"
>PROGRAM</TT
></DT
><DD
><P
>Выполняемая команда. <TT
CLASS="COMMAND"
>COPY FROM</TT
> читает стандартный вывод команды, а <TT
CLASS="COMMAND"
>COPY TO</TT
> записывает в её стандартный ввод.</P
><P
>Заметьте, что команда запускается через командную оболочку, так что если требуется передать этой команде какие-либо аргументы, поступающие из недоверенного источника, необходимо аккуратно избавиться от всех спецсимволов, имеющих особое значение в оболочке, либо экранировать их. По соображениям безопасности лучше ограничиться фиксированной строкой команды или как минимум не позволять пользователям вводить в неё произвольное содержимое.</P
></DD
><DT
><TT
CLASS="LITERAL"
>STDIN</TT
></DT
><DD
><P
>Указывает, что данные будут поступать из клиентского приложения.</P
></DD
><DT
><TT
CLASS="LITERAL"
>STDOUT</TT
></DT
><DD
><P
>Указывает, что данные будут выдаваться клиентскому приложению.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>boolean</I
></TT
></DT
><DD
><P
>Включает или отключает заданный параметр. Для включения параметра можно написать <TT
CLASS="LITERAL"
>TRUE</TT
>, <TT
CLASS="LITERAL"
>ON</TT
> или <TT
CLASS="LITERAL"
>1</TT
>, а для отключения — <TT
CLASS="LITERAL"
>FALSE</TT
>, <TT
CLASS="LITERAL"
>OFF</TT
> или <TT
CLASS="LITERAL"
>0</TT
>. Значение <TT
CLASS="REPLACEABLE"
><I
>boolean</I
></TT
> можно опустить, в этом случае подразумевается <TT
CLASS="LITERAL"
>TRUE</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>FORMAT</TT
></DT
><DD
><P
>Выбирает формат чтения или записи данных: <TT
CLASS="LITERAL"
>text</TT
> (текстовый), <TT
CLASS="LITERAL"
>csv</TT
> (значения, разделённые запятыми, Comma Separated Values) или <TT
CLASS="LITERAL"
>binary</TT
> (двоичный). По умолчанию выбирается формат <TT
CLASS="LITERAL"
>text</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>OIDS</TT
></DT
><DD
><P
>Копирует OID каждой строки. (Если присутствует указание <TT
CLASS="LITERAL"
>OIDS</TT
>, но таблица не содержит колонки oid, либо копируется <TT
CLASS="REPLACEABLE"
><I
>запрос</I
></TT
>, возникнет ошибка.)</P
></DD
><DT
><TT
CLASS="LITERAL"
>FREEZE</TT
></DT
><DD
><P
>Запросы копируют данные с уже замороженными строками, как после выполнения команды <TT
CLASS="COMMAND"
>VACUUM FREEZE</TT
>. Это позволяет увеличить производительность при начальном добавлении данных. Строки будут замораживаться, только если загружаемая таблица была создана или опустошена в текущей подтранзакции, с ней не связаны открытые курсоры и в данной транзакции нет других снимков.</P
><P
>Заметьте, что все другие сеансы будут немедленно видеть данные, как только они будут успешно загружены. Это нарушает принятые правила видимости MVCC, так что пользователи, включающие этот режим, должны понимать, какие проблемы это может вызвать.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DELIMITER</TT
></DT
><DD
><P
>Задаёт символ, разделяющий колонки в строках файла. По умолчанию это символ табуляции в текстовом формате и запятая в формате <TT
CLASS="LITERAL"
>CSV</TT
>. Задаваемый символ должен быть однобайтовым. Для формата <TT
CLASS="LITERAL"
>binary</TT
> этот параметр не допускается.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NULL</TT
></DT
><DD
><P
>Определяет строку, задающую значение NULL. По умолчанию в текстовом формате это <TT
CLASS="LITERAL"
>\N</TT
> (обратная косая черта и N), а в формате <TT
CLASS="LITERAL"
>CSV</TT
> — пустая строка без кавычек. Пустую строку можно использовать и в текстовом формате, если не требуется различать пустые строки и NULL. Для формата <TT
CLASS="LITERAL"
>binary</TT
> этот параметр не допускается.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>При выполнении <TT
CLASS="COMMAND"
>COPY FROM</TT
> любые значения, совпадающие с этой строкой, сохраняются как значение NULL, так что при переносе данных важно убедиться в том, что это та же строка, что применялась в <TT
CLASS="COMMAND"
>COPY TO</TT
>.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>HEADER</TT
></DT
><DD
><P
>Указывает, что файл содержит строку заголовка с именами колонок. При выводе первая строка файла будет содержать имена колонок таблицы, а при вводе первая строка просто игнорируется. Этот параметр допускается только для формата <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>QUOTE</TT
></DT
><DD
><P
>Указывает символ кавычек, используемый для заключения данных в кавычки. По умолчанию это символ двойных кавычек. Задаваемый символ должен быть однобайтовым. Этот параметр поддерживается только для формата <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ESCAPE</TT
></DT
><DD
><P
>Задаёт символ, который будет выводиться перед символом данных, совпавшим со значением <TT
CLASS="LITERAL"
>QUOTE</TT
>. По умолчанию это тот же символ, что и <TT
CLASS="LITERAL"
>QUOTE</TT
> (то есть, при появлении в данных кавычек, они дублируются). Задаваемый символ должен быть однобайтовым. Этот параметр допускается только для режима <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>FORCE_QUOTE</TT
></DT
><DD
><P
>Принудительно заключает в кавычки все значения не <TT
CLASS="LITERAL"
>NULL</TT
> в указанных колонках. Выводимое значение <TT
CLASS="LITERAL"
>NULL</TT
> никогда не заключается в кавычки. Если указано <TT
CLASS="LITERAL"
>*</TT
>, в кавычки будут заключаться значения не <TT
CLASS="LITERAL"
>NULL</TT
> во всех колонках. Этот параметр принимает только команда <TT
CLASS="COMMAND"
>COPY TO</TT
> и только для формата <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>FORCE_NOT_NULL</TT
></DT
><DD
><P
>Не сопоставлять значения в указанных колонках с маркером NULL. По умолчанию, когда маркер пуст, это означает, что пустые значения будут считаны как строки нулевой длины, а не NULL, даже когда они не заключены в кавычки. Этот параметр допускается только в команде <TT
CLASS="COMMAND"
>COPY FROM</TT
> и только для формата <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>FORCE_NULL</TT
></DT
><DD
><P
>Сопоставлять значения в указанных колонках с маркером NULL, даже если они заключены в кавычки, и в случае совпадения устанавливать значение <TT
CLASS="LITERAL"
>NULL</TT
>. По умолчанию, когда этот маркер пуст, пустая строка в кавычках будет преобразовываться в NULL. Этот параметр допускается только в команде <TT
CLASS="COMMAND"
>COPY FROM</TT
> и только для формата <TT
CLASS="LITERAL"
>CSV</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ENCODING</TT
></DT
><DD
><P
>Указывает, что файл имеет кодировку <TT
CLASS="REPLACEABLE"
><I
>имя_кодировки</I
></TT
>. Если этот параметр опущен, выбирается текущая кодировка клиента. Подробнее об этом говорится ниже, в примечаниях.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71818"
></A
><H2
>Выводимая информация</H2
><P
>В случае успешного завершения, <TT
CLASS="COMMAND"
>COPY</TT
> возвращает метку команды в виде </P><PRE
CLASS="SCREEN"
>COPY <TT
CLASS="REPLACEABLE"
><I
>число</I
></TT
></PRE
><P> Здесь <TT
CLASS="REPLACEABLE"
><I
>число</I
></TT
> — количество скопированных записей.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
><SPAN
CLASS="APPLICATION"
>psql</SPAN
> выводит эту метку, только если выполнялась не команда <TT
CLASS="LITERAL"
>COPY ... TO STDOUT</TT
> или её аналог в <SPAN
CLASS="APPLICATION"
>psql</SPAN
>, метакоманда <TT
CLASS="LITERAL"
>\copy ... to stdout</TT
>. Это сделано для того, чтобы метка команды не смешалась с данными, выведенными перед ней.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71831"
></A
><H2
>Замечания</H2
><P
><TT
CLASS="COMMAND"
>COPY</TT
> может использоваться только с обычными таблицами, но не с представлениями. Однако, при необходимости можно скопировать представление так: <TT
CLASS="LITERAL"
>COPY (SELECT * FROM <TT
CLASS="REPLACEABLE"
><I
>имя_представления</I
></TT
>) TO ...</TT
>.</P
><P
><TT
CLASS="COMMAND"
>COPY</TT
> обрабатывает только явно заданную таблицу, дочерние таблицы при копировании данных не затрагиваются. Поэтому, например <TT
CLASS="LITERAL"
>COPY <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
> TO</TT
> выводит те же данные, что и запрос <TT
CLASS="LITERAL"
>SELECT * FROM ONLY <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
></TT
>. Для выгрузки всех данных в иерархии наследования можно применить <TT
CLASS="LITERAL"
>COPY (SELECT * FROM <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
>) TO ...</TT
>.</P
><P
>В таблице, данные которой читает команда <TT
CLASS="COMMAND"
>COPY TO</TT
>, требуется иметь право на выборку данных, а в таблице, куда вставляет значения <TT
CLASS="COMMAND"
>COPY FROM</TT
>, требуется право на добавление. При этом, если в команде перечисляются избранные колонки, достаточно иметь права только для них.</P
><P
>Файлы, указанные в команде <TT
CLASS="COMMAND"
>COPY</TT
>, читаются или записываются непосредственно сервером, не клиентским приложением. Поэтому они должны располагаться на сервере или быть доступными серверу, а не клиенту. Они должны быть доступны на чтение или запись пользователю <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> (пользователю, от имени которого работает сервер), не клиенту. Аналогично, команда, указанная параметром <TT
CLASS="LITERAL"
>PROGRAM</TT
>, выполняется непосредственно сервером, а не клиентским приложением, и должна быть доступна на выполнение пользователю <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Выполнять команду <TT
CLASS="COMMAND"
>COPY</TT
> с файлом (или командой) разрешено только суперпользователям базы данных, так как она позволяет прочитать и записать любой файл, к которому имеет доступ сервер.</P
><P
>Не путайте команду <TT
CLASS="COMMAND"
>COPY</TT
> с реализованной в <SPAN
CLASS="APPLICATION"
>psql</SPAN
> метакомандой <TT
CLASS="COMMAND"
><A
HREF="app-psql.html#APP-PSQL-META-COMMANDS-COPY"
>\copy</A
></TT
>. Метакоманда <TT
CLASS="COMMAND"
>\copy</TT
> вызывает <TT
CLASS="COMMAND"
>COPY FROM STDIN</TT
> или <TT
CLASS="COMMAND"
>COPY TO STDOUT</TT
>, а затем работает с данными в файле, доступном клиенту <SPAN
CLASS="APPLICATION"
>psql</SPAN
>. Таким образом, когда применяется команда <TT
CLASS="COMMAND"
>\copy</TT
>, доступность файла и права доступа зависят от клиента, а не от сервера.</P
><P
>Путь файла, указываемый в <TT
CLASS="COMMAND"
>COPY</TT
>, рекомендуется всегда задавать как абсолютный, а не относительный. Это обязательное условие для команды <TT
CLASS="COMMAND"
>COPY TO</TT
>, но <TT
CLASS="COMMAND"
>COPY FROM</TT
> позволяет прочитать файл, заданный и относительным путём. Такой путь будет интерпретироваться относительно рабочего каталога серверного процесса (обычно это каталог данных кластера), а не рабочего каталога клиента.</P
><P
>Выполнение команды в <TT
CLASS="LITERAL"
>PROGRAM</TT
> может быть ограничено и другими работающими в ОС механизмами контроля доступа, например SELinux.</P
><P
><TT
CLASS="COMMAND"
>COPY FROM</TT
> вызывает все триггеры и обрабатывает все ограничения-проверки в целевой таблице. Однако правила при загрузке данных не вызываются.</P
><P
>При вводе и выводе данных <TT
CLASS="COMMAND"
>COPY</TT
> учитывается <TT
CLASS="VARNAME"
>DateStyle</TT
>. Для обеспечения переносимости на другие инсталляции <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, в которых могут использоваться нестандартные значения <TT
CLASS="VARNAME"
>DateStyle</TT
>, значение <TT
CLASS="VARNAME"
>DateStyle</TT
> следует установить равным <TT
CLASS="LITERAL"
>ISO</TT
> до вызова <TT
CLASS="COMMAND"
>COPY TO</TT
>. Также рекомендуется не выгружать данные с <TT
CLASS="VARNAME"
>IntervalStyle</TT
> равным <TT
CLASS="LITERAL"
>sql_standard</TT
>, так как сервер с другим значением <TT
CLASS="VARNAME"
>IntervalStyle</TT
> может неправильно воспринимать отрицательные интервалы в таких данных.</P
><P
>Входные данные интерпретируются согласно кодировке, заданной параметром <TT
CLASS="LITERAL"
>ENCODING</TT
>, или текущей кодировке клиента, а выходные кодируются в кодировке <TT
CLASS="LITERAL"
>ENCODING</TT
> или текущей кодировке клиента, даже если данные не проходят через клиента, а считываются или записываются в файл непосредственно сервером.</P
><P
><TT
CLASS="COMMAND"
>COPY</TT
> прекращает операцию при первой ошибке. Это не должно приводить к проблемам в случае с <TT
CLASS="COMMAND"
>COPY TO</TT
>, но после <TT
CLASS="COMMAND"
>COPY FROM</TT
> в целевой таблице остаются ранее полученные строки. Эти строки не будут видимыми и доступными, но будут занимать место на диске. Если сбой происходит при копировании большого объёма данных, это может приводить к значительным потерям дискового пространства. При желании вернуть потерянный объём, это можно сделать с помощью команды <TT
CLASS="COMMAND"
>VACUUM</TT
>.</P
><P
><TT
CLASS="LITERAL"
>FORCE_NULL</TT
> и <TT
CLASS="LITERAL"
>FORCE_NOT_NULL</TT
> можно применить одновременно к одной колонке. В результате NULL-значения в кавычках будут преобразованы в NULL, а NULL-значения без кавычек — в пустые строки.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71894"
></A
><H2
>Форматы файлов</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN71896"
></A
><H3
>Текстовый формат</H3
><P
>Когда применяется формат <TT
CLASS="LITERAL"
>text</TT
>, читаемые или записываемые данные представляют собой текстовый файл, строка в котором соответствует строке таблицы. Колонки в строке разделяются символом-разделителем. Значения самих колонок — строки, выдаваемые функцией вывода, либо воспринимаемые функцией ввода, соответствующей типу данных колонки. Заданный маркер NULL выводится и считывается вместо колонок со значением NULL. <TT
CLASS="COMMAND"
>COPY FROM</TT
> выдаёт ошибку, если в любой из строк во входном файле оказывается больше или меньше колонок, чем ожидается. С указанием <TT
CLASS="LITERAL"
>OIDS</TT
> значение OID считывается или записывается в первой колонке, предшествующей колонкам с основными данными.</P
><P
>Конец данных может обозначаться одной строкой, содержащей только обратную косую и точку (<TT
CLASS="LITERAL"
>\.</TT
>). Маркер конца данных не требуется при чтении из файла, так как его роль вполне выполняет конец файла; он необходим только при передаче данных в/из клиентского приложения по протоколу обмена до версии 3.0.</P
><P
>Символы обратной косой черты (<TT
CLASS="LITERAL"
>\</TT
>) в данных <TT
CLASS="COMMAND"
>COPY</TT
> позволяют экранировать символы данных, которые без них считались бы разделителями строк или колонок. В частности, предваряться обратной косой <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>должны</I
></SPAN
> следующие символы, когда они оказываются в значении колонки: сама обратная косая черта, перевод строки, возврат каретки и текущий разделитель.</P
><P
>Маркер NULL передаётся команде <TT
CLASS="COMMAND"
>COPY TO</TT
> как есть, без добавления обратной косой; <TT
CLASS="COMMAND"
>COPY FROM</TT
>, со своей стороны, ищет во вводимых данных маркеры NULL до удаления обратных косых. Таким образом, маркер NULL, например такой как <TT
CLASS="LITERAL"
>\N</TT
>, отличается от значения <TT
CLASS="LITERAL"
>\N</TT
> в данных (оно должно представляться в виде <TT
CLASS="LITERAL"
>\\N</TT
>).</P
><P
>Команда <TT
CLASS="COMMAND"
>COPY FROM</TT
> распознаёт следующие спецпоследовательности: <DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN71916"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Последовательность</TH
><TH
>Представляет</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>\b</TT
></TD
><TD
>Забой (ASCII 8)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\f</TT
></TD
><TD
>Подача формы (ASCII 12)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\n</TT
></TD
><TD
>Новая строка (ASCII 10)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\r</TT
></TD
><TD
>Возврат каретки (ASCII 13)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\t</TT
></TD
><TD
>Табуляция (ASCII 9)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\v</TT
></TD
><TD
>Вертикальная табуляция (ASCII 11)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\</TT
><TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></TD
><TD
>Обратная косая с последующими 1-3 восьмеричными цифрами представляет символ с заданным числовым кодом</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\x</TT
><TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></TD
><TD
>Обратная косая с последующим <TT
CLASS="LITERAL"
>x</TT
> и 1-2 шестнадцатеричными цифрами представляет символ с заданным числовым кодом</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
> В настоящее время <TT
CLASS="COMMAND"
>COPY TO</TT
> никогда не выводит спецпоследовательности с восьмеричными или шестнадцатеричными кодами, однако выводит другие вышеперечисленные спецпоследовательности вместо управляющих символов.</P
><P
>Любой другой символ после обратной косой, отсутствующий в приведённой выше таблице, будет представлять себя. Однако опасайтесь излишнего добавления обратных косых, так как это может привести к случайному образованию строки, обозначающей маркер конца данных (<TT
CLASS="LITERAL"
>\.</TT
>) или маркер NULL (<TT
CLASS="LITERAL"
>\N</TT
> по умолчанию). Эти строки будут восприняты прежде, чем обработаются спецпоследовательности с обратной косой.</P
><P
>В приложениях, генерирующих данные для <TT
CLASS="COMMAND"
>COPY</TT
>, настоятельно рекомендуется преобразовать символы новой строки и возврата каретки в последовательности <TT
CLASS="LITERAL"
>\n</TT
> и <TT
CLASS="LITERAL"
>\r</TT
>, соответственно. В настоящее время можно представить возврат каретки в данных как обратная косая и возврат каретки, а перевод строки как обратная косая и перевод строки, однако это может не поддерживаться в будущих версиях. Такие символы также подвержены искажениям, если файл с выводом <TT
CLASS="COMMAND"
>COPY</TT
> переносится между разными системами (например, с Unix в Windows и наоборот).</P
><P
><TT
CLASS="COMMAND"
>COPY TO</TT
> завершает каждую строку символом новой строки в стиле Unix (<SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>\n</TT
>"</SPAN
>). Серверы, работающие в Microsoft Windows, вместо этого выводят символы возврат каретки/новая строка (<SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>\r\n</TT
>"</SPAN
>), но только при выводе <TT
CLASS="COMMAND"
>COPY</TT
> в файл на сервере; для согласованности на разных платформах, <TT
CLASS="COMMAND"
>COPY TO STDOUT</TT
> всегда передаёт <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>\n</TT
>"</SPAN
>, вне зависимости от платформы сервера. <TT
CLASS="COMMAND"
>COPY FROM</TT
> может воспринимать строки, завершающиеся символами новая строка, перевод каретки, либо возврат каретки+новая строка. Чтобы уменьшить риск ошибки из-за неэкранированных символов новой строки и возврата каретки, которые должны были быть данными, <TT
CLASS="COMMAND"
>COPY FROM</TT
> сигнализирует о проблеме, если концы строк во входных данных различаются.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN71979"
></A
><H3
>Формат CSV</H3
><P
>Этот формат применяется для импорта и экспорта данных в виде списка значений, разделённых запятыми (<TT
CLASS="LITERAL"
>CSV</TT
>), с которым могут работать многие другие программы, например электронные таблицы. Вместо правил экранирования значений, введённых в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> для текстового формата, этот формат использует стандартный механизм экранирования CSV.</P
><P
>Значения в каждой записи разделяются символами <TT
CLASS="LITERAL"
>DELIMITER</TT
>. Если значение содержит символ разделителя, символ <TT
CLASS="LITERAL"
>QUOTE</TT
>, маркер <TT
CLASS="LITERAL"
>NULL</TT
>, символ возврата каретки или перевода строки, то всё значение дополнятся спереди и сзади символами <TT
CLASS="LITERAL"
>QUOTE</TT
>, а любое вхождение символа <TT
CLASS="LITERAL"
>QUOTE</TT
> или спецсимвола (<TT
CLASS="LITERAL"
>ESCAPE</TT
>) в данных предваряется спецсимволом. С указанием <TT
CLASS="LITERAL"
>FORCE_QUOTE</TT
> в кавычки будут принудительно заключаться любые значения не <TT
CLASS="LITERAL"
>NULL</TT
> в указанных колонках.</P
><P
>В формате <TT
CLASS="LITERAL"
>CSV</TT
> отсутствует стандартный способ отличить значение <TT
CLASS="LITERAL"
>NULL</TT
> от пустой строки. В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> команда <TT
CLASS="COMMAND"
>COPY</TT
> решает это с помощью кавычек. Значение <TT
CLASS="LITERAL"
>NULL</TT
> выводится в виде строки, задаваемой параметром <TT
CLASS="LITERAL"
>NULL</TT
>, и не заключается в кавычки, тогда как значение не <TT
CLASS="LITERAL"
>NULL</TT
>, со строкой, задаваемой параметром <TT
CLASS="LITERAL"
>NULL</TT
>, заключается. Например, с параметрами по умолчанию <TT
CLASS="LITERAL"
>NULL</TT
> записывается в виде пустой строки без кавычек, тогда как пустая строка записывается в двойных кавычках (<TT
CLASS="LITERAL"
>""</TT
>). При чтении значений действуют похожие правила. Указание <TT
CLASS="LITERAL"
>FORCE_NOT_NULL</TT
> позволяет избежать сравнений на <TT
CLASS="LITERAL"
>NULL</TT
> во входных данных в заданных колонках, а <TT
CLASS="LITERAL"
>FORCE_NULL</TT
> — преобразовывать в <TT
CLASS="LITERAL"
>NULL</TT
> маркеры NULL, даже заключённые в кавычки.</P
><P
>Так как обратная косая черта не является спецсимволом в формате <TT
CLASS="LITERAL"
>CSV</TT
>, маркер конца данных <TT
CLASS="LITERAL"
>\.</TT
> может быть и значением данных. Во избежание ошибок интерпретации данные <TT
CLASS="LITERAL"
>\.</TT
>, выводимые в виде единственного элемента строки, автоматически заключаются в кавычки при выводе, а при вводе этот маркер, заключённый в кавычки, не воспринимается как маркер конца данных. При загрузке файла, созданного другой программой, в котором в единственной колонке без кавычек оказалось значение <TT
CLASS="LITERAL"
>\.</TT
>, потребуется дополнительно заключить это значение в кавычки.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>В формате <TT
CLASS="LITERAL"
>CSV</TT
> все символы являются значимыми. Заключённое в кавычки значение, дополненное пробелами или любыми другими символами, кроме <TT
CLASS="LITERAL"
>DELIMITER</TT
>, будет включать и эти символы. Это может приводить к ошибкам при импорте данных из системы, дополняющей строки <TT
CLASS="LITERAL"
>CSV</TT
> пробельными символами до некоторой фиксированной ширины. В случае возникновения такой проблемы необходимо обработать файл <TT
CLASS="LITERAL"
>CSV</TT
> и удалить из него замыкающие пробельные символы, прежде чем загружать данные из него в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Обработчик формата CSV воспринимает и генерирует файлы CSV со значениями в кавычках, которые могут содержать символы возврата каретки и перевода строки. Таким образом, число строк в этих файлах не строго равно числу строк в таблице, как в файлах текстового формата.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Многие программы генерируют странные и иногда неприемлемые файлы CSV, так что этот формат используется скорее по соглашению, чем по стандарту. Поэтому вам могут встретиться файлы, которые невозможно импортировать, используя этот механизм, а <TT
CLASS="COMMAND"
>COPY</TT
> может сформировать такие файлы, что их не смогут обработать другие программы.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN72025"
></A
><H3
>Двоичный формат</H3
><P
>При выборе формата <TT
CLASS="LITERAL"
>binary</TT
> все данные сохраняются/считываются в двоичном, а не текстовом виде. Иногда этот формат обрабатывается быстрее, чем текстовый и <TT
CLASS="LITERAL"
>CSV</TT
>, но он может оказаться непереносимым между разными машинными архитектурами и версиями <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Кроме того, двоичный формат сильно зависит от типов данных; например, он не позволяет вывести данные из колонки <TT
CLASS="TYPE"
>smallint</TT
>, а затем прочитать их в колонку <TT
CLASS="TYPE"
>integer</TT
>, хотя с текстовым форматом это вполне возможно.</P
><P
>Формат <TT
CLASS="LITERAL"
>binary</TT
> включает заголовок файла, ноль или более записей, содержащих данные строк, и окончание файла. Для заголовков и данных принят сетевой порядок байт.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 7.4 использовался другой двоичный формат.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN72038"
></A
><H4
>Заголовок файла</H4
><P
>Заголовок файла содержит 15 байт фиксированных полей, за которыми следует область расширения заголовка переменной длины. Фиксированные поля: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Сигнатура</DT
><DD
><P
>Последовательность из 11 байт <TT
CLASS="LITERAL"
>PGCOPY\n\377\r\n\0</TT
> &mdash; заметьте, что нулевой байт является обязательной частью сигнатуры. (Эта сигнатура позволяет легко выявить файлы, испорченные при передаче, не сохраняющей все 8 бит данных. Она изменится при прохождении через фильтры, меняющие концы строк, отбрасывающие нулевые байты или старшие биты, либо добавляющие чётность.)</P
></DD
><DT
>Поле флагов</DT
><DD
><P
>Маска из 32 бит, обозначающая важные аспекты формата файла. Биты нумеруются от 0 (<ACRONYM
CLASS="ACRONYM"
>LSB</ACRONYM
>) до 31 (<ACRONYM
CLASS="ACRONYM"
>MSB</ACRONYM
>). Учтите, что это поле хранится в сетевом порядке байт (наиболее значащий байт первый), как и все целочисленные поля в этом формате. Биты 16-31 зарезервированы для обозначения критичных особенностей формата; обработчик должен прервать чтение, встретив любой неожиданный бит в этом диапазоне. Биты 0-15 зарезервированы для обозначения особенностей, связанных с обратной совместимостью; обработчик может просто игнорировать любые неожиданные биты в этом диапазоне. В настоящее время определён только один битовый флаг, остальные должны быть равны 0: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Бит 16</DT
><DD
><P
>При 1 в данные включается OID; при 0 — нет</P
></DD
></DL
></DIV
><P></P
></DD
><DT
>Длина области расширения заголовка</DT
><DD
><P
>Целое 32-битное число, определяющее длину в байтах остального заголовка, не включая само это значение. В настоящее время содержит 0, и сразу за ним следует первая запись. При будущих изменениях формата в заголовок могут быть добавлены дополнительные данные. Обработчик должен просто пропускать все расширенные данные заголовка, о которых ему ничего не известно.</P
></DD
></DL
></DIV
><P></P
><P
>Область расширения заголовка предусмотрена для размещения последовательности самоопределяемых блоков. Поле флагов не должно содержать указаний о том, что содержится в области расширения. Точное содержимое области расширения может быть определено в будущих версиях.</P
><P
>При таком подходе возможно как обратно-совместимое дополнение заголовка (добавить блоки расширения заголовка или установить младшие биты флагов), так и не обратно-совместимое (установить старшие биты флагов, сигнализирующие о подобном изменении, и добавить вспомогательные данные в область расширения, если это потребуется).</P
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN72064"
></A
><H4
>Записи</H4
><P
>Каждая запись начинается с 16-битного целого числа, определяющего количество полей в записи. (В настоящее время во всех записях должно быть одинаковое число записей, но так может быть не всегда.) Затем, для каждого поля в записи указывается 32-битная длина поля, за которой следует это количество байт с данными поля. (Значение длины не включает свой размер, и может быть равно нулю.) В качестве особого варианта, -1 обозначает, что в поле содержится NULL. В случае с NULL за длиной не следуют байты данных.</P
><P
>Выравнивание или какие-либо дополнительные данные между полями не вставляются.</P
><P
>В настоящее время предполагается, что все значения данных в файле двоичного формата содержатся в двоичном формате (формате под кодом 1). Возможно, в будущем расширении в заголовок будет добавлено поле, позволяющее задавать другие коды форматов для разных колонок.</P
><P
>Чтобы определить подходящий двоичный формат для фактических данных, обратитесь к исходному коду <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, в частности, к функциям <CODE
CLASS="FUNCTION"
>*send</CODE
> и <CODE
CLASS="FUNCTION"
>*recv</CODE
> для типов данных каждой колонки (обычно эти функции находятся в каталоге <TT
CLASS="FILENAME"
>src/backend/utils/adt/</TT
> в дереве исходного кода).</P
><P
>Если в файл включается OID, поле OID следует немедленно за числом, определяющим количество полей. Это поле не отличается от других ничем, кроме того, что оно не учитывается в количестве полей. В частности, для него также задаётся длина &mdash; это позволяет обрабатывать и четырёх- и восьмибайтовые OID без особых сложностей, и даже вывести OID, равный NULL, если возникнет потребность в этом.</P
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN72075"
></A
><H4
>Окончание файла</H4
><P
>Окончание файла состоит из 16-битного целого, содержащего -1. Это позволяет легко отличить его от счётчика полей в записи.</P
><P
>Обработчик, читающий файл, должен выдать ошибку, если число полей в записи не равно -1 или ожидаемому числу колонок. Это обеспечивает дополнительную проверку синхронизации данных.</P
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72079"
></A
><H2
>Примеры</H2
><P
>В следующем примере таблица передаётся клиенту с разделителем полей «вертикальная черта» (<TT
CLASS="LITERAL"
>|</TT
>): </P><PRE
CLASS="PROGRAMLISTING"
>COPY country TO STDOUT (DELIMITER '|');</PRE
><P></P
><P
>Копирование данных из файла в таблицу <TT
CLASS="LITERAL"
>country</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>COPY country FROM '/usr1/proj/bray/sql/country_data';</PRE
><P></P
><P
>Копирование в файл только данных стран, название которых начинается с 'A': </P><PRE
CLASS="PROGRAMLISTING"
>COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';</PRE
><P></P
><P
>Для копирования данных в сжатый файл можно направить вывод через внешнюю программу сжатия: </P><PRE
CLASS="PROGRAMLISTING"
>COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';</PRE
><P></P
><P
>Пример данных, подходящих для копирования в таблицу из <TT
CLASS="LITERAL"
>STDIN</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE</PRE
><P> Примечание: пробелы в каждой строке на самом деле обозначают символы табуляции.</P
><P
>Ниже приведены те же данные, но выведенные в двоичном формате. Данные показаны после обработки Unix-утилитой <TT
CLASS="COMMAND"
>od -c</TT
>. Таблица содержит три колонки; первая имеет тип <TT
CLASS="TYPE"
>char(2)</TT
>, вторая — <TT
CLASS="TYPE"
>text</TT
>, а третья — <TT
CLASS="TYPE"
>integer</TT
>. Последняя колонка во всех строках содержит NULL. </P><PRE
CLASS="PROGRAMLISTING"
>0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72100"
></A
><H2
>Совместимость</H2
><P
>Оператор <TT
CLASS="COMMAND"
>COPY</TT
> отсутствует в стандарте SQL.</P
><P
>До версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.0 использовался и по-прежнему поддерживается следующий синтаксис: </P><PRE
CLASS="SYNOPSIS"
>COPY <TT
CLASS="REPLACEABLE"
><I
>имя_таблицы</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ) ]
    FROM { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
>' ]
          [ NULL [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>маркер_null</I
></TT
>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>кавычки</I
></TT
>' ]
                [ ESCAPE [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>спецсимвол</I
></TT
>' ]
                [ FORCE NOT NULL <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ] ] ]

COPY { <TT
CLASS="REPLACEABLE"
><I
>имя_таблицы</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] ) ] | ( <TT
CLASS="REPLACEABLE"
><I
>запрос</I
></TT
> ) }
    TO { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
>' ]
          [ NULL [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>маркер_null</I
></TT
>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>кавычки</I
></TT
>' ]
                [ ESCAPE [ AS ] '<TT
CLASS="REPLACEABLE"
><I
>спецсимвол</I
></TT
>' ]
                [ FORCE QUOTE { <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ...] | * } ] ] ]</PRE
><P> Заметьте, что в этом синтаксисе ключевые слова <TT
CLASS="LITERAL"
>BINARY</TT
> и <TT
CLASS="LITERAL"
>CSV</TT
> обрабатываются как независимые, а не как аргументы параметра <TT
CLASS="LITERAL"
>FORMAT</TT
>.</P
><P
>До версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3 использовался и по-прежнему поддерживается следующий синтаксис: </P><PRE
CLASS="SYNOPSIS"
>COPY [ BINARY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ WITH OIDS ]
    FROM { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | STDIN }
    [ [USING] DELIMITERS '<TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
>' ]
    [ WITH NULL AS '<TT
CLASS="REPLACEABLE"
><I
>маркер_null</I
></TT
>' ]

COPY [ BINARY ] <TT
CLASS="REPLACEABLE"
><I
>имя_таблицы</I
></TT
> [ WITH OIDS ]
    TO { '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>' | STDOUT }
    [ [USING] DELIMITERS '<TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
>' ]
    [ WITH NULL AS '<TT
CLASS="REPLACEABLE"
><I
>маркер_null</I
></TT
>' ]</PRE
><P></P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commit-prepared.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createaggregate.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>COMMIT PREPARED</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE AGGREGATE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>