<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE CAST</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE AGGREGATE"
HREF="sql-createaggregate.html"><LINK
REL="NEXT"
TITLE="CREATE COLLATION"
HREF="sql-createcollation.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE AGGREGATE"
HREF="sql-createaggregate.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE COLLATION"
HREF="sql-createcollation.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATECAST"
></A
>CREATE CAST</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN72441"
></A
><H2
>Название</H2
>CREATE CAST&nbsp;--&nbsp;создать приведение</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN72444"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>CREATE CAST (<TT
CLASS="REPLACEABLE"
><I
>исходный_тип</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>целевой_тип</I
></TT
>)
    WITH FUNCTION <TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>тип_аргумента</I
></TT
> [, ...])
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<TT
CLASS="REPLACEABLE"
><I
>исходный_тип</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>целевой_тип</I
></TT
>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<TT
CLASS="REPLACEABLE"
><I
>исходный_тип</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>целевой_тип</I
></TT
>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATECAST-DESCRIPTION"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>CREATE CAST</TT
> создаёт новое приведение. Приведение определяет, как выполнить преобразование из одного типа в другой. Например, </P><PRE
CLASS="PROGRAMLISTING"
>SELECT CAST(42 AS float8);</PRE
><P> преобразует целочисленную константу 42 к типу <TT
CLASS="TYPE"
>float8</TT
>, вызывая ранее определённую функцию, в данном случае <TT
CLASS="LITERAL"
>float8(int4)</TT
>. (Если подходящее приведение не определено, возникнет ошибка преобразования.)</P
><P
>Два типа могут быть <I
CLASS="FIRSTTERM"
>двоично-сводимыми</I
>; это означает, что преобразование может быть выполнено <SPAN
CLASS="QUOTE"
>"бесплатно"</SPAN
>, без вызова какой-либо функции. Для этого требуется, чтобы соответствующие значения имели одинаковое внутреннее представление. Например, типы <TT
CLASS="TYPE"
>text</TT
> и <TT
CLASS="TYPE"
>varchar</TT
> двоично-сводимые в обе стороны. Отношение двоичной сводимости не обязательно симметрично. Например, приведение типа <TT
CLASS="TYPE"
>xml</TT
> к типу <TT
CLASS="TYPE"
>text</TT
> в текущей реализации можно выполнить бесплатно, но для преобразования в обратном направлении требуется функция, выполняющая как минимум синтаксическую проверку. (Два типа, двоично-сводимые в обе стороны, также называются двоично-совместимыми.)</P
><P
>Приведение можно определить как <I
CLASS="FIRSTTERM"
>преобразование ввода/вывода</I
>, используя указание <TT
CLASS="LITERAL"
>WITH INOUT</TT
>. В этом случае для приведения одного типа к другому вызывается функция вывода исходного типа данных, а выданная ей строка передаётся функции ввода целевого типа. Во многих случаях эта возможность избавляет от необходимости писать для преобразования всех типов отдельные функции приведения. Преобразование ввода/вывода работает так же, как и обычное приведение с функцией; отличается только реализация.</P
><P
>По умолчанию, приведение можно вызвать, только записав его явно, то есть применив конструкцию <TT
CLASS="LITERAL"
>CAST(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
>)</TT
> или <TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
><TT
CLASS="LITERAL"
>::</TT
><TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
>.</P
><P
>Если приведение помечено <TT
CLASS="LITERAL"
>AS ASSIGNMENT</TT
>, его можно вызывать неявно, присваивая значение колонке с целевым типом данных. Например, если <TT
CLASS="LITERAL"
>foo.f1</TT
> — колонка типа <TT
CLASS="TYPE"
>text</TT
>, то команда: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO foo (f1) VALUES (42);</PRE
><P> будет допустимой, если приведение типа <TT
CLASS="TYPE"
>integer</TT
> к <TT
CLASS="TYPE"
>text</TT
> помечено <TT
CLASS="LITERAL"
>AS ASSIGNMENT</TT
>, и не будет в противном случае. (Для описания такого типа приведений мы обычно используем термин <I
CLASS="FIRSTTERM"
>приведение присваивания</I
>.)</P
><P
>Если приведение помечено <TT
CLASS="LITERAL"
>AS IMPLICIT</TT
>, оно будет вызываться неявно в любом контексте, будь то присваивание или внутреннее преобразование в выражении. (Обычно мы называет приведение такого типа <I
CLASS="FIRSTTERM"
>неявным приведением</I
>.) Например, рассмотрите этот запрос: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 2 + 4.0;</PRE
><P> При разборе запроса константам сначала назначаются типы <TT
CLASS="TYPE"
>integer</TT
> и <TT
CLASS="TYPE"
>numeric</TT
>. Однако в системных каталогах нет оператора <TT
CLASS="TYPE"
>integer</TT
>
   <TT
CLASS="LITERAL"
>+</TT
> <TT
CLASS="TYPE"
>numeric</TT
>, хотя есть оператор <TT
CLASS="TYPE"
>numeric</TT
> <TT
CLASS="LITERAL"
>+</TT
> <TT
CLASS="TYPE"
>numeric</TT
>. Таким образом, запрос выполнится успешно, если существует преобразование типа <TT
CLASS="TYPE"
>integer</TT
> к <TT
CLASS="TYPE"
>numeric</TT
> с пометкой <TT
CLASS="LITERAL"
>AS IMPLICIT</TT
> &mdash; и на самом деле это так. Анализатор запроса применит неявное приведение и запрос будет обработан, как если бы он был записан в виде </P><PRE
CLASS="PROGRAMLISTING"
>SELECT CAST ( 2 AS numeric ) + 4.0;</PRE
><P></P
><P
>Системные каталоги также содержат приведение типа <TT
CLASS="TYPE"
>numeric</TT
> к <TT
CLASS="TYPE"
>integer</TT
>. Если бы это приведение тоже было бы помечено <TT
CLASS="LITERAL"
>AS IMPLICIT</TT
> (на самом деле это не так), анализатору запроса пришлось бы выбирать между предыдущим вариантом и приведением константы <TT
CLASS="TYPE"
>numeric</TT
> к типу <TT
CLASS="TYPE"
>integer</TT
> с последующим применением оператора <TT
CLASS="TYPE"
>integer</TT
> <TT
CLASS="LITERAL"
>+</TT
> <TT
CLASS="TYPE"
>integer</TT
>. Не имея возможности выбрать лучший вариант, анализатор бы не смог разрешить запрос и объявил бы его неоднозначным. Именно благодаря тому, что только одно из двух приведений сделано неявным, анализатор приходит к пониманию, что предпочитаемым является преобразование выражения <TT
CLASS="TYPE"
>numeric</TT
>-и-<TT
CLASS="TYPE"
>integer</TT
> в <TT
CLASS="TYPE"
>numeric</TT
>; отдельного встроенного знания об этом нет.</P
><P
>Определяя, объявлять ли приведения неявными, разумно проявлять консерватизм. При чрезмерном количестве способов неявного приведения <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может выбирать неожиданные интерпретации команд, или вовсе не сможет выполнить команды из-за наличия множества возможных интерпретаций. Как правило, следует делать приведение неявно вызываемым только для преобразований, сохраняющих информацию, между типами в одной общей категории типов. Например, приведение <TT
CLASS="TYPE"
>int2</TT
> к <TT
CLASS="TYPE"
>int4</TT
> разумно сделать неявным, но приведение <TT
CLASS="TYPE"
>float8</TT
> к <TT
CLASS="TYPE"
>int4</TT
>, возможно, лучше сделать только приведением присваивания. Приведения типов разных категорий, например, <TT
CLASS="TYPE"
>text</TT
> к <TT
CLASS="TYPE"
>int4</TT
>, лучше делать только явными.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Иногда ради удобства или соответствия стандартам требуется ввести множество неявных преобразований для нескольких типов, что приводит к неизбежной неоднозначности. Чтобы анализатор запроса мог обеспечить желаемое поведение в таких случаях, он дополнительно принимает во внимание <I
CLASS="FIRSTTERM"
>категории типов</I
> и <I
CLASS="FIRSTTERM"
>предпочитаемые типы</I
>. Подробнее это описано в <A
HREF="sql-createtype.html"
>CREATE TYPE</A
>.</P
></BLOCKQUOTE
></DIV
><P
>Чтобы создать приведение, необходимо быть владельцем одного (исходного или целевого) типа и иметь право <TT
CLASS="LITERAL"
>USAGE</TT
> для другого типа. Создать двоично-сводимое приведение могут только суперпользователи. (Это ограничение введено потому, что преобразование данных с ошибочным двоичным сведением может легко вызывать сбой сервера.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72530"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>исходный_тип</I
></TT
></DT
><DD
><P
>Имя исходного типа данных для приведения.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>целевой_тип</I
></TT
></DT
><DD
><P
>Имя целевого типа данных для приведения.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_функции</I
></TT
>(<TT
CLASS="REPLACEABLE"
><I
>тип_аргумента</I
></TT
> [, ...])</DT
><DD
><P
>Функция, вызываемая для выполнения приведения. Имя функции может быть дополнено схемой, в противном случае для поиска функции просматривается путь поиска. Тип данных результата должен соответствовать целевому типу приведения. Аргументы функции рассматриваются ниже.</P
></DD
><DT
><TT
CLASS="LITERAL"
>WITHOUT FUNCTION</TT
></DT
><DD
><P
>Обозначает, что исходный тип сводится к целевому на двоичном уровне, так что функция для приведения не требуется.</P
></DD
><DT
><TT
CLASS="LITERAL"
>WITH INOUT</TT
></DT
><DD
><P
>Обозначает, что приведение выполняется как преобразование ввода/вывода, то есть вызывается функция вывода исходного типа данных, а её результат-строка передаётся функции ввода целевого типа.</P
></DD
><DT
><TT
CLASS="LITERAL"
>AS ASSIGNMENT</TT
></DT
><DD
><P
>Обозначает, что приведение может вызываться неявно в контексте присваивания.</P
></DD
><DT
><TT
CLASS="LITERAL"
>AS IMPLICIT</TT
></DT
><DD
><P
>Обозначает, что приведение может вызываться неявно в любом контексте.</P
></DD
></DL
></DIV
><P
>Функции, реализующие приведение, могут иметь от одного до трёх аргументов. Тип первого аргумента должен быть идентичен или двоично-сводимым к исходному типу приведения. Второй аргумент, если он есть, должен иметь тип <TT
CLASS="TYPE"
>integer</TT
>; в нём передаётся модификатор типа, связанный с целевым типом, или <TT
CLASS="LITERAL"
>-1</TT
>, если он отсутствует. Третий аргумент, если он есть, должен иметь тип <TT
CLASS="TYPE"
>boolean</TT
>; в нём передаётся <TT
CLASS="LITERAL"
>true</TT
>, если приведение выполняется явно, либо <TT
CLASS="LITERAL"
>false</TT
> в противном случае. (Это довольно экстравагантно, но стандарт SQL предусматривает разное поведение для явного и неявного приведения в некоторых случаях. Этот аргумент предназначен для функций, которые должны реализовывать такие приведения. Однако создавать собственные типы данных, для которых это имело бы значение, не рекомендуется.)</P
><P
>Возвращаемый тип функции приведения должен быть идентичным или двоично-сводимым к целевому типу приведения.</P
><P
>Обычно исходный и целевой типы в приведении различаются, однако можно объявить приведение одного типа к такому же, если функция, реализующая преобразование, имеет более одного аргумента. Это используется для представления в системных каталогах функций, сводящих разные длины типов. Реализующая такое приведение функция будет сводить значение типа к значению с определённым модификатором, заданному вторым аргументом.</P
><P
>Когда исходный и целевой типы приведения различаются и функция принимает более одного аргумента, преобразование типа из одного в другой и сведение к нужной длине может выполняться за один шаг. Если же соответствующей записи не находится, приведение к типу с определённым модификатором выполняется в два этапа: сначала выполняется преобразование типа, а затем применяется модификатор типа.</P
><P
>Приведение типа домена или к типу домена в настоящее время не осуществляется. При попытке выполнить такое приведение вместо него выполняется приведение, связанное с базовым типом домена.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATECAST-NOTES"
></A
><H2
>Замечания</H2
><P
>Для удаления приведений, созданных пользователем, применяется <A
HREF="sql-dropcast.html"
>DROP CAST</A
>.</P
><P
>Помните, что когда требуется преобразовывать типы в обе стороны, необходимо явно описать два приведения.</P
><P
>Обычно не требуется создавать приведения между пользовательскими типами и стандартными строковыми типами (<TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>varchar</TT
> и <TT
CLASS="TYPE"
>char(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>, а также пользовательскими типами, относящимися к категории строковых). Для них <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> предоставляет автоматическое преобразование ввода/вывода. Автоматические приведения к строковым типам считаются приведениями присваивания, а автоматические приведения строковых типов к другим могут быть только явными. Это поведение можно переопределить, создав собственное приведение, заменяющее автоматическое, но обычно это нужно, только чтобы сделать вызов более удобным, чем стандартное только присваивание или явное указание. Возможен и другой повод для такого переопределения — желание создать приведение, работающее не так, как функция ввода/вывода типа; но это настолько удивительно, что следует дважды подумать, хороша ли эта идея. (На самом деле у небольшого количества встроенных типов имеются подобные специфические приведения, в основном из-за требований стандарта SQL.)</P
><P
>Хотя это и не обязательно, но рекомендуется следовать старому соглашению называть функции, реализующие приведение, по целевому типу данных. Многие привыкли выполнять преобразование типов данных, записывая его в стиле функций, т. е. <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
>(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>). Эта запись на самом деле ни больше ни меньше как просто вызов функции, реализующей приведение; такой вызов не воспринимается как именно приведение. Если называть функции, не следуя этому соглашению, это может оказаться неожиданным для пользователей. Так как <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет перегружать одно и то же имя функции с разными типами аргументов, ничто не мешает создать множество функций приведения разных типов к одному, названных по имени этого целевого типа.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Вообще говоря, в предыдущем абзаце допущено некоторое упрощение: есть два случая, когда конструкция с вызовом функции исполняется как приведение, без сопоставления с фактической функцией. Если вызову функции <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
>(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>) в точности не соответствует существующая функция, но имеется тип данных <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> и в <TT
CLASS="STRUCTNAME"
>pg_cast</TT
> есть двоично-сводимое приведение типа <TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
> к этому типу, такой вызов будет воспринят как приведение. Это исключение введено, чтобы двоично-сводимое приведение можно было вызывать, используя синтаксис функций, несмотря на то, что никакой функции преобразования у него нет. Аналогично, если запись приведения в <TT
CLASS="STRUCTNAME"
>pg_cast</TT
> отсутствует, но в случае приведения это было бы преобразование в/из строкового типа, такой вызов будет выполнен как преобразование ввода/вывода. Это исключение позволяет вызывать преобразование ввода/вывода, используя синтаксис вызова функции.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Но есть исключение и из этого исключения: преобразование ввода/вывода из составных типов в строковые нельзя вызвать в виде функции, его необходимо записать как явное приведение (используя <TT
CLASS="LITERAL"
>CAST</TT
> или запись <TT
CLASS="LITERAL"
>::</TT
>). Это исключение было добавлено, потому что после введения автоматически предоставляемых преобразований ввода/вывода, оказалось слишком легко случайно вызвать такое приведение, тогда как имелась в виду ссылка на колонку или функцию.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATECAST-EXAMPLES"
></A
><H2
>Примеры</H2
><P
>Создание приведения присваивания типа <TT
CLASS="TYPE"
>bigint</TT
> к типу <TT
CLASS="TYPE"
>int4</TT
> с помощью функции <TT
CLASS="LITERAL"
>int4(bigint)</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;</PRE
><P> (Это приведение уже предопределено в системе.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATECAST-COMPAT"
></A
><H2
>Совместимость</H2
><P
>Команда <TT
CLASS="COMMAND"
>CREATE CAST</TT
> соответствует стандарту <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, за исключением того, что в стандарте ничего не говорится о двоично-сводимых типах и дополнительных аргументах реализующих функций. Указание <TT
CLASS="LITERAL"
>AS IMPLICIT</TT
> тоже является расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATECAST-SEEALSO"
></A
><H2
>См. также</H2
><P
><A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>, <A
HREF="sql-createtype.html"
>CREATE TYPE</A
>, <A
HREF="sql-dropcast.html"
>DROP CAST</A
></P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createaggregate.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createcollation.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE AGGREGATE</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE COLLATION</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>