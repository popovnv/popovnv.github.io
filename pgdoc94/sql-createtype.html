<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE TYPE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"><LINK
REL="NEXT"
TITLE="CREATE USER"
HREF="sql-createuser.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE USER"
HREF="sql-createuser.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATETYPE"
></A
>CREATE TYPE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN77263"
></A
><H2
>Название</H2
>CREATE TYPE&nbsp;--&nbsp;создать новый тип данных</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN77266"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> AS
    ( [ <TT
CLASS="REPLACEABLE"
><I
>имя_атрибута</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ] [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> AS ENUM
    ( [ '<TT
CLASS="REPLACEABLE"
><I
>метка</I
></TT
>' [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> AS RANGE (
    SUBTYPE = <TT
CLASS="REPLACEABLE"
><I
>подтип</I
></TT
>
    [ , SUBTYPE_OPCLASS = <TT
CLASS="REPLACEABLE"
><I
>класс_оператора_подтипа</I
></TT
> ]
    [ , COLLATION = <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ]
    [ , CANONICAL = <TT
CLASS="REPLACEABLE"
><I
>каноническая_функция</I
></TT
> ]
    [ , SUBTYPE_DIFF = <TT
CLASS="REPLACEABLE"
><I
>функция_разницы_подтипа</I
></TT
> ]
)

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> (
    INPUT = <TT
CLASS="REPLACEABLE"
><I
>функция_ввода</I
></TT
>,
    OUTPUT = <TT
CLASS="REPLACEABLE"
><I
>функция_вывода</I
></TT
>
    [ , RECEIVE = <TT
CLASS="REPLACEABLE"
><I
>функция_получения</I
></TT
> ]
    [ , SEND = <TT
CLASS="REPLACEABLE"
><I
>функция_отправки</I
></TT
> ]
    [ , TYPMOD_IN = <TT
CLASS="REPLACEABLE"
><I
>функция_ввода_модификатора_типа</I
></TT
> ]
    [ , TYPMOD_OUT = <TT
CLASS="REPLACEABLE"
><I
>функция_вывода_модификатора_типа</I
></TT
> ]
    [ , ANALYZE = <TT
CLASS="REPLACEABLE"
><I
>функция_анализа</I
></TT
> ]
    [ , INTERNALLENGTH = { <TT
CLASS="REPLACEABLE"
><I
>внутр_длина</I
></TT
> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <TT
CLASS="REPLACEABLE"
><I
>выравнивание</I
></TT
> ]
    [ , STORAGE = <TT
CLASS="REPLACEABLE"
><I
>хранение</I
></TT
> ]
    [ , LIKE = <TT
CLASS="REPLACEABLE"
><I
>тип_образец</I
></TT
> ]
    [ , CATEGORY = <TT
CLASS="REPLACEABLE"
><I
>категория</I
></TT
> ]
    [ , PREFERRED = <TT
CLASS="REPLACEABLE"
><I
>предпочитаемый</I
></TT
> ]
    [ , DEFAULT = <TT
CLASS="REPLACEABLE"
><I
>по_умолчанию</I
></TT
> ]
    [ , ELEMENT = <TT
CLASS="REPLACEABLE"
><I
>элемент</I
></TT
> ]
    [ , DELIMITER = <TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
> ]
    [ , COLLATABLE = <TT
CLASS="REPLACEABLE"
><I
>сортируемый</I
></TT
> ]
)

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN77299"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
> регистрирует новый тип данных для использования в текущей базе данных. Владельцем типа становится создавший его пользователь.</P
><P
>Если указано имя схемы, тип создаётся в указанной схеме. В противном случае, он создаётся в текущей схеме. Имя типа должно отличаться от имён любых других существующих типов или доменов в той же схеме. (А так как с таблицами связываются типы данных, имя типа должно также отличаться и от имён существующих таблиц в этой схеме.)</P
><P
>Команда <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> имеет пять форм, показанных выше в сводке синтаксиса. Они создают соответственно <I
CLASS="FIRSTTERM"
>составной тип</I
>, <I
CLASS="FIRSTTERM"
>перечисление</I
>, <I
CLASS="FIRSTTERM"
>диапазон</I
>, <I
CLASS="FIRSTTERM"
>базовый тип</I
> или <I
CLASS="FIRSTTERM"
>тип-пустышку</I
>. Первые четыре эти типа рассматриваются по порядку ниже. Тип-пустышка представляет собой просто заготовку для типа, который будет определён позже; он создаётся командой <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> с одним именем, без параметров. Типы-пустышки необходимы для определения прямых ссылок при создании базовых типов и типов-диапазонов, как описывается в соответствующих разделах.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN77312"
></A
><H3
>Составные типы</H3
><P
>Первая форма <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> создаёт составной тип. Составной тип задаётся списком имён и типами данных атрибутов. Если тип данных является сортируемым, то для атрибута можно также задать правило сортировки. Составной тип по сути не отличается от типа строки таблицы, но <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> избавляет от необходимости создавать таблицу, когда всё, что нужно, это создать тип. Отдельный составной тип может быть полезен, например, для передачи аргументов или результатов функции.</P
><P
>Чтобы создать составной тип, необходимо иметь право <TT
CLASS="LITERAL"
>USAGE</TT
> для типов всех его атрибутов.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETYPE-ENUM"
></A
><H3
>Типы перечислений</H3
><P
>Вторая форма <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> создаёт тип-перечисление (такие типы описываются в <A
HREF="datatype-enum.html"
>Разделе 8.7</A
>). Перечисления принимают список из одной или нескольких меток в кавычках, каждая не длиннее <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
> байт (64 байта в стандартной сборке <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>).</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETYPE-RANGE"
></A
><H3
>Диапазонные типы</H3
><P
>Третья форма <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> создаёт тип-диапазон (такие типы описываются в <A
HREF="rangetypes.html"
>Разделе 8.17</A
>).</P
><P
>Задаваемый для диапазона <TT
CLASS="REPLACEABLE"
><I
>подтип</I
></TT
> может быть любым типом со связанным классом операторов B-дерева (что позволяет определить порядок значений в диапазоне). Обычно порядок элементов определяет класс операторов B-дерева по умолчанию, но его можно изменить, задав имя другого класса в параметре <TT
CLASS="REPLACEABLE"
><I
>класс_операторов_подтипа</I
></TT
>. Если подтип поддерживает сортировку и требуется, чтобы значения упорядочивались с нестандартным правилом сортировки, его имя можно задать в параметре <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
>.</P
><P
>Необязательная <TT
CLASS="REPLACEABLE"
><I
>каноническая_функция</I
></TT
> должна принимать один аргумент определяемого типа диапазона и возвращать значение того же типа. Это используется для преобразования значений диапазона в каноническую форму, когда это уместно. За дополнительными сведениями обратитесь к <A
HREF="rangetypes.html#RANGETYPES-DEFINING"
>Подразделу 8.17.8</A
>. Создаётся <TT
CLASS="REPLACEABLE"
><I
>каноническая_функция</I
></TT
> несколько нетривиально, так как она должна быть уже определена, прежде чем можно будет объявить тип-диапазон. Для этого нужно сначала создать тип-пустышку, который будет заготовкой типа, не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, выполнив команду <TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></TT
> без дополнительных параметров. Затем можно объявить функцию, для которой тип-пустышка будет типом аргумента и результата, и, наконец, объявить тип-диапазон с тем же именем. При этом тип-пустышка автоматически заменится полноценным типом-диапазоном.</P
><P
>Необязательная <TT
CLASS="REPLACEABLE"
><I
>функция_разницы_подтипа</I
></TT
> должна принимать в аргументах два значения типа <TT
CLASS="REPLACEABLE"
><I
>подтип</I
></TT
> и возвращать значение <TT
CLASS="TYPE"
>double precision</TT
>, представляющее разницу между двумя данными значениями. Хотя эту функцию можно не использовать, она позволяет кардинально увеличить эффективность индексов GiST для колонок с типом-диапазоном. За дополнительными сведениями обратитесь к <A
HREF="rangetypes.html#RANGETYPES-DEFINING"
>Подразделу 8.17.8</A
>.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN77346"
></A
><H3
>Базовые типы</H3
><P
>Четвёртая форма <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> создаёт новый базовый тип (скалярный тип). Чтобы создать новый базовый тип, нужно быть суперпользователем. (Это ограничение введено потому, что ошибочное определение типа может вызвать нарушения или даже сбой в работе сервера.)</P
><P
>Эти параметры могут перечисляться в любом порядке, не только в показанном выше, и большинство из них необязательные. Прежде чем создавать тип, необходимо зарегистрировать две или более функций (с помощью <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>). Обязательными являются функции <TT
CLASS="REPLACEABLE"
><I
>функция_ввода</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>функция_вывода</I
></TT
>, тогда как <TT
CLASS="REPLACEABLE"
><I
>функция_получения</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>функция_отправки</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>функция_модификатора_типа</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>функция_вывода_модификатора_типа</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>функция_анализа</I
></TT
> могут отсутствовать. Обычно эти функции разрабатываются на C или другом низкоуровневом языке.</P
><P
><TT
CLASS="REPLACEABLE"
><I
>Функция_ввода</I
></TT
> преобразует внешнее текстовое представление типа во внутреннее, с которым работают операторы и функции, определённые для этого типа. <TT
CLASS="REPLACEABLE"
><I
>Функция_вывода</I
></TT
> выполняет обратное преобразование. Функцию ввода можно объявить как принимающую один аргумент типа <TT
CLASS="TYPE"
>cstring</TT
>, либо как принимающую три аргумента типов <TT
CLASS="TYPE"
>cstring</TT
>, <TT
CLASS="TYPE"
>oid</TT
> и <TT
CLASS="TYPE"
>integer</TT
>. В первом аргументе передаётся вводимый текст в виде строки в стиле C, во втором аргументе — собственный OID типа (кроме типов массивов, для которых передаётся OID типа элемента), а в третьем — <TT
CLASS="LITERAL"
>модификатор_типа</TT
> для целевой колонки, если он определён (или -1 в противном случае). Функция ввода должна возвращать значение нового типа данных. Обычно функция ввода должна быть строгой (STRICT); если это не так, при получении на вход значения NULL она будет вызываться с первым параметром NULL. Функция может в этом случае сама вернуть NULL или вызвать ошибку. (Это полезно в основном для поддержки функций ввода доменных типов, которые не должны принимать данные NULL.) Функция вывода должна принимать один аргумент нового типа данных, а возвращать она должна <TT
CLASS="TYPE"
>cstring</TT
>. Для значений NULL функции вывода не вызываются.</P
><P
>Необязательная <TT
CLASS="REPLACEABLE"
><I
>функция_получения</I
></TT
> преобразует двоичное внешнее представление типа во внутреннее представление. Если эта функция отсутствует, новый тип не сможет участвовать в двоичном вводе. Двоичное представление следует выбирать таким, чтобы оно легко переводилось во внутреннюю форму и при этом было переносимым до разумной степени. (Например, для стандартных целочисленных типов данных во внешнем двоичном представлении выбран сетевой порядок байтов, тогда как внутреннее представление определяется порядком байтов в процессоре.) Функция получения должна выполнить проверку вводимого значения на допустимость. Функция получения может быть объявлена как принимающая один аргумент типа <TT
CLASS="TYPE"
>internal</TT
>, либо как принимающая три аргумента типов <TT
CLASS="TYPE"
>internal</TT
>, <TT
CLASS="TYPE"
>oid</TT
> и <TT
CLASS="TYPE"
>integer</TT
>. В первом аргументе передаётся указатель на буфер <TT
CLASS="TYPE"
>StringInfo</TT
>, содержащий полученную байтовую строку, а дополнительные аргументы такие же, как и для функции ввода текста. Функция получения должна возвращать значение нового типа данных. Обычно функция получения должна быть строгой (STRICT); если это не так, при получении на вход значения NULL, она будет вызываться с первым параметром NULL. Функция может в этом случае сама вернуть NULL или вызывать ошибку. (Это полезно в основном для поддержки функций получения доменных типов, которые не должны принимать значения NULL.) Подобным образом, необязательная <TT
CLASS="REPLACEABLE"
><I
>функция_отправки</I
></TT
> преобразует данные из внутреннего во внешнее двоичное представление. Если эта функция не определена, новый тип не может участвовать в двоичном выводе. Функция отправки должна принимать один аргумент нового типа данных, а возвращать она должна <TT
CLASS="TYPE"
>bytea</TT
>. Для значений NULL функции отправки не вызываются.</P
><P
>Здесь у вас может возникнуть вопрос, как функции ввода и вывода могут быть объявлены принимающими или возвращающими значения нового типа, если они должны быть созданы до объявления нового типа. Ответ довольно прост: сначала нужно создать <I
CLASS="FIRSTTERM"
>тип-пустышку</I
>, который будет заготовкой типа, не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, выполнив команду <TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></TT
> без дополнительных параметров. Затем можно будет определить функции ввода/вывода, ссылающиеся на этот тип. И наконец, команда <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> с полным определением заменит тип-пустышку окончательным и полноценным определением, после чего новый тип можно будет использовать как обычно.</P
><P
>Необязательные <TT
CLASS="REPLACEABLE"
><I
>функция_ввода_модификатора_типа</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>функция_вывода_модификатора_типа</I
></TT
> требуются, только если типы поддерживают модификаторы, или, другими словами, дополнительные ограничения, связываемые с объявлением типа, например <TT
CLASS="LITERAL"
>char(5)</TT
> или <TT
CLASS="LITERAL"
>numeric(30,2)</TT
>. В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> типы могут принимать в качестве модификаторов одну или несколько простых констант или идентификаторов. Однако эти данные должны упаковываться в единственное неотрицательное целочисленное значение, которое и будет храниться в системных каталогах. <TT
CLASS="REPLACEABLE"
><I
>Функция_ввода_модификатора_типа</I
></TT
> получает объявленные модификаторы в виде строки <TT
CLASS="TYPE"
>cstring</TT
>. Она должна проверить значения на допустимость (и вызвать ошибку, если они неверны), а затем выдать неотрицательное значение <TT
CLASS="TYPE"
>integer</TT
>, которое будет сохранено в колонке <SPAN
CLASS="QUOTE"
>"typmod"</SPAN
>. Если для типа не определена <TT
CLASS="REPLACEABLE"
><I
>функция_ввода_модификатора_типа</I
></TT
>, модификаторы типа приниматься не будут. <TT
CLASS="REPLACEABLE"
><I
>Функция_вывода_модификатора_типа</I
></TT
> преобразует внутреннее целочисленное значение typmod обратно, в форму, понятную пользователю. Она должна вернуть значение <TT
CLASS="TYPE"
>cstring</TT
>, которое именно в этом виде будет добавлено к имени типа; например, функция для <TT
CLASS="TYPE"
>numeric</TT
> должна вернуть <TT
CLASS="LITERAL"
>(30,2)</TT
>. <TT
CLASS="REPLACEABLE"
><I
>Функция_вывода_модификатора_типа</I
></TT
> может быть опущена, в этом случае сохранённое целочисленное значение typmod по умолчанию будет выводиться просто в виде числа, заключённого в скобки.</P
><P
>Необязательная <TT
CLASS="REPLACEABLE"
><I
>функция_анализа</I
></TT
> выполняет сбор специфической для этого типа статистики в колонках с таким типом данных. По умолчанию <TT
CLASS="COMMAND"
>ANALYZE</TT
> пытается собрать статистику, используя операторы <SPAN
CLASS="QUOTE"
>"равно"</SPAN
> и <SPAN
CLASS="QUOTE"
>"меньше"</SPAN
>, если для этого типа определён класс операторов B-дерева по умолчанию. Для нескалярных типов это поведение скорее всего не подойдёт, поэтому его можно переопределить, задав собственную функцию анализа. Эта функция должна принимать единственный аргумент типа <TT
CLASS="TYPE"
>internal</TT
> и возвращать результат <TT
CLASS="TYPE"
>boolean</TT
>. Более глубоко API функций анализа описан в <TT
CLASS="FILENAME"
>src/include/commands/vacuum.h</TT
>.</P
><P
>Если особенности внутреннего представления нового типа известны функциям ввода/вывода и другим функциям, созданным специально для работы с этим типом, необходимо определить ряд характеристик внутреннего представления, о которых должен знать <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. В первую очередь это <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
> (внутренняя длина). Если базовый тип данных имеет фиксированную длину, в <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
> указывается эта длина в виде положительного числа, а если длина переменная, в <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
> задаётся значение <TT
CLASS="LITERAL"
>VARIABLE</TT
>. (Внутри при этом <TT
CLASS="LITERAL"
>typlen</TT
> принимает значение -1.) Внутреннее представление всех типов переменной длины должно начинаться с 4-байтового целого, задающего общую длину значения этого типа.</P
><P
>Необязательный флаг <TT
CLASS="LITERAL"
>PASSEDBYVALUE</TT
> указывает, что значения этого типа данных передаются по значению, а не по ссылке. Передавать типы по значению можно, только если их внутреннее представление не превышает размера типа <TT
CLASS="TYPE"
>Datum</TT
> (на большинстве платформ 4 байта, на некоторых — 8).</P
><P
>Параметр <TT
CLASS="REPLACEABLE"
><I
>выравнивание</I
></TT
> определяет, как требуется выравнивать данные этого типа. Допускается выравнивание по границам 1, 2, 4 или 8 байт. Заметьте, что типы переменной длины должны быть выровнены как минимум по границе 4 байт, так как их первым компонентом обязательно должен быть <TT
CLASS="TYPE"
>int4</TT
>.</P
><P
>Параметр <TT
CLASS="REPLACEABLE"
><I
>хранение</I
></TT
> позволяет выбрать стратегию хранения для типов данных переменной длины. (Для типов с фиксированной длиной поддерживается только вариант <TT
CLASS="LITERAL"
>plain</TT
>.) Если выбрана стратегия <TT
CLASS="LITERAL"
>plain</TT
>, данные этого типа всегда хранятся внутри, без сжатия. Со стратегией <TT
CLASS="LITERAL"
>extended</TT
> система сначала попытается сжать большое значение, а затем выносит его из строки основной таблицы, если оно всё же окажется слишком большим. С <TT
CLASS="LITERAL"
>external</TT
> значение может быть вынесено из основной таблицы, но система не будет пытаться сжать его. Стратегия <TT
CLASS="LITERAL"
>main</TT
> позволяет сжать данные, но не стремится вынести их из основной таблицы. (Элементы данных с этой стратегией хранения, тем не менее, могут быть вынесены из основной таблицы, если другого способа уместить их в строке нет, но всё же она отдаёт большее предпочтение основной таблице, по сравнению со стратегиями <TT
CLASS="LITERAL"
>extended</TT
> и <TT
CLASS="LITERAL"
>external</TT
>.)</P
><P
>Параметр <TT
CLASS="REPLACEABLE"
><I
>тип_образец</I
></TT
> позволяет задать основные свойства представления типа другим способом: скопировать их из существующего типа. В частности, из указанного типа будут скопированы свойства <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>. (Также возможно, хотя обычно это не требуется, переопределить некоторые из этих значений, указав их вместе с предложением <TT
CLASS="LITERAL"
>LIKE</TT
>.) Определять представление типа таким образом особенно удобно, когда низкоуровневая реализация нового типа некоторым образом опирается на существующий тип.</P
><P
>Параметры <TT
CLASS="REPLACEABLE"
><I
>категория</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>предпочитаемый</I
></TT
> позволяют определять, какое неявное приведение будет применяться в неоднозначных ситуациях. Каждый тип данных принадлежит к некоторой категории, обозначаемой одним символом ASCII, при этом он может быть, либо не быть <SPAN
CLASS="QUOTE"
>"предпочитаемым"</SPAN
> в этой категории. Анализатор запроса по возможности выберет приведение к предпочитаемому типу (но только среди других типов той же категории), когда это может помочь разрешить имя перегруженной функции или оператора. За дополнительными подробностями обратитесь к <A
HREF="typeconv.html"
>Главе 10</A
>. Если для типа не определено неявное приведение к какому-либо другому типу или обратное, для этих параметров достаточно оставить значения по умолчанию. Однако если есть группа связанных типов, для которых определены неявные приведения, часто бывает полезно пометить их все как принадлежащие некоторой категории и назначить один или два <SPAN
CLASS="QUOTE"
>"наиболее общих"</SPAN
> предпочитаемыми в этой категории. Параметр <TT
CLASS="REPLACEABLE"
><I
>категория</I
></TT
> особенно полезен при добавлении типа, определённого пользователем, в существующую встроенную категорию, например, в категорию числовых или строковых типов. Однако так же возможно создать категории типов, полностью определённые пользователем. В качестве имени такой категории можно выбрать любой ASCII-символ, кроме латинской заглавной буквы.</P
><P
>Если пользователь хочет назначить колонкам с этим типом данных значение по умолчанию, отличное от NULL, он может задать его в этой команде, указав его после ключевого слова <TT
CLASS="LITERAL"
>DEFAULT</TT
>. (Такое значение по умолчанию можно переопределить явным предложением <TT
CLASS="LITERAL"
>DEFAULT</TT
>, добавленным при создании колонки.)</P
><P
>Чтобы обозначить, что тип является массивом, укажите тип элементов массива, добавив ключевое слово <TT
CLASS="LITERAL"
>ELEMENT</TT
>. Например, чтобы определить массив из четырёхбайтовых целых (<TT
CLASS="TYPE"
>int4</TT
>), укажите <TT
CLASS="LITERAL"
>ELEMENT = int4</TT
>. Дополнительные сведения о типах массивов приведены ниже.</P
><P
>Параметр <TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
> позволяет задать разделитель, который будет вставляться между значениями во внешнем представлении массива с элементами этого типа. По умолчанию разделителем является запятая (<TT
CLASS="LITERAL"
>,</TT
>). Заметьте, что разделитель связывается с типом элементов массива, а не с типом самого массива.</P
><P
>Если необязательный логический параметр <TT
CLASS="REPLACEABLE"
><I
>сортируемый</I
></TT
> равен true, определения колонок и выражения с этим типом могут включать указания о порядке сортировки, в предложении <TT
CLASS="LITERAL"
>COLLATE</TT
>. Как именно будут использоваться эти указания, зависит от реализации функций, работающих с этим типом; эти указания не действуют автоматически просто от того, что тип помечен как сортируемый.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN77455"
></A
><H3
>Типы массивов</H3
><P
>При создании любого нового типа <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> автоматически создаёт соответствующий тип массива, имя которого он получает, добавляя подчёркивание перед именем типа элементов. Если полученное имя оказывается не короче <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
> байт, оно усекается. (Если полученное таким образом имя конфликтует с именем уже существующего типа, процесс повторяется, пока не будет получено уникальное имя.) Этот неявно создаваемый тип массива имеет переменную длину и использует встроенные функции ввода и вывода <TT
CLASS="LITERAL"
>array_in</TT
> и <TT
CLASS="LITERAL"
>array_out</TT
>. Тип массива отражает любые изменения владельца или схемы связанного типа элемента и удаляется сам при удалении типа элемента.</P
><P
>Вы можете вполне резонно спросить, зачем нужен параметр <TT
CLASS="OPTION"
>ELEMENT</TT
>, если система создаёт правильный тип массива автоматически. Единственный случай, когда параметр <TT
CLASS="OPTION"
>ELEMENT</TT
> может быть полезен, это когда вы создаёте тип фиксированной длины, который внутри оказывается массивом одинаковых элементов, и вы хотите, чтобы к этим элементам можно было обращаться по индексу, помимо того, что вы можете реализовать какие угодно операции с типом в целом. Например, тип <TT
CLASS="TYPE"
>point</TT
> представлен просто как два числа с плавающей точкой, к которым можно обратиться так: <TT
CLASS="LITERAL"
>point[0]</TT
> и <TT
CLASS="LITERAL"
>point[1]</TT
>. Заметьте, что это работает только с типами фиксированной длины, которые представляют собой в точности последовательность одинаковых полей фиксированной длины. Тип массива переменной длины должен иметь обобщённое внутреннее представление, с которым умеют работать <TT
CLASS="LITERAL"
>array_in</TT
> и <TT
CLASS="LITERAL"
>array_out</TT
>. По историческим причинам (т. е. это определённо некорректно, но менять уже слишком поздно), индексы в массивах фиксированной длины начинаются с нуля, а не с 1, как в массивах переменной длины.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN77470"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) создаваемого типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_атрибута</I
></TT
></DT
><DD
><P
>Имя атрибута (колонки) составного типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
></DT
><DD
><P
>Имя существующего типа данных, который станет типом колонки составного типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
></DT
><DD
><P
>Имя существующего правила сортировки, связываемого с колонкой составного типа или с типом-диапазоном.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>метка</I
></TT
></DT
><DD
><P
>Строковая константа, представляющая текстовую метку, связанную с отдельным значением типа-перечисления.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>подтип</I
></TT
></DT
><DD
><P
>Имя типа элемента, множество значений которого будет представлять тип-диапазон.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>класс_оператора_подтипа</I
></TT
></DT
><DD
><P
>Имя класса операторов B-дерева для подтипа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>каноническая_функция</I
></TT
></DT
><DD
><P
>Имя функции канонизации для типа-диапазона.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_разницы_подтипа</I
></TT
></DT
><DD
><P
>Имя функции разницы для значений подтипа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_ввода</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей данные из внешнего текстового представления типа во внутреннюю форму.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_вывода</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей данные из внутренней формы во внешнее текстовое представление типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_получения</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей данные из внешнего двоичного представления типа во внутреннюю форму.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_отправки</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей данные из внутренней формы во внешнее двоичное представление типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_ввода_модификатора_типа</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей массив модификаторов типа во внутреннюю форму.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_вывода_модификатора_типа</I
></TT
></DT
><DD
><P
>Имя функции, преобразующей внутреннюю форму модификаторов типа во внешнее текстовое представление.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>функция_анализа</I
></TT
></DT
><DD
><P
>Имя функции, производящей статистический анализ типа данных.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>внутр_длина</I
></TT
></DT
><DD
><P
>Числовая константа, задающая размер внутреннего представления нового типа в байтах. По умолчанию предполагается, что тип имеет переменную длину.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>выравнивание</I
></TT
></DT
><DD
><P
>Требуемое выравнивание для типа данных. Допустимые значения этого параметра, если он указывается: <TT
CLASS="LITERAL"
>char</TT
>, <TT
CLASS="LITERAL"
>int2</TT
>, <TT
CLASS="LITERAL"
>int4</TT
> или <TT
CLASS="LITERAL"
>double</TT
>; по умолчанию подразумевается <TT
CLASS="LITERAL"
>int4</TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>хранение</I
></TT
></DT
><DD
><P
>Стратегия хранения для типа данных. Допустимые значения этого параметра, если он указывается: <TT
CLASS="LITERAL"
>plain</TT
>, <TT
CLASS="LITERAL"
>external</TT
>, <TT
CLASS="LITERAL"
>extended</TT
> или <TT
CLASS="LITERAL"
>main</TT
>; по умолчанию подразумевается <TT
CLASS="LITERAL"
>plain</TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_образец</I
></TT
></DT
><DD
><P
>Имя существующего типа данных, от которого новый тип получит свойства представления. Из этого типа будут скопированы значения параметров <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
> и <TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>, если их не переопределят явные указания, заданные дополнительно в этой команде <TT
CLASS="COMMAND"
>CREATE TYPE</TT
>.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>категория</I
></TT
></DT
><DD
><P
>Код категории (один символ ASCII) для этого типа. По умолчанию подразумевается <TT
CLASS="LITERAL"
>'U'</TT
> (что означает пользовательский тип, <SPAN
CLASS="QUOTE"
>"User-defined"</SPAN
>). Коды других стандартных категорий можно найти в <A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>Таблице 48-53</A
>. Для нестандартных категорий можно выбрать другие ASCII-символы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>предпочитаемый</I
></TT
></DT
><DD
><P
>Если значение этого параметра равно true, создаваемый тип будет предпочитаемым в своей категории. По умолчанию подразумевается false. Будьте очень осторожны, создавая новый предпочитаемый тип в существующей категории, так как это может поменять поведение выражений неожиданным образом.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>по_умолчанию</I
></TT
></DT
><DD
><P
>Значение по умолчанию для создаваемого типа данных. Если не указано, значением по умолчанию будет NULL.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>элемент</I
></TT
></DT
><DD
><P
>Создаваемый тип будет массивом; этот параметр определяет тип элементов массива.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>разделитель</I
></TT
></DT
><DD
><P
>Символ, разделяющий значения в массивах, образованных из значений создаваемого типа.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>сортируемый</I
></TT
></DT
><DD
><P
>Если значение этого параметра равно true, в операциях с создаваемым типом может учитываться информация о правилах сортировки. По умолчанию подразумевается false.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-NOTES"
></A
><H2
>Замечания</H2
><P
>Так как на использование типа данных после создания не накладываются ограничения, объявление базового типа или типа-диапазона по сути даёт всем право на выполнение функций, упомянутых в определении типа. Обычно это не проблема для таких функций, какие бывают полезны в определении типов. Но прежде чем создать тип, преобразование которого во внешнюю форму и обратно будет использовать <SPAN
CLASS="QUOTE"
>"секретную"</SPAN
> информацию, стоит подумать дважды.</P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 8.3 имя генерируемого типа-массива всегда образовалось из имени типа элемента и добавленного спереди символа подчёркивания (<TT
CLASS="LITERAL"
>_</TT
>). (Таким образом, допустимая максимальная длина имени типа была на символ меньше, чем длины других имён.) Хотя и сейчас имя типа массива чаще всего образуется таким образом, оно может быть и другим в случае достижения максимальной длины или конфликтов с именами пользовательских типов, начинающихся с подчёркивания. Поэтому полагаться на это соглашение в коде не рекомендуется. Вместо этого, имя типа массива, связанного с данным типом, следует определять по значению <TT
CLASS="STRUCTNAME"
>pg_type</TT
>.<TT
CLASS="STRUCTFIELD"
>typarray</TT
>.</P
><P
>Вообще же можно посоветовать не использовать имена типов и таблиц, начинающиеся с подчёркивания. Хотя сервер сможет сгенерировать другое имя, не конфликтующее с пользовательским, некоторая путаница всё же возможна, особенно со старыми клиентскими приложениями, которые могут полагать, что имя типа, начинающееся с подчёркивания, всегда относится к типу массива.</P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 8.2 у <TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
> отсутствовала форма для создания типа-пустышки. Поэтому для создания нового базового типа требовалось сначала создать функцию ввода. При таком подходе <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> воспринимал тип возврата функции ввода как имя нового типа данных и неявно создавал тип-пустышку, на который затем можно было ссылаться в определениях остальных функций ввода/вывода. Этот подход по-прежнему работает, но считается устаревшим и может быть запрещён в будущих версиях. Кроме того, во избежание непреднамеренного заполнения каталогов типами-пустышками, появляющимися в результате простых опечаток в определении функций, тип-пустышка будет создаваться таким образом, только если функция ввода написана на C.</P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 7.3 было принято вовсе не создавать тип-пустышку, заменяя в определении функций ссылки на ещё не созданный тип именем псевдотипа <TT
CLASS="TYPE"
>opaque</TT
>. Аргументы <TT
CLASS="TYPE"
>cstring</TT
> и результаты так же должны были объявляться как <TT
CLASS="TYPE"
>opaque</TT
> до версии 7.3. Для поддержки загрузки старых файлов экспорта БД, <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> примет ссылки на функции ввода/вывода, объявленные с типом <TT
CLASS="TYPE"
>opaque</TT
>, но при этом выдаст замечание и изменит в объявлении функции псевдотип на правильный.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN77643"
></A
><H2
>Примеры</H2
><P
>В этом примере создаётся составной тип, а затем он используется в определении функции: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;</PRE
><P></P
><P
>В этом примере создаётся тип-перечисление, а затем он используется в определении таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);</PRE
><P></P
><P
>В этом примере создаётся тип-диапазон: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);</PRE
><P></P
><P
>В следующем примере создаётся базовый тип данных <TT
CLASS="TYPE"
>box</TT
>, а затем он используется в определении таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);</PRE
><P></P
><P
>Если бы внутренней структурой <TT
CLASS="TYPE"
>box</TT
> был массив из четырёх элементов <TT
CLASS="TYPE"
>float4</TT
>, вместо этого можно было бы использовать определение: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);</PRE
><P> В таком случае к числам, составляющим значение этого типа, можно было бы обращаться по индексу. В остальном поведение этого типа будет таким же.</P
><P
>В этом примере создаётся тип большого объекта, а затем он используется в определении таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);</PRE
><P></P
><P
>Другие примеры, в том числе демонстрирующие подходящие функции ввода/вывода, можно найти в <A
HREF="xtypes.html"
>Разделе 35.11</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-COMPATIBILITY"
></A
><H2
>Совместимость</H2
><P
>Первая форма команды <TT
CLASS="COMMAND"
>CREATE TYPE</TT
>, создающая составной тип, соответствует стандарту <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>. Другие формы являются расширениями <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Для оператора <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> в стандарте <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> также определены другие формы, не реализованные в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
><P
>Возможность создавать составной тип без атрибутов — специфическое отклонение <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> от стандарта (как и аналогичная особенность команды <TT
CLASS="COMMAND"
>CREATE TABLE</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-SEE-ALSO"
></A
><H2
>См. также</H2
><A
HREF="sql-altertype.html"
>ALTER TYPE</A
>, <A
HREF="sql-createdomain.html"
>CREATE DOMAIN</A
>, <A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>, <A
HREF="sql-droptype.html"
>DROP TYPE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createuser.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE TRIGGER</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE USER</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>