<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Диапазонные типы</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Типы данных"
HREF="datatype.html"><LINK
REL="PREVIOUS"
TITLE="Составные типы"
HREF="rowtypes.html"><LINK
REL="NEXT"
TITLE="Идентификаторы объектов"
HREF="datatype-oid.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Составные типы"
HREF="rowtypes.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 8. Типы данных</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Идентификаторы объектов"
HREF="datatype-oid.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RANGETYPES"
>8.17. Диапазонные типы</A
></H1
><P
>Диапазонные типы представляют диапазоны значений некоторого типа данных (он также называется <I
CLASS="FIRSTTERM"
>подтипом</I
> диапазона). Например, диапазон типа <TT
CLASS="TYPE"
>timestamp</TT
> может представлять временной интервал, когда зарезервирован зал заседаний. В данном случае типом данных будет <TT
CLASS="TYPE"
>tsrange</TT
> (сокращение от <SPAN
CLASS="QUOTE"
>"timestamp range"</SPAN
>), а подтипом &mdash; <TT
CLASS="TYPE"
>timestamp</TT
>. Подтип должен быть полностью упорядочиваемым, чтобы можно было однозначно определить, где находится значение по отношению к диапазону: внутри, до или после него.</P
><P
>Диапазонные типы полезны тем, что позволяют представить множество возможных значений в одной структуре данных и чётко выразить такие понятия, как пересечение диапазонов. Наиболее очевидный вариант их использования &mdash; применять диапазоны даты и времени для составления расписания, но также полезными могут оказаться диапазоны цен, интервалы измерений и т. д.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-BUILTIN"
>8.17.1. Встроенные диапазонные типы</A
></H2
><P
>PostgreSQL имеет следующие встроенные диапазонные типы: <P
></P
></P><UL
><LI
><P
><TT
CLASS="TYPE"
>int4range</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>integer</TT
></P
></LI
><LI
><P
><TT
CLASS="TYPE"
>int8range</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>bigint</TT
></P
></LI
><LI
><P
><TT
CLASS="TYPE"
>numrange</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>numeric</TT
></P
></LI
><LI
><P
><TT
CLASS="TYPE"
>tsrange</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>timestamp without time zone</TT
></P
></LI
><LI
><P
><TT
CLASS="TYPE"
>tstzrange</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>timestamp with time zone</TT
></P
></LI
><LI
><P
><TT
CLASS="TYPE"
>daterange</TT
> &mdash; диапазон подтипа <TT
CLASS="TYPE"
>date</TT
></P
></LI
></UL
><P> Помимо этого, вы можете определять собственные типы; подробнее это описано в <A
HREF="sql-createtype.html"
>CREATE TYPE</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-EXAMPLES"
>8.17.2. Примеры</A
></H2
><P
></P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');

-- Вхождение
SELECT int4range(10, 20) @&gt; 3;

-- Перекрытие
SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);

-- Получение верхней границы
SELECT upper(int8range(15, 25));

-- Вычисление пересечения
SELECT int4range(10, 20) * int4range(15, 25);

-- Является ли диапазон пустым?
SELECT isempty(numrange(1, 5));</PRE
><P> Полный список операторов и функций, предназначенных для диапазонных типов, приведён в <A
HREF="functions-range.html#RANGE-OPERATORS-TABLE"
>Таблице 9-47</A
> и <A
HREF="functions-range.html#RANGE-FUNCTIONS-TABLE"
>Таблице 9-48</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-INCLUSIVITY"
>8.17.3. Включение и исключение границ</A
></H2
><P
>Любой непустой диапазон имеет две границы, верхнюю и нижнюю, и включает все точки между этими значениями. В него также может входить точка, лежащая на границе, если диапазон включает эту границу. И наоборот, если диапазон не включает границу, считается, что точка, лежащая на этой границе, в него не входит.</P
><P
>В текстовой записи диапазона включение нижней границы обозначается символом <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>[</TT
>"</SPAN
>, а исключением &mdash; символом <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>(</TT
>"</SPAN
>. Для верхней границы включение обозначается аналогично, символом <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>]</TT
>"</SPAN
>, а исключение &mdash; символом <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>)</TT
>"</SPAN
>. (Подробнее это описано в <A
HREF="rangetypes.html#RANGETYPES-IO"
>Подразделе 8.17.5</A
>.)</P
><P
>Для проверки, включается ли нижняя или верхняя граница в диапазон, предназначены функции <TT
CLASS="LITERAL"
>lower_inc</TT
> и <TT
CLASS="LITERAL"
>upper_inc</TT
>, соответственно.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-INFINITE"
>8.17.4. Неограниченные (бесконечные) диапазоны</A
></H2
><P
>Нижнюю границу диапазона можно опустить и определить тем самым диапазон, включающий все точки, лежащие ниже верхней границы. Подобным образом, если не определить верхнюю границу, в диапазон войдут все точки, лежащие выше нижней границы. Если же опущена и нижняя, и правая границы, такой диапазон будет включать все возможные значения своего подтипа.</P
><P
>Это равнозначно тому, что нижней границей будет считаться <SPAN
CLASS="QUOTE"
>"минус бесконечность"</SPAN
>, а верхней &mdash; <SPAN
CLASS="QUOTE"
>"плюс бесконечность"</SPAN
>. Но заметьте, что эти бесконечные значения не являются значениями подтипа диапазона и поэтому также не могут входить в диапазон. (Как следствие, нет такого понятия, как включаемая нижняя бесконечная граница &mdash; если попытаться записать такой диапазон, она будет автоматически преобразована в исключаемую.)</P
><P
>Кроме этого, в некоторых типах есть понятие <SPAN
CLASS="QUOTE"
>"бесконечность"</SPAN
>, но в данном контексте оно считается просто одним из значений. Например, во временных диапазонах <TT
CLASS="LITERAL"
>[today,]</TT
> означает то же самое, что и <TT
CLASS="LITERAL"
>[today,)</TT
>. Но диапазон <TT
CLASS="LITERAL"
>[today,infinity]</TT
> отличается от <TT
CLASS="LITERAL"
>[today,infinity)</TT
> &mdash; в последнем специальное значение <TT
CLASS="LITERAL"
>infinity</TT
> типа <TT
CLASS="TYPE"
>timestamp</TT
> не входит в диапазон.</P
><P
>Проверить, определена ли верхняя или нижняя граница, можно с помощью функций <TT
CLASS="LITERAL"
>lower_inf</TT
> и <TT
CLASS="LITERAL"
>upper_inf</TT
>, соответственно.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-IO"
>8.17.5. Ввод/вывод диапазонов</A
></H2
><P
>Вводимое значение диапазона должно записываться в одной из следующих форм: </P><PRE
CLASS="SYNOPSIS"
>(<TT
CLASS="REPLACEABLE"
><I
>нижняя-граница</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>верхняя-граница</I
></TT
>)
(<TT
CLASS="REPLACEABLE"
><I
>нижняя-граница</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>верхняя-граница</I
></TT
>]
[<TT
CLASS="REPLACEABLE"
><I
>нижняя-граница</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>верхняя-граница</I
></TT
>)
[<TT
CLASS="REPLACEABLE"
><I
>нижняя-граница</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>верхняя-граница</I
></TT
>]
empty</PRE
><P> Тип скобок (квадратные или круглые) определяет, включаются ли в диапазон соответствующие границы, как описано выше. Заметьте, что последняя форма содержит только слово <TT
CLASS="LITERAL"
>empty</TT
> и определяет пустой диапазон (диапазон, не содержащий точек).</P
><P
>Здесь <TT
CLASS="REPLACEABLE"
><I
>нижняя-граница</I
></TT
> может быть строкой с допустимым значением подтипа или быть пустой (тогда диапазон будет без нижней границы). Аналогично, <TT
CLASS="REPLACEABLE"
><I
>верхняя-граница</I
></TT
> может задаваться одним из значений подтипа или быть неопределённой (пустой).</P
><P
>Любое значение диапазона можно заключить в кавычки (<TT
CLASS="LITERAL"
>"</TT
>). А если значение содержит круглые или квадратные скобки, запятые, кавычки или обратную косую черту, использовать кавычки необходимо, чтобы эти символы не рассматривались как часть синтаксиса диапазона. Чтобы включить в значение диапазона, заключённое в кавычки, такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавычки в значении диапазона, заключённого в кавычки, воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть синтаксиса диапазона, с помощью спецпоследовательностей. Чтобы задать в качестве границы пустую строку, нужно ввести <TT
CLASS="LITERAL"
>""</TT
>, так как пустая строка без кавычек будет означать отсутствие границы.</P
><P
>Пробельные символы до и после определения диапазона игнорируются, но когда они присутствуют внутри скобок, они воспринимаются как часть значения верхней или нижней границы. (Хотя они могут также игнорироваться в зависимости от подтипа диапазона.)</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Эти правила очень похожи на правила записи значений для полей составных типов. Дополнительные замечания приведены в <A
HREF="rowtypes.html#ROWTYPES-IO-SYNTAX"
>Подразделе 8.16.5</A
>.</P
></BLOCKQUOTE
></DIV
><P
>Примеры: </P><PRE
CLASS="PROGRAMLISTING"
>-- в диапазон включается 3, не включается 7 и включаются все точки между ними
SELECT '[3,7)'::int4range;

-- в диапазон не включаются 3 и 7, но включаются все точки между ними
SELECT '(3,7)'::int4range;

-- в диапазон включается только одно значение 4
SELECT '[4,4]'::int4range;

-- диапазон не включает никаких точек (нормализация заменит его определение
--  на 'empty')
SELECT '[4,4)'::int4range;</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-CONSTRUCT"
>8.17.6. Конструирование диапазонов</A
></H2
><P
>Для каждого диапазонного типа определена функция конструктора, имеющая то же имя, что и данный тип. Использовать этот конструктор обычно удобнее, чем записывать текстовую константу диапазона, так как это избавляет от потребности в дополнительных кавычках. Функция конструктора может принимать два или три параметра. Вариант с двумя параметрами создаёт диапазон в стандартной форме (нижняя граница включается, верхняя исключается), тогда как для варианта с тремя параметрами включение границ определяется третьим параметром. Третий параметр должен содержать одну из строк: <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>()</TT
>"</SPAN
>, <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>(]</TT
>"</SPAN
>, <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>[)</TT
>"</SPAN
> или <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>[]</TT
>"</SPAN
>. Например: </P><PRE
CLASS="PROGRAMLISTING"
>-- Полная форма: нижняя граница, верхняя граница и текстовая строка, определяющая
-- включение/исключение границ.
SELECT numrange(1.0, 14.0, '(]');

-- Если третий аргумент опущен, подразумевается '[)'.
SELECT numrange(1.0, 14.0);

-- Хотя здесь указывается '(]', при выводе значение будет приведено к
-- каноническому виду, так как int8range &mdash; тип дискретного диапазона (см. ниже).
SELECT int8range(1, 14, '(]');

-- Когда вместо любой границы указывается NULL, соответствующей границы
--  у диапазона не будет.
SELECT numrange(NULL, 2.2);</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-DISCRETE"
>8.17.7. Типы дискретных диапазонов</A
></H2
><P
>Дискретным диапазоном считается диапазон, для подтипа которого однозначно определён <SPAN
CLASS="QUOTE"
>"шаг"</SPAN
>, как например для типов <TT
CLASS="TYPE"
>integer</TT
> и <TT
CLASS="TYPE"
>date</TT
>. Значения этих двух типов можно назвать соседними, когда между ними нет никаких других значений. В непрерывных диапазонах, напротив, всегда (или почти всегда) можно найти ещё одно значение между двумя данными. Например, непрерывным диапазоном будет диапазон с подтипами <TT
CLASS="TYPE"
>numeric</TT
> и <TT
CLASS="TYPE"
>timestamp</TT
>. (Хотя <TT
CLASS="TYPE"
>timestamp</TT
> имеет ограниченную точность, то есть теоретически он является дискретным, но всё же лучше считать его непрерывным, так как шаг его обычно не определён.)</P
><P
>Можно также считать дискретным подтип диапазона, в котором чётко определены понятия <SPAN
CLASS="QUOTE"
>"следующего"</SPAN
> и <SPAN
CLASS="QUOTE"
>"предыдущего"</SPAN
> элемента для каждого значения. Такие определения позволяют преобразовывать границы диапазона из включаемых в исключаемые, выбирая следующий или предыдущий элемент вместо заданного значения. Например, диапазоны целочисленного типа <TT
CLASS="LITERAL"
>[4,8]</TT
> и <TT
CLASS="LITERAL"
>(3,9)</TT
> описывают одно и то же множество значений; но для диапазона подтипа numeric это не так.</P
><P
>Для типа дискретного диапазона определяется функция <I
CLASS="FIRSTTERM"
>канонизации</I
>, учитывающая размер шага для данного подтипа. Задача этой функции &mdash; преобразовать равнозначные диапазоны к единственному представлению, в частности нормализовать включаемые и исключаемые границы. Если функция канонизации не определена, диапазоны с различным определением будут всегда считаться разными, даже когда они на самом деле представляют одно множество значений.</P
><P
>Для встроенных типов <TT
CLASS="TYPE"
>int4range</TT
>, <TT
CLASS="TYPE"
>int8range</TT
> и <TT
CLASS="TYPE"
>daterange</TT
> каноническое представление включает нижнюю границу и не включает верхнюю; то есть диапазон приводится к виду <TT
CLASS="LITERAL"
>[)</TT
>. Однако для нестандартных типов можно использовать и другие соглашения.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-DEFINING"
>8.17.8. Определение новых диапазонных типов</A
></H2
><P
>Пользователи могут определять собственные диапазонные типы. Это может быть полезно, когда нужно использовать диапазоны с подтипами, для которых нет встроенных диапазонных типов. Например, можно определить новый тип диапазона для подтипа <TT
CLASS="TYPE"
>float8</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE floatrange AS RANGE (
    subtype = float8,
    subtype_diff = float8mi
);

SELECT '[1.234, 5.678]'::floatrange;</PRE
><P> Так как для <TT
CLASS="TYPE"
>float8</TT
> осмысленное значение <SPAN
CLASS="QUOTE"
>"шага"</SPAN
> не определено, функция канонизации в данном примере не задаётся.</P
><P
>Если подтип можно рассматривать как дискретный, а не непрерывный, в команде <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> следует также задать функцию <TT
CLASS="LITERAL"
>канонизации</TT
>. Этой функции будет передаваться значение диапазона, а она должна вернуть равнозначное значение, но, возможно, с другими границами и форматированием. Для двух диапазонов, представляющих одно множество значений, например, целочисленные диапазоны <TT
CLASS="LITERAL"
>[1, 7]</TT
> и <TT
CLASS="LITERAL"
>[1, 8)</TT
>, функция канонизации должна выдавать один результат. Какое именно представление будет считаться каноническим, не имеет значения &mdash; главное, чтобы два равнозначных диапазона, отформатированных по-разному, всегда преобразовывались в одно значение с одинаковым форматированием. Помимо исправления формата включаемых/исключаемых границ, функция канонизации может округлять значения границ, если размер шага превышает точность хранения подтипа. Например, в типе диапазона для подтипа <TT
CLASS="TYPE"
>timestamp</TT
> можно определить размер шага, равный часу, тогда функция канонизации должна будет округлить границы, заданные, например с точностью до минут, либо вместо этого выдать ошибку.</P
><P
>Определяя собственный диапазонный тип, вы также можете выбрать другие правила сортировки или класс оператора B-дерева для его подтипа, что позволит изменить порядок значений, от которого зависит, какие значения попадают в заданный диапазон.</P
><P
>Помимо этого, для любого диапазонного типа, ориентированного на использование с индексами GiST или SP-GiST, должна быть определена разница значений подтипов, функция <TT
CLASS="LITERAL"
>subtype_diff</TT
>. (Индекс сможет работать и без <TT
CLASS="LITERAL"
>subtype_diff</TT
>, но в большинстве случае это будет не так эффективно.) Эта функция принимает на вход два значения подтипа и возвращает их разницу (т. е. <TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
> минус <TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>) в значении типа <TT
CLASS="TYPE"
>float8</TT
>. В показанном выше примере эта функция внутри может использовать обычный оператор <SPAN
CLASS="QUOTE"
>"минус"</SPAN
> для типа <TT
CLASS="TYPE"
>float8</TT
>, но для другого подтипа могут потребоваться дополнительные преобразования. Иногда для представления разницы в числовом виде требуется ещё и творческий подход. Функция <TT
CLASS="LITERAL"
>subtype_diff</TT
>, насколько это возможно, должна быть согласована с порядком сортировки, вытекающим из выбранных правил сортировки и класса оператора; то есть, её результат должен быть положительным, если согласно порядку сортировки первый её аргумент больше второго.</P
><P
>Дополнительные сведения о создании диапазонных типов можно найти в описании <A
HREF="sql-createtype.html"
>CREATE TYPE</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-INDEXING"
>8.17.9. Индексация</A
></H2
><P
>Для колонок, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST. Например, так создаётся индекс GiST: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX reservation_idx ON reservation USING gist (during);</PRE
><P> Индекс GiST или SP-GiST помогает ускорить запросы со следующими операторами: <TT
CLASS="LITERAL"
>=</TT
>, <TT
CLASS="LITERAL"
>&amp;&amp;</TT
>, <TT
CLASS="LITERAL"
>&lt;@</TT
>, <TT
CLASS="LITERAL"
>@&gt;</TT
>, <TT
CLASS="LITERAL"
>&lt;&lt;</TT
>, <TT
CLASS="LITERAL"
>&gt;&gt;</TT
>, <TT
CLASS="LITERAL"
>-|-</TT
>, <TT
CLASS="LITERAL"
>&amp;&lt;</TT
> и <TT
CLASS="LITERAL"
>&amp;&gt;</TT
> (дополнительно о них можно узнать в <A
HREF="functions-range.html#RANGE-OPERATORS-TABLE"
>Таблице 9-47</A
>.</P
><P
>Кроме того, для таких колонок можно создать индексы на основе хеша и B-деревьев. Для индексов таких типов полезен по сути только один оператор диапазона &mdash; равно. Порядок сортировки B-дерева определяется для значений диапазона соответствующими операторами <TT
CLASS="LITERAL"
>&lt;</TT
> и <TT
CLASS="LITERAL"
>&gt;</TT
>, но этот порядок может быть произвольным и он не очень важен в реальном мире. Поддержка B-деревьев и хешей диапазонными типами нужна в основном для сортировки и хеширования при выполнении запросов, но не для создания самих индексов.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RANGETYPES-CONSTRAINT"
>8.17.10. Ограничения для диапазонов</A
></H2
><P
>Тогда как для скалярных значений естественным ограничением является <TT
CLASS="LITERAL"
>UNIQUE</TT
>, оно обычно не подходит для диапазонных типов. Вместо этого чаще оказываются полезнее ограничения-исключения (см. <A
HREF="sql-createtable.html#SQL-CREATETABLE-EXCLUDE"
>CREATE TABLE ... CONSTRAINT ... EXCLUDE</A
>). Такие ограничения позволяют, например определить условие <SPAN
CLASS="QUOTE"
>"непересечения"</SPAN
> диапазонов. Например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE reservation (
    during tsrange,
    EXCLUDE USING gist (during WITH &amp;&amp;)
);</PRE
><P> Это ограничение не позволит одновременно сохранить в таблице несколько диапазонов, которые накладываются друг на друга: </P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO reservation VALUES
    ('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO reservation VALUES
    ('[2010-01-01 14:45, 2010-01-01 15:45)');
ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение "reservation_during_excl"
ПОДРОБНОСТИ: Ключ (during)=(["2010-01-01 14:45:00","2010-01-01 15:45:00"))
конфликтует с существующим ключом (during)=(["2010-01-01 11:30:00","2010-01-01 15:00:00"))</PRE
><P></P
><P
>Для максимальной гибкости в ограничении-исключении можно сочетать простые скалярные типы данных с диапазонами, используя расширение <A
HREF="btree-gist.html"
><TT
CLASS="LITERAL"
>btree_gist</TT
></A
>. Например, если <TT
CLASS="LITERAL"
>btree_gist</TT
> установлено, следующее ограничение не будет допускать пересекающиеся диапазоны, только если совпадают также и номера комнат: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
    room text,
    during tsrange,
    EXCLUDE USING gist (room WITH =, during WITH &amp;&amp;)
);

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение
  "room_reservation_room_during_excl"
ПОДРОБНОСТИ:  Ключ (room, during)=(123A, [ 2010-01-01 14:30:00,
  2010-01-01 15:30:00 )) конфликтует
с существующим ключом (room, during)=(123A, ["2010-01-01 14:00:00","2010-01-01 15:00:00")).

INSERT INTO room_reservation VALUES
    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1</PRE
><P></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="rowtypes.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="datatype-oid.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Составные типы</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Идентификаторы объектов</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>