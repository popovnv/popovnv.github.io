<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Компоновка страницы базы данных</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Физическое хранение базы данных"
HREF="storage.html"><LINK
REL="PREVIOUS"
TITLE="Слой инициализации"
HREF="storage-init.html"><LINK
REL="NEXT"
TITLE="Внутренний интерфейс BKI"
HREF="bki.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Слой инициализации"
HREF="storage-init.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 59. Физическое хранение базы данных</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Внутренний интерфейс BKI"
HREF="bki.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STORAGE-PAGE-LAYOUT"
>59.6. Компоновка страницы базы данных</A
></H1
><P
>В данном разделе рассматривается формат страницы, используемый в таблицах и индексах <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.<A
NAME="AEN107948"
HREF="#FTN.AEN107948"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
> Последовательности и таблицы <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> форматируются как обычные таблицы.</P
><P
>В дальнейшем подразумевается, что <I
CLASS="FIRSTTERM"
>байт</I
> содержит 8 бит. В дополнение, термин <I
CLASS="FIRSTTERM"
>элемент</I
> относится к индивидуальному значению данных, которое хранится на странице. В таблице элемент — это строка; в индексе — элемент индекса.</P
><P
>Каждая таблица и индекс хранятся как массив <I
CLASS="FIRSTTERM"
>страниц</I
> фиксированного размера (обычно 8 kB, хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой странице. В индексах первая страница обычно резервируется как <I
CLASS="FIRSTTERM"
>метастраница</I
>, хранящая контрольную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода доступа индекса.</P
><P
><A
HREF="storage-page-layout.html#PAGE-TABLE"
>Таблица 59-2</A
> показывает общую компоновку страницы. Каждая страница имеет пять частей.</P
><DIV
CLASS="TABLE"
><A
NAME="PAGE-TABLE"
></A
><P
><B
>Таблица 59-2. Общая компоновка страницы</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Элемент</TH
><TH
>Описание</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Данные заголовка страницы</TD
><TD
>Длина - 24 байта. Содержит общую информацию о странице, включая указатели свободного пространства.</TD
></TR
><TR
><TD
>Данные идентификаторов элементов</TD
><TD
>Массив пар (смещение, длина), указывающих на фактические элементы. Для каждого элемента выделяется 4 байта.</TD
></TR
><TR
><TD
>Свободное пространство</TD
><TD
>Незанятое пространство. Новые указатели элементов размещаются с начала этой области, сами новые элементы — с конца.</TD
></TR
><TR
><TD
>Элементы</TD
><TD
>Сами элементы данных как таковые.</TD
></TR
><TR
><TD
>Специальное пространство</TD
><TD
>Специфические данные метода доступа. Для различных методов хранятся различные данные. Для обычных таблиц таких данных нет.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Первые 24 байта каждой страницы состоят из заголовка страницы (данные заголовка страницы). Формат заголовка детализирован в <A
HREF="storage-page-layout.html#PAGEHEADERDATA-TABLE"
>Таблице 59-3</A
>. Первые два поля отслеживают последнюю запись WAL, связанную с этой страницей. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следует три двухбайтовых целочисленных поля (<TT
CLASS="STRUCTFIELD"
>pd_lower</TT
>, <TT
CLASS="STRUCTFIELD"
>pd_upper</TT
> и <TT
CLASS="STRUCTFIELD"
>pd_special</TT
>). Эти поля содержат смещения от начала страницы до начала незанятого пространства, до конца незанятого пространства и до начала специального пространства. Следующие 2 байта заголовка страницы, <TT
CLASS="STRUCTFIELD"
>pd_pagesize_version</TT
>, хранят как размер страницы, так и индикатор версии. Начиная с <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.3, используется версия 4; <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1 и 8.2 использовали версию 3; <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.0 — версию 2; <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3 и 7.4 — версию 1; в более ранних выпусках использовалась версия 0. (Основная компоновка страницы и формат заголовка остались прежними в большинстве этих версий, а компоновка заголовков строк таблицы изменилась.) Размер страницы присутствует, в основном, для осуществления сквозного контроля, так как при установке поддерживается не более одного размера страницы. Последнее поле является подсказкой, которая говорит о том, будет ли очистка страницы являться эффективной: оно отслеживает самый старый идентификатор XMAX на странице, перед которым производилась очистка.</P
><DIV
CLASS="TABLE"
><A
NAME="PAGEHEADERDATA-TABLE"
></A
><P
><B
>Таблица 59-3. Данные заголовка страницы (PageHeaderData)</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>Поле</TH
><TH
>Тип</TH
><TH
>Длина</TH
><TH
>Описание</TH
></TR
></THEAD
><TBODY
><TR
><TD
>pd_lsn</TD
><TD
>XLogRecPtr</TD
><TD
>8 байт</TD
><TD
>LSN: Следующий байт после последнего байта записи xlog для последнего изменения на этой странице</TD
></TR
><TR
><TD
>pd_checksum</TD
><TD
>uint16</TD
><TD
>2 байта</TD
><TD
>Контрольная сумма страницы</TD
></TR
><TR
><TD
>pd_flags</TD
><TD
>uint16</TD
><TD
>2 байта</TD
><TD
>Биты признаков</TD
></TR
><TR
><TD
>pd_lower</TD
><TD
>LocationIndex</TD
><TD
>2 байта</TD
><TD
>Смещение до начала свободного пространства</TD
></TR
><TR
><TD
>pd_upper</TD
><TD
>LocationIndex</TD
><TD
>2 байта</TD
><TD
>Смещение до конца свободного пространства</TD
></TR
><TR
><TD
>pd_special</TD
><TD
>LocationIndex</TD
><TD
>2 байта</TD
><TD
>Смещение до начала специального пространства</TD
></TR
><TR
><TD
>pd_pagesize_version</TD
><TD
>uint16</TD
><TD
>2 байта</TD
><TD
>Информация о размере страницы и номере версии компоновки</TD
></TR
><TR
><TD
>pd_prune_xid</TD
><TD
>TransactionId</TD
><TD
>4 байта</TD
><TD
>Самый старый неочищенный идентификатор XMAX на странице или ноль при отсутствии такового</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Всю подробную информацию можно найти в <TT
CLASS="FILENAME"
>src/include/storage/bufpage.h</TT
>.</P
><P
>За заголовком страницы следуют идентификаторы элемента (<TT
CLASS="TYPE"
>ItemIdData</TT
>), каждому из которых требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые идентификаторы элементов размещаются по мере необходимости от начала свободного пространства. Количество имеющихся идентификаторов элементов можно определить через значение <TT
CLASS="STRUCTFIELD"
>pd_lower</TT
>, которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор элемента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно использовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам элемент перемещается по странице для уплотнения свободного пространства. Фактически каждый указатель на элемент (<TT
CLASS="TYPE"
>ItemPointer</TT
>, также известный как <TT
CLASS="TYPE"
>CTID</TT
>), созданный <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, состоит из номера страницы и индекса идентификатора элемента.</P
><P
>Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу незанятого пространства. Точная структура меняется в зависимости от того, каким будет содержание таблицы. Как таблицы, так и последовательности используют структуру под названием <TT
CLASS="TYPE"
>HeapTupleHeaderData</TT
>, которая описывается ниже.</P
><P
>Последний раздел является <SPAN
CLASS="QUOTE"
>"особым разделом"</SPAN
>, который может содержать всё, что необходимо методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные таблицы не используют особый раздел вовсе (что указывается установкой значения <TT
CLASS="STRUCTFIELD"
>pd_special</TT
> равным размеру страницы).</P
><P
>Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксированного размера (занимающий 23 байта на большинстве машин), за которым следует необязательная битовая карта пустых значений, необязательное поле идентификатора объекта и данные пользователя. Подробное описание заголовка представлено в <A
HREF="storage-page-layout.html#HEAPTUPLEHEADERDATA-TABLE"
>Таблица 59-4</A
>. Актуальные пользовательские данные (столбцы строки) начинаются после смещения, заданного в <TT
CLASS="STRUCTFIELD"
>t_hoff</TT
>, которое должно всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеется тогда, когда бит <I
CLASS="FIRSTTERM"
>HEAP_HASNULL</I
> установлен в значении <TT
CLASS="STRUCTFIELD"
>t_infomask</TT
>. В случае наличия, она начинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один бит на столбец (т. е. <TT
CLASS="STRUCTFIELD"
>t_natts</TT
> битов всего). В этом списке битов установленный в единицу бит означает непустое значение, а установленный в ноль соответствует пустому значению. Когда битовая карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если только бит <I
CLASS="FIRSTTERM"
>HEAP_HASOID</I
> установлен в значении <TT
CLASS="STRUCTFIELD"
>t_infomask</TT
>. Если он есть, он расположен сразу перед началом <TT
CLASS="STRUCTFIELD"
>t_hoff</TT
>. Любое заполнение, необходимое для того, чтобы сделать <TT
CLASS="STRUCTFIELD"
>t_hoff</TT
> кратным MAXALIGN, будет расположено между битовой картой пустых значений и идентификатором объекта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)</P
><DIV
CLASS="TABLE"
><A
NAME="HEAPTUPLEHEADERDATA-TABLE"
></A
><P
><B
>Таблица 59-4. Данные заголовка строки таблицы (HeapTupleHeaderData)</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>Поле</TH
><TH
>Тип</TH
><TH
>Длина</TH
><TH
>Описание</TH
></TR
></THEAD
><TBODY
><TR
><TD
>t_xmin</TD
><TD
>TransactionId</TD
><TD
>4 байта</TD
><TD
>значение XID вставки</TD
></TR
><TR
><TD
>t_xmax</TD
><TD
>TransactionId</TD
><TD
>4 байта</TD
><TD
>значение XID удаления</TD
></TR
><TR
><TD
>t_cid</TD
><TD
>CommandId</TD
><TD
>4 байта</TD
><TD
>значение CID для вставки и/или удаления (пересекается с t_xvac)</TD
></TR
><TR
><TD
>t_xvac</TD
><TD
>TransactionId</TD
><TD
>4 байта</TD
><TD
>XID для операции VACUUM, которая перемещает версию строки</TD
></TR
><TR
><TD
>t_ctid</TD
><TD
>ItemPointerData</TD
><TD
>6 байт</TD
><TD
>текущее значение TID этой или более новой версии строки</TD
></TR
><TR
><TD
>t_infomask2</TD
><TD
>uint16</TD
><TD
>2 байта</TD
><TD
>количество атрибутов плюс различные биты флагов</TD
></TR
><TR
><TD
>t_infomask</TD
><TD
>uint16</TD
><TD
>2 байта</TD
><TD
>различные биты флагов</TD
></TR
><TR
><TD
>t_hoff</TD
><TD
>uint8</TD
><TD
>1 байт</TD
><TD
>отступ до пользовательских данных</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Всю подробную информацию можно найти в <TT
CLASS="FILENAME"
>src/include/access/htup.h</TT
>.</P
><P
>Интерпретация текущих данных может быть проведена с помощью информации, полученной из других таблиц, в основном из <TT
CLASS="STRUCTNAME"
>pg_attribute</TT
>. Ключевые значения, необходимые для определения расположения полей <TT
CLASS="STRUCTFIELD"
>attlen</TT
> и <TT
CLASS="STRUCTFIELD"
>attalign</TT
>. Не существует способа непосредственного получения заданного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом нет пустых значений. Все эти особенности учитываются в функциях <I
CLASS="FIRSTTERM"
>heap_getattr</I
>, <I
CLASS="FIRSTTERM"
>fastgetattr</I
> и <I
CLASS="FIRSTTERM"
>heap_getsysattr</I
>.</P
><P
>Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений. Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной длиной имеют общую структуру заголовка <TT
CLASS="TYPE"
>struct varlena</TT
>, которая включает общую длину сохранённого значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут храниться либо локально, либо в таблице <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>. Также, возможно сжатие данных (см. <A
HREF="storage-toast.html"
>Раздел 59.2</A
>).</P
></DIV
><H3
CLASS="FOOTNOTES"
>Примечания</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN107948"
HREF="storage-page-layout.html#AEN107948"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage-init.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="bki.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Слой инициализации</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Внутренний интерфейс <ACRONYM
CLASS="ACRONYM"
>BKI</ACRONYM
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>