<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE TABLE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE SERVER"
HREF="sql-createserver.html"><LINK
REL="NEXT"
TITLE="CREATE TABLE AS"
HREF="sql-createtableas.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE SERVER"
HREF="sql-createserver.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE TABLE AS"
HREF="sql-createtableas.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATETABLE"
></A
>CREATE TABLE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN75625"
></A
><H2
>Название</H2
>CREATE TABLE&nbsp;--&nbsp;создать таблицу</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN75628"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> ( [
  { <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>ограничение_колонки</I
></TT
> [ ... ] ]
    | <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
>
    | LIKE <TT
CLASS="REPLACEABLE"
><I
>исходная_таблица</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>вариант_копирования</I
></TT
> ... ] }
    [, ... ]
] )
[ INHERITS ( <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
> [, ... ] ) ]
[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>
    OF <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
> [ (
  { <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> WITH OPTIONS [ <TT
CLASS="REPLACEABLE"
><I
>ограничение_колонки</I
></TT
> [ ... ] ]
    | <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
> }
    [, ... ]
) ]
[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
> ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>Здесь <TT
CLASS="REPLACEABLE"
><I
>ограничение_колонки</I
></TT
>:</SPAN
></SPAN
>

[ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> ]
{ NOT NULL |
  NULL |
  CHECK ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ) [ NO INHERIT ] |
  DEFAULT <TT
CLASS="REPLACEABLE"
><I
>выражение_по_умолчанию</I
></TT
> |
  UNIQUE <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> |
  PRIMARY KEY <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> |
  REFERENCES <TT
CLASS="REPLACEABLE"
><I
>целевая_таблица</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>целевая_колонка</I
></TT
> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>и <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
>:</SPAN
></SPAN
>

[ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> ]
{ CHECK ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ) [ NO INHERIT ] |
  UNIQUE ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> |
  PRIMARY KEY ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> |
  EXCLUDE [ USING <TT
CLASS="REPLACEABLE"
><I
>метод_индекса</I
></TT
> ] ( <TT
CLASS="REPLACEABLE"
><I
>элемент_исключения</I
></TT
> WITH <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> [ WHERE ( <TT
CLASS="REPLACEABLE"
><I
>предикат</I
></TT
> ) ] |
  FOREIGN KEY ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] ) REFERENCES <TT
CLASS="REPLACEABLE"
><I
>целевая_таблица</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>целевая_колонка</I
></TT
> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>и <TT
CLASS="REPLACEABLE"
><I
>вариант_копирования</I
></TT
>:</SPAN
></SPAN
>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
><TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> в ограничениях <TT
CLASS="LITERAL"
>UNIQUE</TT
>, <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> и <TT
CLASS="LITERAL"
>EXCLUDE</TT
>:</SPAN
></SPAN
>

[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
>] [, ... ] ) ]
[ USING INDEX TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
> ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
><TT
CLASS="REPLACEABLE"
><I
>элемент_исключения</I
></TT
> в ограничении <TT
CLASS="LITERAL"
>EXCLUDE</TT
>:</SPAN
></SPAN
>

{ <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ) } [ <TT
CLASS="REPLACEABLE"
><I
>класс_операторов</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETABLE-DESCRIPTION"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>CREATE TABLE</TT
> создаёт новую, изначально пустую таблицу в текущей базе данных. Владельцем таблицы будет пользователь, выполнивший эту команду.</P
><P
>Если задано имя схемы (например, <TT
CLASS="LITERAL"
>CREATE TABLE myschema.mytable ...</TT
>), таблица создаётся в указанной схеме, в противном случае — в текущей. Временные таблицы существуют в специальной схеме, так что при создании таких таблиц имя схемы задать нельзя. Имя таблицы должно отличаться от имён других таблиц, последовательностей, индексов, представлений или сторонних таблиц в этой схеме.</P
><P
><TT
CLASS="COMMAND"
>CREATE TABLE</TT
> также автоматически создаёт составной тип данных, соответствующий одной строке таблицы. Таким образом, имя таблицы не может совпадать с именем существующего типа в этой же схеме.</P
><P
>Необязательные предложения ограничений задают ограничения (проверки), которым должны удовлетворять добавляемые или изменяемые строки, чтобы операция добавления или изменения была выполнена успешно. Ограничение представляет собой SQL-объект, помогающий некоторым способом определить множество допустимых значений в таблице.</P
><P
>Определить ограничения можно двумя способами: в виде ограничений таблицы и в виде ограничений колонки. Ограничение колонки определяется как часть определения колонки, а ограничение таблицы не привязывается к конкретной колонке и может задействовать несколько колонок. Любые ограничения колонок можно также записать в виде ограничения таблицы, они введены просто для удобства записи в случаях, когда ограничение затрагивает только одну колонку.</P
><P
>Чтобы создать таблицу, необходимо иметь право <TT
CLASS="LITERAL"
>USAGE</TT
> для типов всех колонок или типа в предложении <TT
CLASS="LITERAL"
>OF</TT
>, соответственно.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN75708"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="SQL-CREATETABLE-TEMPORARY"
></A
><TT
CLASS="LITERAL"
>TEMPORARY</TT
> или <TT
CLASS="LITERAL"
>TEMP</TT
></DT
><DD
><P
>С таким указанием таблица создаётся как временная. Временные таблицы автоматически удаляются в конце сеанса или могут удаляться в конце текущей транзакции (см. описание <TT
CLASS="LITERAL"
>ON COMMIT</TT
> ниже). Существующая постоянная таблица с тем же именем не будет видна в текущем сеансе, пока существует временная, однако к ней можно обратиться, дополнив имя указанием схемы. Все индексы, создаваемые для временной таблицы, так же автоматически становятся временными.</P
><P
><A
HREF="routine-vacuuming.html#AUTOVACUUM"
>Демон автоочистки</A
> не может прочитать и, как следствие, сжимать и анализировать временные таблицы. По этой причине соответствующие операции очистки и анализа следует выполнять, вызывая SQL-команды в рамках сеанса. Например, если временную таблицу планируется использовать в сложных запросах, будет разумным выполнить для неё <TT
CLASS="COMMAND"
>ANALYZE</TT
> после того, как она будет наполнена.</P
><P
>По желанию можно добавить указание <TT
CLASS="LITERAL"
>GLOBAL</TT
> или <TT
CLASS="LITERAL"
>LOCAL</TT
> перед <TT
CLASS="LITERAL"
>TEMPORARY</TT
> или <TT
CLASS="LITERAL"
>TEMP</TT
>. В настоящее время это не имеет значения для <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> и считается устаревшей возможностью; см. <A
HREF="sql-createtable.html#SQL-CREATETABLE-COMPATIBILITY"
><I
>Совместимость</I
></A
>.</P
></DD
><DT
><A
NAME="SQL-CREATETABLE-UNLOGGED"
></A
><TT
CLASS="LITERAL"
>UNLOGGED</TT
></DT
><DD
><P
>С этим указанием таблица создаётся как нежурналируемая. Данные, записываемые в нежурналируемые таблицы, не проходят через журнал упреждающей записи (см. <A
HREF="wal.html"
>Главу 29</A
>), в результате чего такие таблицы работают гораздо быстрее обычных. Однако, они не защищены от сбоя; при сбое или аварийном отключении сервера нежурналируемая таблица автоматически усекается. Кроме того, содержимое нежурналируемой таблицы не реплицируется на резервные серверы. Любые индексы, создаваемые для нежурналируемой таблицы, автоматически становятся нежурналируемыми.</P
></DD
><DT
><TT
CLASS="LITERAL"
>IF NOT EXISTS</TT
></DT
><DD
><P
>Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то соотносится с тем, которое могло бы быть создано.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) создаваемой таблицы.</P
></DD
><DT
><TT
CLASS="LITERAL"
>OF <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
></TT
></DT
><DD
><P
>Создаёт <I
CLASS="FIRSTTERM"
>типизированную таблицу</I
>, структура которой определяется указанным составным типом (его имя может быть дополнено схемой). Типизированная таблица привязана к породившему её типу; например, при удалении типа (командой <TT
CLASS="LITERAL"
>DROP TYPE ... CASCADE</TT
>) будет удалена и эта таблица.</P
><P
>Когда создаётся типизированная таблица, типы данных её колонок определяются нижележащим составным типом, а не задаются командой <TT
CLASS="LITERAL"
>CREATE TABLE</TT
>. Но <TT
CLASS="LITERAL"
>CREATE TABLE</TT
> может добавить в таблицу значения по умолчанию и ограничения, а также задать параметры её хранения.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
></DT
><DD
><P
>Имя колонки, создаваемой в новой таблице.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
></DT
><DD
><P
>Тип данных колонки (может включать определение массива с этим типом). За дополнительными сведениями о типах данных, которые поддерживает <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, обратитесь к <A
HREF="datatype.html"
>Главе 8</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
></TT
></DT
><DD
><P
>Предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> назначает правило сортировки для колонки (которая должна иметь тип, поддерживающий сортировку). Если оно отсутствует, используется правило сортировки по умолчанию, установленное для типа данных колонки.</P
></DD
><DT
><TT
CLASS="LITERAL"
>INHERITS ( <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>Необязательное предложение <TT
CLASS="LITERAL"
>INHERITS</TT
> определяет список таблиц, от которых новая таблица будет автоматически наследовать все колонки.</P
><P
>При использовании <TT
CLASS="LITERAL"
>INHERITS</TT
> создаётся постоянная связь дочерней таблицы с родительскими. Изменения схемы в родительских таблицах обычно также отражаются в дочерних, и по умолчанию при чтении родительских таблиц в результат включаются данные дочерней таблицы.</P
><P
>Когда в нескольких родительских таблицах оказываются колонки с одним именем, происходит ошибка, за исключением случая, когда типы данных всех этих колонок в таблицах совпадают. В этом случае одноимённые колонки объединяются и формируют одну колонку в новой таблице. Если имя колонки новой таблицы совпадает с именем одной из унаследованных колонок, их типы так же должны совпадать, и в этом случае определения колонок тоже сливаются в одну. Если в новой таблице явно указывается значение по умолчанию для новой колонки, это значение переопределяет любые значения по умолчанию, унаследованные этой колонкой. В противном случае, если значения по умолчанию определяются в разных родительских таблицах, эти определения должны совпадать, иначе произойдёт ошибка.</P
><P
>Ограничения <TT
CLASS="LITERAL"
>CHECK</TT
> объединяются вместе по сути так же, как и колонки: если несколько родительских таблиц и/или определение новой таблицы содержат одноимённые ограничения <TT
CLASS="LITERAL"
>CHECK</TT
>, этим ограничениям должны соответствовать одинаковые выражения проверки, в противном случае произойдёт ошибка. В случае совпадения выражения, эти ограничения с данным выражением объединяются в одно. При этом ограничения со свойством <TT
CLASS="LITERAL"
>NO INHERIT</TT
> в родительской таблице исключаются из рассмотрения. Заметьте, что безымянное ограничение <TT
CLASS="LITERAL"
>CHECK</TT
> в новой таблице никогда не сливается с другими, так как для него всегда выбирается уникальное имя.</P
><P
>Параметры <TT
CLASS="LITERAL"
>STORAGE</TT
> для колонки так же копируются из родительских таблиц.</P
></DD
><DT
><TT
CLASS="LITERAL"
>LIKE <TT
CLASS="REPLACEABLE"
><I
>исходная_таблица</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>вариант_копирования</I
></TT
> ... ]</TT
></DT
><DD
><P
>Предложение <TT
CLASS="LITERAL"
>LIKE</TT
> определяет таблицу, из которой в новую таблицу будут автоматически скопированы все имена колонок, их типы данных и их ограничения на NULL.</P
><P
>В отличие от <TT
CLASS="LITERAL"
>INHERITS</TT
>, новая и исходная таблица становятся полностью независимыми после завершения создания. Изменения в исходной таблице не отражаются в новой, а данные новой таблицы не включаются в результат чтения исходной.</P
><P
>Выражения значений по умолчанию в определениях копируемых колонок переносятся в новую таблицу, если дополнительно указано <TT
CLASS="LITERAL"
>INCLUDING DEFAULTS</TT
>. Если такие выражения вызывают функцию, модифицирующие БД, как например, <CODE
CLASS="FUNCTION"
>nextval</CODE
>, при этом создаётся связь исходной таблицы с новой. По умолчанию такие выражения не переносятся, вследствие чего в новой таблице скопированные колонки получают значения по умолчанию NULL.</P
><P
>Ограничения NULL копируются в новую таблицу всегда, а ограничения <TT
CLASS="LITERAL"
>CHECK</TT
> копируются только при явном указании <TT
CLASS="LITERAL"
>INCLUDING CONSTRAINTS</TT
>. Индексы, свойство <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> и ограничения <TT
CLASS="LITERAL"
>UNIQUE</TT
> из исходной таблицы копируются в новую, только если явно указано <TT
CLASS="LITERAL"
>INCLUDING INDEXES</TT
>. Это в равной мере касается как ограничений таблиц, так и колонок.</P
><P
>Параметры <TT
CLASS="LITERAL"
>STORAGE</TT
> будут перенесены в определение копируемых колонок, только если явно указывается <TT
CLASS="LITERAL"
>INCLUDING STORAGE</TT
>. По умолчанию параметры <TT
CLASS="LITERAL"
>STORAGE</TT
> исключаются, вследствие чего скопированные колонки в новой таблице получают параметры по умолчанию, определённые соответствующим типом. Подробнее параметры <TT
CLASS="LITERAL"
>STORAGE</TT
> описаны в <A
HREF="storage-toast.html"
>Разделе 59.2</A
>.</P
><P
>Комментарии для скопированных колонок, ограничений и индексов будут копироваться, только если явно указано <TT
CLASS="LITERAL"
>INCLUDING COMMENTS</TT
>. По умолчанию комментарии исключаются, вследствие чего скопированные колонки и ограничения в новой таблице оказываются без комментариев.</P
><P
>Предложение <TT
CLASS="LITERAL"
>INCLUDING ALL</TT
> является сокращённой формой развёрнутого предложения <TT
CLASS="LITERAL"
>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</TT
>.</P
><P
>Заметьте также, что в отличие от <TT
CLASS="LITERAL"
>INHERITS</TT
>, колонки и ограничения, копируемые командой <TT
CLASS="LITERAL"
>LIKE</TT
> не объединяются с одноимёнными колонками и ограничениями. Если дублирующееся имя указывается явно или возникает в другом предложении <TT
CLASS="LITERAL"
>LIKE</TT
>, происходит ошибка.</P
><P
>Предложение <TT
CLASS="LITERAL"
>LIKE</TT
> может также применяться для копирования колонок из представлений, сторонних таблиц и составных типов. Неприменимые параметры (например, <TT
CLASS="LITERAL"
>INCLUDING INDEXES</TT
> для представления) при этом игнорируются.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
></TT
></DT
><DD
><P
>Необязательное имя колонки или ограничения таблицы. При нарушении ограничения его имя будет выводиться в сообщении об ошибках, так что имена ограничений вида <TT
CLASS="LITERAL"
>колонка должна быть положительной</TT
> могут сообщить полезную информацию об ограничении клиентскому приложению. (Имена ограничений, включающие пробелы, необходимо заключать в двойные кавычки.) Если имя ограничения не указано, система генерирует имя автоматически.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NOT NULL</TT
></DT
><DD
><P
>Данная колонка не принимает значения NULL.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NULL</TT
></DT
><DD
><P
>Данная колонка может содержать значения NULL (по умолчанию).</P
><P
>Это предложение предназначено только для совместимости с нестандартными базами данных SQL. Использовать его в новых приложениях не рекомендуется.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CHECK ( <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ) [ NO INHERIT ]</TT
></DT
><DD
><P
>В ограничении <TT
CLASS="LITERAL"
>CHECK</TT
> задаётся выражение, возвращающее булевский результат, по которому определяется, будет ли успешна операция добавления или изменения для конкретных строк. Операция выполняется успешно, если результат выражения равен TRUE или UNKNOWN. Если же для какой-нибудь строки, задействованной в операции добавления или изменения, будет получен результат FALSE, возникает ошибка, и эта операция не меняет ничего в базе данных. Ограничение-проверка, заданное как ограничение колонки, должно ссылаться только на значение самой колонки, тогда как ограничение на уровне таблицы может ссылаться и на несколько колонок.</P
><P
>В настоящее время выражения <TT
CLASS="LITERAL"
>CHECK</TT
> не могут содержать подзапросы или ссылаться на переменные, кроме как на колонки текущей строки. Также допустима ссылка на системную колонку <TT
CLASS="LITERAL"
>tableoid</TT
>, но не на другие системные колонки.</P
><P
>Ограничение с пометкой <TT
CLASS="LITERAL"
>NO INHERIT</TT
> не будет наследоваться дочерними таблицами.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DEFAULT <TT
CLASS="REPLACEABLE"
><I
>выражение_по_умолчанию</I
></TT
></TT
></DT
><DD
><P
>Предложение <TT
CLASS="LITERAL"
>DEFAULT</TT
> задаёт значение по умолчанию для колонки, в определении которой оно присутствует. Значение задаётся выражением без переменных (подзапросы и перекрёстные ссылки на другие колонки текущей таблицы в нём не допускаются). Тип данных выражения, задающего значение по умолчанию, должен соответствовать типу данных колонки.</P
><P
>Это выражение будет использоваться во всех операциях добавления данных, в которых не задаётся значение данной колонки. Если значение по умолчанию не определено, таким значением будет NULL.</P
></DD
><DT
><TT
CLASS="LITERAL"
>UNIQUE</TT
> (ограничение колонки)<BR><TT
CLASS="LITERAL"
>UNIQUE ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] )</TT
> (ограничение таблицы)</DT
><DD
><P
>Ограничение <TT
CLASS="LITERAL"
>UNIQUE</TT
> определяет, что группа из одной или нескольких колонок таблицы может содержать только уникальные значения. Ограничение уникальности для таблицы ведёт себя точно так же, как ограничение для колонки, но может охватывать несколько колонок.</P
><P
>При проверке ограничения уникальности значения NULL не считаются равными.</P
><P
>В каждом ограничении уникальности для таблицы должен задаваться набор колонок, отличный от набора любого другого ограничения уникальности или первичного ключа в данной таблице. (Иначе это будет одно и то же ограничение, определённое многократно.)</P
></DD
><DT
><TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> (ограничение колонки)<BR><TT
CLASS="LITERAL"
>PRIMARY KEY ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] )</TT
> (ограничение таблицы)</DT
><DD
><P
>Ограничение первичного ключа определяет, что колонка или несколько колонок таблицы могут содержать только уникальные (неповторяющиеся) значения не NULL. С технической стороны <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> представляет собой просто сочетание ограничений <TT
CLASS="LITERAL"
>UNIQUE</TT
> и <TT
CLASS="LITERAL"
>NOT NULL</TT
>, но объявление первичного ключа привносит также метаданные о конструкции схемы, так как первичный ключ подразумевает, что другие таблицы могут ссылаться на этот набор колонок как на уникальный идентификатор строк.</P
><P
>Для таблицы можно определить только один первичный ключ, будь то ограничение для колонки или для таблицы.</P
><P
>В определении первичного ключа должен задаваться набор колонок, отличный от набора любого другого ограничения уникальности, установленного для данной таблицы.</P
></DD
><DT
><A
NAME="SQL-CREATETABLE-EXCLUDE"
></A
><TT
CLASS="LITERAL"
>EXCLUDE [ USING <TT
CLASS="REPLACEABLE"
><I
>метод_индекса</I
></TT
> ] ( <TT
CLASS="REPLACEABLE"
><I
>элемент_исключения</I
></TT
> WITH <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>параметры_индекса</I
></TT
> [ WHERE ( <TT
CLASS="REPLACEABLE"
><I
>предикат</I
></TT
> ) ]</TT
></DT
><DD
><P
>Предложение <TT
CLASS="LITERAL"
>EXCLUDE</TT
> определяет ограничение-исключение, которое гарантирует, что для любых двух строк, сравниваемых по указанным колонкам или выражениям с указанными операторами, результат не будет равен <TT
CLASS="LITERAL"
>TRUE</TT
> для всех сравнений. Если все указанные операторы проверяют равенство, это ограничение равносильно ограничению <TT
CLASS="LITERAL"
>UNIQUE</TT
>, хотя обычное ограничение уникальности будет работать быстрее. С другой стороны, в ограничениях-исключениях можно задавать более общие условия, чем простое условие на равенство. Например, можно задать ограничение, требующее, чтобы никакие две строки в таблице не содержали пересекающихся кругов (см. <A
HREF="datatype-geometric.html"
>Раздел 8.8</A
>), применив оператор <TT
CLASS="LITERAL"
>&amp;&amp;</TT
>.</P
><P
>Ограничения-исключения реализуются с помощью индексов, так что каждый указанный в них оператор должен быть связан с соответствующим классом операторов (см. <A
HREF="indexes-opclass.html"
>Раздел 11.9</A
>) для <TT
CLASS="REPLACEABLE"
><I
>метода_индекса</I
></TT
>. Кроме того, операторы должны быть коммутативными. В каждом <TT
CLASS="REPLACEABLE"
><I
>элементе_исключения</I
></TT
> можно дополнительно указать класс оператора и/или параметры сортировки, подробно описанные в <A
HREF="sql-createindex.html"
>CREATE INDEX</A
>.</P
><P
>Метод индекса должен поддерживать <TT
CLASS="LITERAL"
>amgettuple</TT
> (см. <A
HREF="indexam.html"
>Главу 55</A
>); в настоящее время это означает, что метод <ACRONYM
CLASS="ACRONYM"
>GIN</ACRONYM
> здесь применять нельзя. Хотя в ограничении-исключении можно использовать B-деревья и хеш-индексы, в этом мало смысла, так как такой подход ничем не лучше обычного ограничения уникальности. Так что на практике методом индекса всегда будет <ACRONYM
CLASS="ACRONYM"
>GiST</ACRONYM
> или <ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>.</P
><P
>Параметр <TT
CLASS="REPLACEABLE"
><I
>предикат</I
></TT
> позволяет указать ограничение-исключение для подмножества таблицы; внутри при этом создаётся частичный индекс. Заметьте, что предикат необходимо заключить в скобки.</P
></DD
><DT
><TT
CLASS="LITERAL"
>REFERENCES <TT
CLASS="REPLACEABLE"
><I
>внешняя_таблица</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>внешняя_колонка</I
></TT
> ) ] [ MATCH <TT
CLASS="REPLACEABLE"
><I
>тип_совпадения</I
></TT
> ] [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ]</TT
> (ограничение колонки)<BR><TT
CLASS="LITERAL"
>FOREIGN KEY ( <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [, ... ] ) REFERENCES <TT
CLASS="REPLACEABLE"
><I
>внешняя_таблица</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>внешняя_колонка</I
></TT
> [, ... ] ) ] [ MATCH <TT
CLASS="REPLACEABLE"
><I
>тип_совпадения</I
></TT
> ] [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> ]</TT
> (ограничение таблицы)</DT
><DD
><P
>Эти предложения определяют ограничение внешнего ключа, требующее, чтобы указанная группа из одной или нескольких колонок новой таблицы содержала только такие значения, которым соответствуют значения в заданных внешних колонках некоторой строки во внешней таблице. Если список <TT
CLASS="REPLACEABLE"
><I
>внешних_колонок</I
></TT
> опущен, в качестве него используется первичный ключ <TT
CLASS="REPLACEABLE"
><I
>внешней_таблицы</I
></TT
>. В качестве внешних колонок должны указываться колонки неоткладываемого уникального ограничения или ограничение первичного ключа во внешней таблице. Заметьте, что ограничения внешнего ключа, связывающие временные и постоянные таблицы, определить нельзя.</P
><P
>Значения, вставляемые в ссылающиеся колонки, сверяются со значениями во внешних колонках внешней таблицы с учётом заданного типа совпадения. Возможны три типа совпадения: <TT
CLASS="LITERAL"
>MATCH FULL</TT
> (полное совпадение), <TT
CLASS="LITERAL"
>MATCH PARTIAL</TT
> (частичное совпадение) и тип по умолчанию, <TT
CLASS="LITERAL"
>MATCH SIMPLE</TT
> (простое совпадение). С <TT
CLASS="LITERAL"
>MATCH FULL</TT
> ни одна из колонок многоколоночного внешнего ключа не может содержать NULL, кроме случая, когда все внешние колонки NULL; в этом случае, строка может не иметь соответствия во внешней таблице. С <TT
CLASS="LITERAL"
>MATCH SIMPLE</TT
> любая из колонок внешнего ключа может содержать NULL; при этом строка с NULL в одной из таких колонок может не иметь соответствия во внешней таблице. Тип <TT
CLASS="LITERAL"
>MATCH PARTIAL</TT
> ещё не реализован. (Разумеется, чтобы вопросы со сравнением NULL не возникали, к колонкам, ссылающимся на внешние, можно применить ограничения <TT
CLASS="LITERAL"
>NOT NULL</TT
>.)</P
><P
>Кроме того, при изменении значений во внешних колонках с данными в колонках этой таблицы могут производиться определённые действия. Предложение <TT
CLASS="LITERAL"
>ON DELETE</TT
> задаёт действие, производимое при удалении некоторой строки во внешней таблице. Предложение <TT
CLASS="LITERAL"
>ON UPDATE</TT
> подобным образом задаёт действие, производимое при изменении значения в целевых колонках внешней таблицы. Если строка изменена, но это изменение не затронуло целевые колонки, никакое действие не производится. Ссылочные действия, кроме <TT
CLASS="LITERAL"
>NO ACTION</TT
>, нельзя сделать откладываемыми, даже если ограничение объявлено как откладываемое. Для каждого предложения возможные следующие варианты действий: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>NO ACTION</TT
></DT
><DD
><P
>Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Для отложенных ограничений ошибка произойдёт в момент проверки ограничения, если строки, ссылающиеся на эту запись, по-прежнему будут существовать. Этот вариант действия подразумевается по умолчанию.</P
></DD
><DT
><TT
CLASS="LITERAL"
>RESTRICT</TT
></DT
><DD
><P
>Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Этот вариант подобен <TT
CLASS="LITERAL"
>NO ACTION</TT
>, но эта проверка будет неоткладываемой.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CASCADE</TT
></DT
><DD
><P
>Удалить все строки, ссылающиеся на удаляемую запись, либо поменять значения в ссылающихся колонках на новые значения во внешних колонках, в соответствии с операцией.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET NULL</TT
></DT
><DD
><P
>Установить ссылающиеся колонки равными NULL.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET DEFAULT</TT
></DT
><DD
><P
>Установить в ссылающихся колонках значения по умолчанию. (Если эти значения не равны NULL, во внешней таблице должна быть строка, соответствующая набору значений по умолчанию; в противном случае операция завершится ошибкой.)</P
></DD
></DL
></DIV
><P></P
><P
>Если внешние колонки меняются часто, будет разумным добавить индекс для ссылающихся колонок, чтобы действия по обеспечению ссылочной целостности, связанные с ограничением внешнего ключа, выполнялись более эффективно.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DEFERRABLE</TT
><BR><TT
CLASS="LITERAL"
>NOT DEFERRABLE</TT
></DT
><DD
><P
>Это предложение определяет, может ли ограничение быть отложенным. Неоткладываемое ограничение будет проверяться немедленно после каждой команды. Проверка откладываемых ограничений может быть отложена до завершения транзакции (обычно с помощью команды <A
HREF="sql-set-constraints.html"
>SET CONSTRAINTS</A
>). По умолчанию подразумевается вариант <TT
CLASS="LITERAL"
>NOT DEFERRABLE</TT
>. В настоящее время это предложение принимают только ограничения <TT
CLASS="LITERAL"
>UNIQUE</TT
>, <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>, <TT
CLASS="LITERAL"
>EXCLUDE</TT
> и <TT
CLASS="LITERAL"
>REFERENCES</TT
> (ограничения внешнего ключа). Ограничения <TT
CLASS="LITERAL"
>NOT NULL</TT
> и <TT
CLASS="LITERAL"
>CHECK</TT
> не могут быть отложенными.</P
></DD
><DT
><TT
CLASS="LITERAL"
>INITIALLY IMMEDIATE</TT
><BR><TT
CLASS="LITERAL"
>INITIALLY DEFERRED</TT
></DT
><DD
><P
>Для откладываемых ограничений это предложение определяет, когда ограничение должно проверяться по умолчанию. Ограничение с характеристикой <TT
CLASS="LITERAL"
>INITIALLY IMMEDIATE</TT
> (подразумеваемой по умолчанию) проверяется после каждого оператора. Ограничение <TT
CLASS="LITERAL"
>INITIALLY DEFERRED</TT
>, напротив, проверяется только в конце транзакции. Время проверки ограничения можно изменить явно с помощью команды <A
HREF="sql-set-constraints.html"
>SET CONSTRAINTS</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>WITH ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
>] [, ... ] )</TT
></DT
><DD
><P
>Это предложение определяет необязательные параметры хранения для таблицы или индекса (за подробными сведениями о них обратитесь к <A
HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"
><I
>Параметры хранения</I
></A
>. Предложение <TT
CLASS="LITERAL"
>WITH</TT
> для таблицы может также включать указание <TT
CLASS="LITERAL"
>OIDS=TRUE</TT
> (или просто <TT
CLASS="LITERAL"
>OIDS</TT
>), устанавливающее, что каждая строка таблицы должна иметь собственный OID (Object IDentifier, идентификатор объекта), или указание <TT
CLASS="LITERAL"
>OIDS=FALSE</TT
>, устанавливающее, что строки не содержат OID. Если указание <TT
CLASS="LITERAL"
>OIDS</TT
> отсутствует, значение этого свойства по умолчанию зависит от конфигурационного параметра <A
HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS"
>default_with_oids</A
>. (Если новая таблица унаследована от каких-либо таблиц, имеющих OID, свойство <TT
CLASS="LITERAL"
>OIDS=TRUE</TT
> задаётся принудительно, даже если в команде явно написано <TT
CLASS="LITERAL"
>OIDS=FALSE</TT
>.)</P
><P
>Если явно указано <TT
CLASS="LITERAL"
>OIDS=FALSE</TT
> или это подразумевается, в новой таблице не будут храниться значения OID и новый OID не будет генерироваться для каждой добавляемой в неё строки. Для обычных таблиц такое поведение предпочтительнее, так как оно сокращает потребление OID и тем самым откладывает наложение 32-битного счётчика OID. Как только происходит наложение, значения OID больше нельзя считать уникальными, что делает их значительно менее полезными. К тому же, исключение колонки OID из таблицы сокращает объём, необходимый для хранения таблицы на диске, на 4 байта для каждой строки (на большинстве платформ), что несколько улучшает производительность.</P
><P
>Для удаления данных OID из таблицы после её создания воспользуйтесь командой <A
HREF="sql-altertable.html"
>ALTER TABLE</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>WITH OIDS</TT
><BR><TT
CLASS="LITERAL"
>WITHOUT OIDS</TT
></DT
><DD
><P
>Это устаревшее написание указаний <TT
CLASS="LITERAL"
>WITH (OIDS)</TT
> и <TT
CLASS="LITERAL"
>WITH (OIDS=FALSE)</TT
>, соответственно. Если требуется определить одновременно свойство <TT
CLASS="LITERAL"
>OIDS</TT
> и параметры хранения, необходимо использовать синтаксис <TT
CLASS="LITERAL"
>WITH ( ... )</TT
>; см. ниже.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ON COMMIT</TT
></DT
><DD
><P
>Поведением временных таблиц в конце блока транзакции позволяет управлять предложение <TT
CLASS="LITERAL"
>ON COMMIT</TT
>, которое принимает три параметра: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>PRESERVE ROWS</TT
></DT
><DD
><P
>Никакое специальное действие в конце транзакции не выполняется. Это поведение по умолчанию.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DELETE ROWS</TT
></DT
><DD
><P
>Все строки в этой временной таблице будут удаляться в конце каждого блока транзакции. По сути, при каждой фиксации транзакции будет автоматически выполняться <A
HREF="sql-truncate.html"
>TRUNCATE</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DROP</TT
></DT
><DD
><P
>Эта временная таблица будет удаляться в конце текущего блока транзакции.</P
></DD
></DL
></DIV
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
></TT
></DT
><DD
><P
>Здесь <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
> — имя табличного пространства, в котором будет создаваться новая таблица. Если оно не указано, выбирается <A
HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE"
>default_tablespace</A
> или <A
HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES"
>temp_tablespaces</A
>, если таблица временная.</P
></DD
><DT
><TT
CLASS="LITERAL"
>USING INDEX TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>табл_пространство</I
></TT
></TT
></DT
><DD
><P
>Это предложение позволяет выбрать табличное пространство, в котором будут создаваться индексы, связанные с ограничениями <TT
CLASS="LITERAL"
>UNIQUE</TT
>, <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> или <TT
CLASS="LITERAL"
>EXCLUDE</TT
>. Если оно не указано, выбирается <A
HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE"
>default_tablespace</A
> или <A
HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES"
>temp_tablespaces</A
>, если таблица временная.</P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETABLE-STORAGE-PARAMETERS"
></A
><H3
>Параметры хранения</H3
><P
>Предложение <TT
CLASS="LITERAL"
>WITH</TT
> позволяет установить <I
CLASS="FIRSTTERM"
>параметры хранения</I
> для таблиц и индексов, связанных с ограничениями <TT
CLASS="LITERAL"
>UNIQUE</TT
>, <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> и <TT
CLASS="LITERAL"
>EXCLUDE</TT
>. Параметры хранения для индексов документированы в <A
HREF="sql-createindex.html"
>CREATE INDEX</A
>. Поддерживаемые в настоящее время параметры хранения для таблиц перечислены ниже. Для каждого параметра, если не указано другое, существует дополнительный параметр с тем же именем и префиксом <TT
CLASS="LITERAL"
>toast.</TT
>, который может управлять поведением вторичной таблицей <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, если она есть (за дополнительными сведениями о TOAST обратитесь к <A
HREF="storage-toast.html"
>Разделу 59.2</A
>). Учтите, что таблица TOAST наследует значения параметров <TT
CLASS="LITERAL"
>autovacuum_*</TT
> от родительского отношения, если параметры <TT
CLASS="LITERAL"
>toast.autovacuum_*</TT
> не определены.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>fillfactor</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Фактор заполнения для таблицы, задаваемый в процентах, от 10 до 100. Значение по умолчанию — 100 (плотное заполнение). При меньшем факторе заполнения операции <TT
CLASS="COMMAND"
>INSERT</TT
> упаковывают данные в страницы только до заданного процента; оставшееся место резервируется для изменения строк на этой странице. В результате <TT
CLASS="COMMAND"
>UPDATE</TT
> получает шанс поместить изменённую копию строки в ту же страницу, что и исходную, что гораздо эффективнее, чем размещать её на другой странице. Для таблиц, записи в которых никогда не меняются, лучшим выбором будет плотное заполнение, но для активно изменяемых таблиц лучше выбрать меньший фактор заполнения. Этот параметр нельзя задать для таблиц TOAST.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_enabled</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_enabled</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>Включает или отключает демон автоочистки для конкретной таблицы. При значении true демон автоочистки будет выполнять операцию <TT
CLASS="COMMAND"
>VACUUM</TT
> для этой таблицы, когда число изменённых или удалённых кортежей превысит <TT
CLASS="LITERAL"
>autovacuum_vacuum_threshold</TT
> плюс <TT
CLASS="LITERAL"
>autovacuum_vacuum_scale_factor</TT
>, помноженный на примерно оцениваемое число актуальных кортежей в отношении. Подобным образом, при включённой автоочистке будет выполняться операция <TT
CLASS="COMMAND"
>ANALYZE</TT
>, когда число добавленных, изменённых или удалённых кортежей превышает <TT
CLASS="LITERAL"
>autovacuum_analyze_threshold</TT
> плюс <TT
CLASS="LITERAL"
>autovacuum_analyze_scale_factor</TT
>, помноженный на примерно оцениваемое число актуальных кортежей в отношении. При значении false эта таблица не будет подлежать автоочистке, за исключением случаев, когда автоочистка потребуется для предотвращения наложений идентификаторов транзакций. Подробнее о предотвращении наложений транзакций можно узнать в <A
HREF="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND"
>Подразделе 23.1.5</A
>. Заметьте, что эта переменная наследует своё значение от параметра <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM"
>autovacuum</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_vacuum_threshold</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_vacuum_threshold</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Минимальное число изменённых или удалённых кортежей, при котором будет запускаться операция <TT
CLASS="COMMAND"
>VACUUM</TT
> для данной таблицы.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_vacuum_scale_factor</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_vacuum_scale_factor</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</DT
><DD
><P
>Множитель для <TT
CLASS="STRUCTFIELD"
>reltuples</TT
> (произведение складывается с <TT
CLASS="LITERAL"
>autovacuum_vacuum_threshold</TT
>).</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_analyze_threshold</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Минимальное число добавленных, изменённых или удалённых кортежей, при котором будет запускаться операция <TT
CLASS="COMMAND"
>ANALYZE</TT
> для данной таблицы.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_analyze_scale_factor</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</DT
><DD
><P
>Множитель для <TT
CLASS="STRUCTFIELD"
>reltuples</TT
> (произведение складывается с <TT
CLASS="LITERAL"
>autovacuum_analyze_threshold</TT
>).</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_vacuum_cost_delay</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_vacuum_cost_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-DELAY"
>autovacuum_vacuum_cost_delay</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_vacuum_cost_limit</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_vacuum_cost_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT"
>autovacuum_vacuum_cost_limit</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_freeze_min_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_freeze_min_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE"
>vacuum_freeze_min_age</A
>. Учтите, что система автоочистки будет игнорировать попытки установить для таблицы значение <TT
CLASS="LITERAL"
>autovacuum_freeze_min_age</TT
>, превышающее половину системного <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE"
>autovacuum_freeze_max_age</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_freeze_max_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_freeze_max_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE"
>autovacuum_freeze_max_age</A
>. Заметьте, что система автоочистки будет игнорировать попытки установить для таблицы значение <TT
CLASS="LITERAL"
>autovacuum_freeze_max_age</TT
>, превышающее системное (оно может быть только меньше). И хотя вы можете задать для <TT
CLASS="LITERAL"
>autovacuum_freeze_max_age</TT
> очень маленькое значение, даже 0, обычно это неразумно, так как повлечёт за собой слишком частую очистку.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_freeze_table_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_freeze_table_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE"
>vacuum_freeze_table_age</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_min_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_multixact_freeze_min_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE"
>vacuum_multixact_freeze_min_age</A
>. Учтите, что система автоочистки будет игнорировать попытки установить для таблицы значение <TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_min_age</TT
>, превышающее половину системного <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"
>autovacuum_multixact_freeze_max_age</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_max_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_multixact_freeze_max_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"
>autovacuum_multixact_freeze_max_age</A
>. Учтите, что система автоочистки будет игнорировать попытки установить для таблицы значение <TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_max_age</TT
>, превышающее системное (оно может быть только меньше). И хотя вы можете задать для <TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_max_age</TT
> очень маленькое значение, даже 0, обычно это неразумно, так как повлечёт за собой слишком частую очистку.</P
></DD
><DT
><TT
CLASS="LITERAL"
>autovacuum_multixact_freeze_table_age</TT
>, <TT
CLASS="LITERAL"
>toast.autovacuum_multixact_freeze_table_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>Пользовательский параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE"
>vacuum_multixact_freeze_table_age</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>user_catalog_table</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>Объявить таблицу как дополнительную таблицу каталога, например, для целей логической репликации. За подробностями обратитесь к <A
HREF="logicaldecoding-output-plugin.html#LOGICALDECODING-CAPABILITIES"
>Подразделу 46.6.2</A
>.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETABLE-NOTES"
></A
><H2
>Замечания</H2
><P
>Применять OID в новых приложениях не рекомендуется: по возможности лучше использовать в качестве первичного ключа таблицы <TT
CLASS="LITERAL"
>SERIAL</TT
> или другой генератор последовательности. Однако, если в вашем приложении для идентификации строк применяется OID, рекомендуется создать уникальное ограничение по колонке <TT
CLASS="STRUCTFIELD"
>oid</TT
> в этой таблице, чтобы значения OID в этой таблице на самом деле однозначно идентифицировали строки даже после зацикливания счётчика. Также не стоит полагать, что значения OID уникальны в разных таблицах; если вам требуется идентификатор, уникальный в базе данных, воспользуйтесь для этого комбинацией <TT
CLASS="STRUCTFIELD"
>tableoid</TT
> и OID строки.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Применять <TT
CLASS="LITERAL"
>OIDS=FALSE</TT
> не рекомендуется для таблиц без первичного ключа, так как без OID или уникального ключа данных сложно идентифицировать определённые строки.</P
></BLOCKQUOTE
></DIV
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> автоматически создаёт индекс, гарантирующий уникальность, для каждого ограничения уникальности и ограничения первичного ключа. Поэтому явно создавать индекс для колонок первичного ключа не требуется. (За дополнительными сведениями обратитесь к <A
HREF="sql-createindex.html"
>CREATE INDEX</A
>.)</P
><P
>Ограничения уникальности и первичные ключи в текущей реализации не наследуются. Вследствие этого ограничения уникальности довольно плохо сочетаются с наследованием.</P
><P
>В таблице не может быть больше 1600 колонок. (На практике фактический предел обычно ниже из-за ограничения на длину записи.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETABLE-EXAMPLES"
></A
><H2
>Примеры</H2
><P
>Создание таблицы <TT
CLASS="STRUCTNAME"
>films</TT
> и таблицы <TT
CLASS="STRUCTNAME"
>distributors</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</PRE
><P></P
><P
>Создание таблицы с двумерным массивом: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE array_int (
    vector  int[][]
);</PRE
><P></P
><P
>Определение ограничения уникальности для таблицы <TT
CLASS="LITERAL"
>films</TT
>. Ограничения уникальности могут быть определены для одной или нескольких колонок таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);</PRE
><P></P
><P
>Определение ограничения-проверки для колонки: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);</PRE
><P></P
><P
>Определение ограничения-проверки для таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);</PRE
><P></P
><P
>Определение ограничения первичного ключа для таблицы <TT
CLASS="STRUCTNAME"
>films</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);</PRE
><P></P
><P
>Определение ограничения первичного ключа для таблицы <TT
CLASS="STRUCTNAME"
>distributors</TT
>. Следующие два примера равнозначны, но в первом используется синтаксис ограничений для таблицы, а во втором — для колонки: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);</PRE
><P></P
><P
>Определение значений по умолчанию: для колонки <TT
CLASS="LITERAL"
>name</TT
> значением по умолчанию будет строка, для колонки <TT
CLASS="LITERAL"
>did</TT
> — следующее значение объекта последовательности, а для <TT
CLASS="LITERAL"
>modtime</TT
> — время, когда была вставлена запись: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);</PRE
><P></P
><P
>Определение двух ограничений <TT
CLASS="LITERAL"
>NOT NULL</TT
> для колонок таблицы <CODE
CLASS="CLASSNAME"
>distributors</CODE
>, одному из которых даётся явное имя: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);</PRE
><P></P
><P
>Определение ограничения уникальности для колонки <TT
CLASS="LITERAL"
>name</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);</PRE
><P> То же самое условие, но в виде ограничения таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);</PRE
><P></P
><P
>Создание такой же таблицы с фактором заполнения 70% для таблицы и её уникального индекса: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);</PRE
><P></P
><P
>Создание таблицы <TT
CLASS="STRUCTNAME"
>circles</TT
> с ограничением-исключением, не допускающим пересечения двух кругов: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);</PRE
><P></P
><P
>Создание таблицы <TT
CLASS="STRUCTNAME"
>cinemas</TT
> в табличном пространстве <TT
CLASS="STRUCTNAME"
>diskvol1</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;</PRE
><P></P
><P
>Создание составного типа и типизированной таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETABLE-COMPATIBILITY"
></A
><H2
>Совместимость</H2
><P
>Команда <TT
CLASS="COMMAND"
>CREATE TABLE</TT
> соответствует стандарту <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, с описанными ниже исключениями.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76292"
></A
><H3
>Временные таблицы</H3
><P
>Хотя синтаксис <TT
CLASS="LITERAL"
>CREATE TEMPORARY TABLE</TT
> подобен аналогичному в стандарте SQL, результат получается другим. В стандарте временные таблицы определяются только один раз и существуют (изначально пустые) в каждом сеансе, в котором они используются. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> вместо этого требует, чтобы каждый сеанс выполнял собственную команду <TT
CLASS="LITERAL"
>CREATE TEMPORARY TABLE</TT
> для каждой временной таблицы, которая будет использоваться. Это позволяет использовать в разных сеансах таблицы с одинаковыми именами для разных целей, тогда как при подходе, регламентированном стандартом, все экземпляры временной таблицы с одним именем должны иметь одинаковую табличную структуру.</P
><P
>Поведение временных таблиц, описанное в стандарте, в большинстве своём игнорируют и другие СУБД, так что в этом отношении <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> ведёт себя так же, как и ряд других СУБД.</P
><P
>В стандарте SQL также разделяются глобальные и локальные временные таблицы — в локальной временной таблице содержится отдельный набор данных для каждого модуля SQL в отдельном сеансе, хотя её определение так же разделяется между ними. Так как в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> модули SQL не поддерживаются, это различие в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не существует.</P
><P
>Совместимости ради, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> принимает ключевые слова <TT
CLASS="LITERAL"
>GLOBAL</TT
> и <TT
CLASS="LITERAL"
>LOCAL</TT
> в объявлении временной таблицы, но в настоящее время они никак не действуют. Использовать их не рекомендуется, так как в будущих версиях <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может быть принята их интерпретация, более близкая к стандарту.</P
><P
>Предложение <TT
CLASS="LITERAL"
>ON COMMIT</TT
> для временных таблиц тоже подобно описанному в стандарте SQL, но есть некоторые отличия. Если предложение <TT
CLASS="LITERAL"
>ON COMMIT</TT
> опущено, в SQL подразумевается поведение <TT
CLASS="LITERAL"
>ON COMMIT DELETE ROWS</TT
>. Однако в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> по умолчанию действует <TT
CLASS="LITERAL"
>ON COMMIT PRESERVE ROWS</TT
>. Параметр <TT
CLASS="LITERAL"
>ON COMMIT DROP</TT
> в стандарте SQL отсутствует.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76315"
></A
><H3
>Неотложенные ограничения уникальности</H3
><P
>Когда ограничение <TT
CLASS="LITERAL"
>UNIQUE</TT
> или <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> не является отложенным, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> проверяет уникальность непосредственно в момент добавления или изменения строки. Стандарт SQL говорит, что уникальность должна обеспечиваться только в конце оператора; это различие проявляется, например когда одна команда изменяет множество ключевых значений. Чтобы получить поведение, оговоренное стандартом, объявите ограничение как откладываемое (<TT
CLASS="LITERAL"
>DEFERRABLE</TT
>), но не отложенное (т. е., <TT
CLASS="LITERAL"
>INITIALLY IMMEDIATE</TT
>). Учтите, что этот вариант может быть значительно медленнее, чем немедленная проверка ограничений.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76323"
></A
><H3
>Ограничения-проверки для колонок</H3
><P
>Стандарт SQL говорит, что ограничение <TT
CLASS="LITERAL"
>CHECK</TT
>, определяемое для колонки, может ссылаться только на колонку, с которой оно связано; только ограничения <TT
CLASS="LITERAL"
>CHECK</TT
> для таблиц могут ссылаться на несколько колонок. В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> этого ограничения нет; он воспринимает ограничения-проверки для колонок и таблиц одинаково.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76329"
></A
><H3
>Ограничение <TT
CLASS="LITERAL"
>EXCLUDE</TT
></H3
><P
>Ограничения <TT
CLASS="LITERAL"
>EXCLUDE</TT
> являются расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76335"
></A
><H3
><TT
CLASS="LITERAL"
>NULL</TT
> <SPAN
CLASS="QUOTE"
>"Ограничение"</SPAN
></H3
><P
><SPAN
CLASS="QUOTE"
>"Ограничение"</SPAN
> <TT
CLASS="LITERAL"
>NULL</TT
> (на самом деле это не ограничение) является расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> стандарта SQL, которое реализовано для совместимости с некоторыми другими СУБД (и для симметрии с ограничением <TT
CLASS="LITERAL"
>NOT NULL</TT
>). Так как это поведение по умолчанию для любой колонки, его присутствие не несёт смысловой нагрузки.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76344"
></A
><H3
>Наследование</H3
><P
>Множественное наследование посредством <TT
CLASS="LITERAL"
>INHERITS</TT
> является языковым расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. SQL:1999 и более поздние стандарты определяют единичное наследование с другим синтаксисом и смыслом. Наследование в стиле SQL:1999 пока ещё не поддерживается в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76350"
></A
><H3
>Таблицы с нулём колонок</H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет создать таблицу без колонок (например, <TT
CLASS="LITERAL"
>CREATE TABLE foo();</TT
>). Это расширение стандарта SQL, который не допускает таблицы с нулём колонок. Таблицы с нулём колонок сами по себе не очень полезны, но если их запретить, возникают странные особые ситуации с командой <TT
CLASS="COMMAND"
>ALTER TABLE DROP COLUMN</TT
>, так что лучшим вариантом кажется игнорировать это требование стандарта.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76356"
></A
><H3
>Предложение <TT
CLASS="LITERAL"
>WITH</TT
></H3
><P
>Предложение <TT
CLASS="LITERAL"
>WITH</TT
> является расширением <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>; в стандарте ни параметры хранения, ни OID не оговариваются.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76362"
></A
><H3
>Табличные пространства</H3
><P
>Концепция табличных пространств в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> отсутствует в стандарте. Как следствие, предложения <TT
CLASS="LITERAL"
>TABLESPACE</TT
> и <TT
CLASS="LITERAL"
>USING INDEX TABLESPACE</TT
> являются расширениями.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN76368"
></A
><H3
>Типизированные таблицы</H3
><P
>Типизированные таблицы реализуют подмножество стандарта SQL. Согласно стандарту, типизированная таблица содержит колонки, соответствующие нижележащему составному типу, и ещё одну колонку, ссылающуюся на себя. PostgreSQL не поддерживает ссылающиеся на себя колонки явно, но тот же эффект можно получить, воспользовавшись OID.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76371"
></A
><H2
>См. также</H2
><A
HREF="sql-altertable.html"
>ALTER TABLE</A
>, <A
HREF="sql-droptable.html"
>DROP TABLE</A
>, <A
HREF="sql-createtableas.html"
>CREATE TABLE AS</A
>, <A
HREF="sql-createtablespace.html"
>CREATE TABLESPACE</A
>, <A
HREF="sql-createtype.html"
>CREATE TYPE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createserver.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createtableas.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE SERVER</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE TABLE AS</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>