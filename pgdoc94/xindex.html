<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Интерфейсы расширений для индексов</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Расширение SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Информация для оптимизации операторов"
HREF="xoper-optimization.html"><LINK
REL="NEXT"
TITLE="Упаковывание связанных объектов в расширение"
HREF="extend-extensions.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Информация для оптимизации операторов"
HREF="xoper-optimization.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 35. Расширение <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Упаковывание связанных объектов в расширение"
HREF="extend-extensions.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XINDEX"
>35.14. Интерфейсы расширений для индексов</A
></H1
><P
>Описанные до этого процедуры позволяли определять новые типы, функции и операторы. Однако, мы ещё не можем определить индекс по колонке нового типа данных. Для этого нам потребуется создать <I
CLASS="FIRSTTERM"
>класс операторов</I
> для нового типа данных. Далее в этом разделе мы продемонстрируем эту концепцию на примере: мы создадим новый класс операторов для метода индекса-B-дерева, в котором будут храниться комплексные числа и сортироваться по возрастанию абсолютного значения.</P
><P
>Классы операторов могут объединяться в <I
CLASS="FIRSTTERM"
>семейства операторов</I
>, выражающие зависимости между семантически совместимыми классами. Когда вводится один тип данных, достаточно класса операторов, так что мы начнём с него, а к семействам операторов вернёмся позже.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-OPCLASS"
>35.14.1. Методы индексов и классы операторов</A
></H2
><P
>В системном каталоге есть таблица <CODE
CLASS="CLASSNAME"
>pg_am</CODE
>, содержащая записи для каждого метода индекса (внутри называемого методом доступа). Поддержка обычного доступа к таблицам встроена в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, но все методы доступа по индексам описываются в <CODE
CLASS="CLASSNAME"
>pg_am</CODE
>. Система позволяет добавлять новые методы индексов — для этого нужно реализовать требуемые интерфейсом функции, а затем добавить запись в <CODE
CLASS="CLASSNAME"
>pg_am</CODE
>, но это выходит за рамки данной главы (см. <A
HREF="indexam.html"
>Главу 55</A
>).</P
><P
>Процедуры метода индекса непосредственно ничего не знают о типах данных, с которыми будет применяться этот метод. Вместо этого, набор операций, которые нужны методу индекса для работы с конкретным типом данных, определяется <I
CLASS="FIRSTTERM"
>классом операторов</I
>. Классы операторов называются так потому, что они определяют множество операторов в предложении <TT
CLASS="LITERAL"
>WHERE</TT
>, которые могут использоваться с индексом (т. е. могут быть сведены к сканированию индекса). В классе операторов могут также определяться некоторые <I
CLASS="FIRSTTERM"
>опорные процедуры</I
>, которые нужны для внутренних операций метода индекса, но они не соответствуют напрямую каким-либо операторам предложения <TT
CLASS="LITERAL"
>WHERE</TT
>, которые могут обрабатываться с индексом.</P
><P
>Для одного типа данных и метода индекса можно определить несколько классов операторов. Благодаря этому, для одного типа данных можно использовать несколько семантически разных вариантов индексирования. Например, индекс-B-дерево требует, чтобы для каждого типа данных, с которым он работает, определялся порядок сортировки. Для типа комплексных чисел может быть полезен класс операторов B-дерева, сортирующий данные по модулю комплексного числа, и ещё один, сортирующий по вещественной части, и т. п. Обычно предполагается, что один из классов операторов будет применяться чаще других, и тогда он помечается как класс по умолчанию для данного типа и метода индекса.</P
><P
>Одно и то же имя класса операторов может использоваться для разных методов индекса (например, для методов индекса-B-дерева или хеш-индекса применяются классы операторов <TT
CLASS="LITERAL"
>int4_ops</TT
>), но все такие классы являются независимыми и должны определяться отдельно.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-STRATEGIES"
>35.14.2. Стратегии методов индексов</A
></H2
><P
>Операторам, которые связываются с классом операторов, назначаются <SPAN
CLASS="QUOTE"
>"номера стратегий"</SPAN
>, определяющие роль каждого оператора в контексте его класса. Например, в B-дереве должен быть строгий порядок ключей с отношениями меньше/больше, так что в данном контексте представляют интерес операторы <SPAN
CLASS="QUOTE"
>"меньше"</SPAN
> и <SPAN
CLASS="QUOTE"
>"больше или равно"</SPAN
>. Так как <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет пользователям определять операторы произвольным образом, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не может просто посмотреть на имя оператора (<TT
CLASS="LITERAL"
>&lt;</TT
> или <TT
CLASS="LITERAL"
>&gt;=</TT
>) и сказать, какое сравнение он выполняет. Вместо этого для метода индекса определяется набор <SPAN
CLASS="QUOTE"
>"стратегий"</SPAN
>, которые можно считать обобщёнными операторами. Каждый класс операторов устанавливает, какие фактические операторы соответствуют стратегиям для определённого типа данных и интерпретации семантики индекса.</P
><P
>Для метода индекса-B-дерева определены пять стратегий, описанных в <A
HREF="xindex.html#XINDEX-BTREE-STRAT-TABLE"
>Таблице 35-2</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-BTREE-STRAT-TABLE"
></A
><P
><B
>Таблица 35-2. Стратегии B-дерева</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Операция</TH
><TH
>Номер стратегии</TH
></TR
></THEAD
><TBODY
><TR
><TD
>меньше</TD
><TD
>1</TD
></TR
><TR
><TD
>меньше или равно</TD
><TD
>2</TD
></TR
><TR
><TD
>равно</TD
><TD
>3</TD
></TR
><TR
><TD
>больше или равно</TD
><TD
>4</TD
></TR
><TR
><TD
>больше</TD
><TD
>5</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Индексы по хешу поддерживают только сравнение на равенство, так что они используют только одну стратегию, показанную в <A
HREF="xindex.html#XINDEX-HASH-STRAT-TABLE"
>Таблице 35-3</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-HASH-STRAT-TABLE"
></A
><P
><B
>Таблица 35-3. Стратегии хеша</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Операция</TH
><TH
>Номер стратегии</TH
></TR
></THEAD
><TBODY
><TR
><TD
>равно</TD
><TD
>1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Индексы GiST более гибкие: для них вообще нет фиксированного набора стратегий. Вместо этого опорная процедура <SPAN
CLASS="QUOTE"
>"согласованности"</SPAN
> каждого конкретного класса операторов GiST интерпретирует номера стратегий как ей угодно. Например, некоторые из встроенных классов операторов для индексов GiST индексируют двумерные геометрические объекты, и реализуют стратегии <SPAN
CLASS="QUOTE"
>"R-дерева"</SPAN
>, показанные в <A
HREF="xindex.html#XINDEX-RTREE-STRAT-TABLE"
>Таблице 35-4</A
>. Четыре из них являются истинно двумерными проверками (overlaps, same, contains, contained by); другие четыре учитывают только ординаты, а ещё четыре проводят же проверки только с абсциссами.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-RTREE-STRAT-TABLE"
></A
><P
><B
>Таблица 35-4. Стратегии двумерного <SPAN
CLASS="QUOTE"
>"R-дерева"</SPAN
> индекса GiST</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Операция</TH
><TH
>Номер стратегии</TH
></TR
></THEAD
><TBODY
><TR
><TD
>строго слева от</TD
><TD
>1</TD
></TR
><TR
><TD
>не простирается правее</TD
><TD
>2</TD
></TR
><TR
><TD
>пересекается с</TD
><TD
>3</TD
></TR
><TR
><TD
>не простирается левее</TD
><TD
>4</TD
></TR
><TR
><TD
>строго справа от</TD
><TD
>5</TD
></TR
><TR
><TD
>одинаковы</TD
><TD
>6</TD
></TR
><TR
><TD
>содержит</TD
><TD
>7</TD
></TR
><TR
><TD
>содержится в</TD
><TD
>8</TD
></TR
><TR
><TD
>не простирается выше</TD
><TD
>9</TD
></TR
><TR
><TD
>строго ниже</TD
><TD
>10</TD
></TR
><TR
><TD
>строго выше</TD
><TD
>11</TD
></TR
><TR
><TD
>не простирается ниже</TD
><TD
>12</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <A
HREF="xindex.html#XINDEX-SPGIST-POINT-STRAT-TABLE"
>Таблице 35-5</A
> приведены номера стратегий, установленные для встроенных классов операторов для точек.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-SPGIST-POINT-STRAT-TABLE"
></A
><P
><B
>Таблица 35-5. Стратегии SP-GiST для точек</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Операция</TH
><TH
>Номер стратегии</TH
></TR
></THEAD
><TBODY
><TR
><TD
>строго слева от</TD
><TD
>1</TD
></TR
><TR
><TD
>строго справа от</TD
><TD
>5</TD
></TR
><TR
><TD
>одинаковы</TD
><TD
>6</TD
></TR
><TR
><TD
>содержится в</TD
><TD
>8</TD
></TR
><TR
><TD
>строго ниже</TD
><TD
>10</TD
></TR
><TR
><TD
>строго выше</TD
><TD
>11</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <A
HREF="xindex.html#XINDEX-GIN-ARRAY-STRAT-TABLE"
>Таблице 35-6</A
> приведены номера стратегий, установленные для встроенных классов операторов для массивов.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-GIN-ARRAY-STRAT-TABLE"
></A
><P
><B
>Таблица 35-6. Стратегии GIN для массивов</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Операция</TH
><TH
>Номер стратегии</TH
></TR
></THEAD
><TBODY
><TR
><TD
>пересекается с</TD
><TD
>1</TD
></TR
><TR
><TD
>содержит</TD
><TD
>2</TD
></TR
><TR
><TD
>содержится в</TD
><TD
>3</TD
></TR
><TR
><TD
>равно</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На практике все операторы, определённые как операторы поиска для метода индекса, должны возвращать тип <TT
CLASS="TYPE"
>boolean</TT
>, так как они должны находиться на верхнем уровне предложения <TT
CLASS="LITERAL"
>WHERE</TT
>, чтобы для них применялся индекс. (Некоторые методы доступа по индексу также поддерживают <I
CLASS="FIRSTTERM"
>операторы упорядочивания</I
>, которые обычно не возвращают булевы значения; это обсуждается в <A
HREF="xindex.html#XINDEX-ORDERING-OPS"
>Подразделе 35.14.7</A
>.)</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-SUPPORT"
>35.14.3. Опорные процедуры метода индекса</A
></H2
><P
>Стратегии обычно не дают системе достаточно информации, чтобы понять, как использовать индекс. На практике, чтобы методы индекса работали, необходимы дополнительные опорные процедуры. Например, метод индекса-B-дерева должен уметь сравнивать два ключа и определять, больше, равен или меньше ли первый второго. Аналогично, метод индекса по хешу должен уметь сравнивать хеш-коды значений ключа. Эти операции не соответствуют операторам, которые применяются в условиях в командах SQL; это внутрисистемные подпрограммы, используемые методами индекса.</P
><P
>Так же, как и со стратегиями, класс операторов определяет, какие конкретные функции должны играть каждую из ролей для определённого типа данных и интерпретации семантики индекса. Для метода индекса определяется набор нужных ему функций, а класс оператора выбирает нужные функции для применения, назначая им <SPAN
CLASS="QUOTE"
>"номера опорных функций"</SPAN
>, определяемые методом индекса.</P
><P
>Для B-деревьев требуется одна опорная функция, а вторая задаётся по выбору автора класса операторов, как показано в <A
HREF="xindex.html#XINDEX-BTREE-SUPPORT-TABLE"
>Таблице 35-7</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-BTREE-SUPPORT-TABLE"
></A
><P
><B
>Таблица 35-7. Опорные функции B-деревьев</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Номер опорной функции</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</TD
><TD
>1</TD
></TR
><TR
><TD
>Возвращает адрес вызываемой из C функции(й), поддерживающей сортировку, как описано в <TT
CLASS="FILENAME"
>utils/sortsupport.h</TT
> (необязательно)</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Для хеш-индексов требуется одна опорная функция, указанная в <A
HREF="xindex.html#XINDEX-HASH-SUPPORT-TABLE"
>Таблице 35-8</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-HASH-SUPPORT-TABLE"
></A
><P
><B
>Таблица 35-8. Опорные функции хеша</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Номер опорной функции</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Вычисляет значение хеша для ключа</TD
><TD
>1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Для индексов GiST требуются семь опорных функций, с необязательной восьмой; они описаны в <A
HREF="xindex.html#XINDEX-GIST-SUPPORT-TABLE"
>Таблице 35-9</A
>. (За дополнительными сведениями обратитесь к <A
HREF="gist.html"
>Главе 56</A
>.)</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-GIST-SUPPORT-TABLE"
></A
><P
><B
>Таблица 35-9. Опорные функции GiST</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Описание</TH
><TH
>Номер опорной функции</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>consistent</CODE
>
                  </TD
><TD
>определяет, удовлетворяет ли ключ условию запроса</TD
><TD
>1</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>union</CODE
>
                  </TD
><TD
>вычисляет объединение набора ключей</TD
><TD
>2</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>compress</CODE
>
                  </TD
><TD
>вычисляет сжатое представление ключа или индексируемого значения</TD
><TD
>3</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>decompress</CODE
>
                  </TD
><TD
>вычисляет развёрнутое представление сжатого ключа</TD
><TD
>4</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>penalty</CODE
>
                  </TD
><TD
>вычисляет стоимость добавления нового ключа в поддерево с заданным ключом</TD
><TD
>5</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>picksplit</CODE
>
                  </TD
><TD
>определяет, какие записи страницы должны быть перемещены в новую страницу, и вычисляет ключи объединения для результирующих страниц</TD
><TD
>6</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>equal</CODE
>
                  </TD
><TD
>сравнивает два ключа и возвращает true, если они равны</TD
><TD
>7</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>distance</CODE
>
                  </TD
><TD
>определяет дистанцию от ключа до искомого значения (необязательно)</TD
><TD
>8</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Для индексов SP-GiST требуются пять опорных функций, описанных в <A
HREF="xindex.html#XINDEX-SPGIST-SUPPORT-TABLE"
>Таблице 35-10</A
>. (За дополнительными сведениями обратитесь к <A
HREF="spgist.html"
>Главе 57</A
>.)</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-SPGIST-SUPPORT-TABLE"
></A
><P
><B
>Таблица 35-10. Опорные функции SP-GiST</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Описание</TH
><TH
>Номер опорной функции</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>config</CODE
>
                  </TD
><TD
>предоставляет основную информацию о классе операторов</TD
><TD
>1</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>choose</CODE
>
                  </TD
><TD
>определяет, как вставить новое значение во внутренний элемент</TD
><TD
>2</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>picksplit</CODE
>
                  </TD
><TD
>определяет, как разделить множество значений</TD
><TD
>3</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>
                  </TD
><TD
>определяет, в каких внутренних ветвях нужно искать заданное значение</TD
><TD
>4</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>leaf_consistent</CODE
>
                  </TD
><TD
>определяет, удовлетворяет ли ключ условию запроса</TD
><TD
>5</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Для индексов GIN требуются четыре опорных функции, с необязательной пятой; они описаны в <A
HREF="xindex.html#XINDEX-GIN-SUPPORT-TABLE"
>Таблице 35-11</A
>. (За дополнительными сведениями обратитесь к <A
HREF="gin.html"
>Главе 58</A
>.)</P
><DIV
CLASS="TABLE"
><A
NAME="XINDEX-GIN-SUPPORT-TABLE"
></A
><P
><B
>Таблица 35-11. Опорные функции GIN</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Функция</TH
><TH
>Описание</TH
><TH
>Номер опорной функции</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>compare</CODE
>
                  </TD
><TD
>сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</TD
><TD
>1</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>extractValue</CODE
>
                  </TD
><TD
>извлекает ключи из индексируемого значения</TD
><TD
>2</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>extractQuery</CODE
>
                  </TD
><TD
>извлекает ключи из условия запроса</TD
><TD
>3</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>consistent</CODE
>
                  </TD
><TD
>определяет, соответствует ли значение условию запроса (булевская вариация) (не требуется, если присутствует опорная функция 6)</TD
><TD
>4</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>comparePartial</CODE
>
                  </TD
><TD
>сравнивает частичный ключ из запроса с ключом из индекса и возвращает целое число меньше нуля, ноль или больше нуля, показывающее, что GIN должен игнорировать эту запись индекса, принять её как соответствующую или прекратить сканирование индекса (необязательно)</TD
><TD
>5</TD
></TR
><TR
><TD
>                    <CODE
CLASS="FUNCTION"
>triConsistent</CODE
>
                  </TD
><TD
>определяет, соответствует ли значение условию запроса (троичная вариация) (не требуется, если присутствует опорная функция 4)</TD
><TD
>6</TD
></TR
></TBODY
></TABLE
></DIV
><P
>В отличие от операторов поиска, опорные функции возвращают тот тип данных, который ожидает конкретный метод индекса; например, функция сравнения для B-деревьев возвращает знаковое целое. Количество и типы аргументов для каждой опорной функции так же зависят от метода индекса. Для методов B-дерева и хеша функции сравнения и хеширования принимают те же типы данных, что и операторы, включённые в класс операторов, но для большинства опорных функций GiST, SP-GiST и GIN это не так.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-EXAMPLE"
>35.14.4. Пример</A
></H2
><P
>Теперь, когда мы познакомились с основными идеями, мы можем перейти к обещанному примеру создания нового класса операторов. (Рабочую копию этого примера можно найти в <TT
CLASS="FILENAME"
>src/tutorial/complex.c</TT
> и <TT
CLASS="FILENAME"
>src/tutorial/complex.sql</TT
> в пакете исходного кода.) Класс операторов включает операторы, сортирующие комплексные числа по порядку абсолютных значений, поэтому мы выбрали для него имя <TT
CLASS="LITERAL"
>complex_abs_ops</TT
>. Во-первых, нам понадобится набор операторов. Процедура определения операторов была рассмотрена в <A
HREF="xoper.html"
>Разделе 35.12</A
>. Для класса операторов B-деревьев нам понадобятся операторы: <P
></P
></P><UL
COMPACT="COMPACT"
><LI
><SPAN
>абсолютное-значение меньше (стратегия 1)</SPAN
></LI
><LI
><SPAN
>абсолютное-значение меньше-или-равно (стратегия 2)</SPAN
></LI
><LI
><SPAN
>абсолютное-значение равно (стратегия 3)</SPAN
></LI
><LI
><SPAN
>абсолютное-значение больше-или-равно (стратегия 4)</SPAN
></LI
><LI
><SPAN
>абсолютное-значение больше (стратегия 5)</SPAN
></LI
></UL
><P></P
><P
>Чтобы не провоцировать ошибки при определении связанного набора операторов сравнения, лучше всего сначала написать вспомогательную функцию сравнения для B-дерева, а затем написать другие функции как однострочные оболочки этой вспомогательной функции. Это уменьшит вероятность получения несогласованных результатов в исключительных случаях. Следуя этому подходу, мы сначала напишем: </P><PRE
CLASS="PROGRAMLISTING"
>#define Mag(c)  ((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag &lt; bmag)
        return -1;
    if (amag &gt; bmag)
        return 1;
    return 0;
}</PRE
><P> Теперь функция &laquo;меньше&raquo; будет выглядеть так: </P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}</PRE
><P> Остальные четыре функции отличаются от неё только тем, как сравнивают результат внутренней функции с нулём.</P
><P
>Затем мы объявим в SQL функции и операторы на основе этих функций: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);</PRE
><P> Важно правильно определить обратные и коммутирующие операторы, а также подходящие функции избирательности ограничения и соединения; иначе оптимизатор не сможет использовать наш индекс эффективно. Заметьте, что для случаев меньше, равно и больше следует использовать другие функции оценки избирательности.</P
><P
>Здесь также стоит обратить внимание на следующее: <P
></P
></P><UL
><LI
><P
>Учтите, что может быть только один оператор с именем, например, <TT
CLASS="LITERAL"
>=</TT
>, который будет принимать тип <TT
CLASS="TYPE"
>complex</TT
> с двух сторон. В этом случае у нас не будет другого оператора <TT
CLASS="LITERAL"
>=</TT
> для <TT
CLASS="TYPE"
>complex</TT
>, но если мы создаём практически полезный тип данных, вероятно, мы захотим, чтобы оператор <TT
CLASS="LITERAL"
>=</TT
> проверял обычное равенство двух комплексных чисел (а не равенство их абсолютных значений). В этом случае, для <CODE
CLASS="FUNCTION"
>complex_abs_eq</CODE
> нужно выбрать какое-то другое имя оператора.</P
></LI
><LI
><P
>Хотя в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> разные функции могут иметь одинаковые имена SQL, если у них различные типы аргументов, в C только одна глобальная функция может иметь заданное имя. Поэтому не следует давать функции на C имя вроде <TT
CLASS="FILENAME"
>abs_eq</TT
>. Во избежание конфликтов с функциями для других типов данных, в имя функции на C обычно включается имя конкретного типа данных.</P
></LI
><LI
><P
>Мы могли быть дать нашей функции имя <TT
CLASS="FILENAME"
>abs_eq</TT
> в SQL, рассчитывая на то, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> отличит её от любых других одноимённых функций SQL по типам аргументов. Но в данном случае для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL.</P
></LI
></UL
><P></P
><P
>На следующем этапе регистрируется опорная процедура, необходимая для B-деревьев. В нашем примере код C, реализующий её, находится в том же файле, что и функции операторов. Мы объявляем эту процедуру так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<TT
CLASS="REPLACEABLE"
><I
>имя_файла</I
></TT
>'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P></P
><P
>Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец можем создать класс операторов: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       &lt; ,
        OPERATOR        2       &lt;= ,
        OPERATOR        3       = ,
        OPERATOR        4       &gt;= ,
        OPERATOR        5       &gt; ,
        FUNCTION        1       complex_abs_cmp(complex, complex);</PRE
><P></P
><P
>Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-деревья по колонкам <TT
CLASS="TYPE"
>complex</TT
>.</P
><P
>Операторы можно было записать более многословно, например, так: </P><PRE
CLASS="PROGRAMLISTING"
>        OPERATOR        1       &lt; (complex, complex) ,</PRE
><P> но в этом необходимости, так как эти операторы принимают тот же тип данных, для которого определяется класс операторов.</P
><P
>В приведённом примере предполагается, что этот класс операторов будет классом операторов B-дерева по умолчанию для типа <TT
CLASS="TYPE"
>complex</TT
>. Если вам это не нужно, просто опустите слово <TT
CLASS="LITERAL"
>DEFAULT</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-OPFAMILY"
>35.14.5. Семейства и классы операторов</A
></H2
><P
>До этого мы неявно полагали, что класс операторов работает только с одним типом данных. Хотя в конкретной индексируемой колонке, определённо, может быть только один тип данных, часто бывает полезно индексировать операции, сравнивающие значение колонки со значением другого типа. Также, если в сочетании с классом операторов возможно применение оператора, работающего с двумя типами, для другого типа данных обычно тоже создаётся собственный класс. В таких случаях полезно установить явную связь между связанными классами, так как это поможет планировщику оптимизировать SQL-запросы (особенно для классов операторов B-дерева, потому что планировщик хорошо знает, как работать с ними).</P
><P
>Для удовлетворения этих потребностей в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> введена концепция <I
CLASS="FIRSTTERM"
>семейства операторов</I
>. Семейство операторов содержит один или несколько классов операторов и может также содержать индексируемые операторы и соответствующие опорные функции, принадлежащие к семейству в целом, но не к какому-то одному классу в нём. Мы называем такую связь операторов и функций с семейством <SPAN
CLASS="QUOTE"
>"слабой"</SPAN
>, в отличие от обычной связи с определённым классом. Как правило, классы содержат операторы с операндами одного типа, тогда как межтиповые операторы слабо связываются с семейством.</P
><P
>Все операторы и функции в семействе операторов должны иметь совместимую семантику; требования к совместимости устанавливаются методом индекса. Вы можете спросить, зачем в таком случае вообще выделять конкретные подмножества семейства в виде классов операторов; и на самом деле во многих случаях деление на классы не имеет значения, важно только связывание с семейством. Смысл классов операторов в том, что они определяют, какая часть семейства необходима для поддержки некоторого индекса. Если существует индекс, использующий класс операторов, этот класс нельзя будет удалить, не удалив индекс &mdash; но другие части семейства, а именно, другие классы операторов и слабосвязанные операторы, удалить можно. Таким образом, класс операторов должен определяться так, чтобы он содержал минимальный набор операторов и функций, обоснованно требующихся для работы с индексом по определённому типу данных, а связанные, но не существенные операторы могут добавляться в качестве слабосвязанных членов в семейство операторов.</P
><P
>В качестве примера, в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть встроенное семейство операторов B-дерева <TT
CLASS="LITERAL"
>integer_ops</TT
>, включающее классы операторов <TT
CLASS="LITERAL"
>int8_ops</TT
>, <TT
CLASS="LITERAL"
>int4_ops</TT
> и <TT
CLASS="LITERAL"
>int2_ops</TT
> для индексов по колонкам <TT
CLASS="TYPE"
>bigint</TT
> (<TT
CLASS="TYPE"
>int8</TT
>), <TT
CLASS="TYPE"
>integer</TT
> (<TT
CLASS="TYPE"
>int4</TT
>) и <TT
CLASS="TYPE"
>smallint</TT
> (<TT
CLASS="TYPE"
>int2</TT
>), соответственно. В этом семействе также содержатся операторы межтипового сравнения, позволяющие сравнивать значения любых двух этих типов, так что индексом по любому из этих типов можно пользоваться, выполняя сравнение с другим типом. Это семейство можно представить такими определениями: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- стандартные сравнения int8
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- стандартные сравнения int4
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- стандартные сравнения int2
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- межтиповые сравнения int8 и int2
  OPERATOR 1 &lt; (int8, int2) ,
  OPERATOR 2 &lt;= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 &gt;= (int8, int2) ,
  OPERATOR 5 &gt; (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- межтиповые сравнения int8 и int4
  OPERATOR 1 &lt; (int8, int4) ,
  OPERATOR 2 &lt;= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 &gt;= (int8, int4) ,
  OPERATOR 5 &gt; (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- межтиповые сравнения int4 и int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- межтиповые сравнения int4 и int8
  OPERATOR 1 &lt; (int4, int8) ,
  OPERATOR 2 &lt;= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 &gt;= (int4, int8) ,
  OPERATOR 5 &gt; (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- межтиповые сравнения int2 и int8
  OPERATOR 1 &lt; (int2, int8) ,
  OPERATOR 2 &lt;= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 &gt;= (int2, int8) ,
  OPERATOR 5 &gt; (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- межтиповые сравнения int2 и int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;</PRE
><P> Заметьте, что в определении семейства <SPAN
CLASS="QUOTE"
>"перегружаются"</SPAN
> номера стратегий операторов и опорных функций: каждый номер фигурирует в семействе неоднократно. Это допускается, если для каждого экземпляра определённого номера задаются свои типы данных. Экземпляры, у которых оба входных типа совпадают с входным типом класса операторов, являются первичными операторами и опорными функциями для этого класса, и в большинстве случаев они должны объявляться в составе класса операторов, а не быть слабосвязанными членами семейства.</P
><P
>В семействе операторов B-дерева все операторы должны быть совместимыми в контексте сортировки, то есть для всех типов данных, поддерживаемых семейством, должны действовать транзитивные законы: <SPAN
CLASS="QUOTE"
>"если A = B и B = C, то A = C"</SPAN
>, и <SPAN
CLASS="QUOTE"
>"если A &lt; B и B &lt; C, то A &lt; C"</SPAN
>. Более того, неявное или двоичное приведение типов, представленных в семействе операторов, не должно влиять на порядок сортировки. Для каждого оператора в семействе должна существовать опорная функция, принимающая на вход те же два типа, что и оператор. Семейство рекомендуется делать полным, то есть включить в него все операторы для каждого сочетания типов данных. В классы операторов следует включать только однотиповые операторы и опорные функции для определённого типа данных.</P
><P
>Чтобы создать семейство операторов хеширования для нескольких типов данных, необходимо создать совместимые функции поддержки хеша для каждого типа данных, который будет поддерживать семейство. Здесь под совместимостью понимается гарантия получения одного хеш-кода для любых двух значений, которые операторы сравнения в этом семействе считают равными, даже если они имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное физическое представление, но в некоторых случаях всё же возможно. Более того, преобразование значения одного типа данных, представленного в семействе операторов, к другому типу, также представленному в этом семействе, путём неявного или двоичного сведения не должно менять значение вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для типа данных, а не для оператора равенства. Семейство рекомендуется делать полным, то есть включить в него оператор равенства для всех сочетаний типов данных. В классы операторов следует включать только однотиповый оператор равенства и опорную функция для определённого типа данных.</P
><P
>В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. Множество поддерживаемых операторов определяется только теми операциями, которые могут выполнять основные опорные функции заданного класса операторов.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>До версии 8.3 в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не было понятия семейства операторов, поэтому любые межтиповые операторы, предназначенные для применения с индексом, должны были привязываться непосредственно к классу оператора индекса. Хотя этот подход по-прежнему работает, он считается устаревшим, потому что он создаёт слишком много зависимостей для индекса, а также потому, что планировщик может выполнять межтиповые сравнения более эффективно, когда для обоих типов данных определены операторы в одном семействе.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-OPCLASS-DEPENDENCIES"
>35.14.6. Системные зависимости от классов операторов</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> использует классы операторов для наделения операторов такими свойствами, которые могут быть полезны не только для индексов. Поэтому классы операторов могут быть полезны, даже если вы не намерены индексировать колонки со значениями определённого вами типа.</P
><P
>В частности, это касается SQL-конструкций <TT
CLASS="LITERAL"
>ORDER BY</TT
> и <TT
CLASS="LITERAL"
>DISTINCT</TT
>, для которых требуется сравнивать и упорядочивать значения. Чтобы эти конструкции работали с определённым пользователем типом данных, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> задействует класс операторов B-дерева по умолчанию для этого типа. Член <SPAN
CLASS="QUOTE"
>"равно"</SPAN
> этого класса определяет, как система будет понимать равенство значений для <TT
CLASS="LITERAL"
>GROUP BY</TT
> и <TT
CLASS="LITERAL"
>DISTINCT</TT
>, а порядок сортировки, задаваемый классом операторов, определяет порядок <TT
CLASS="LITERAL"
>ORDER BY</TT
> по умолчанию.</P
><P
>Сравнение массивов пользовательских типов также зависит от семантики, определённой классом операторов B-дерева по умолчанию.</P
><P
>Если класс операторов B-дерева по умолчанию для типа данных не определён, система будет искать класс операторов хеша по умолчанию. Но так как этот вид класса поддерживает только равенство, на практике его достаточно только для проверки равенства массивов.</P
><P
>Если для типа не определён класс операторов по умолчанию, попытавшись использовать эти конструкции SQL с данным типом, вы получите ошибку вида <SPAN
CLASS="QUOTE"
>"не удалось найти оператор сортировки"</SPAN
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>До версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.4, в операциях сортировки и группировки неявно использовались операторы с именами <TT
CLASS="LITERAL"
>=</TT
>, <TT
CLASS="LITERAL"
>&lt;</TT
> и <TT
CLASS="LITERAL"
>&gt;</TT
>. С новым подходом, опирающимся на классы операторов по умолчанию, система не делает никаких предположений о поведении операторов по их именам.</P
></BLOCKQUOTE
></DIV
><P
>Также важно отметить, что оператор, указанный в семействе операторов хеширования, является кандидатом для применения при слиянии и агрегации по хешу, а также связанной оптимизации. В данном случае существенно семейство операторов хеша, так как оно определяет, какую функцию хеширования использовать.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-ORDERING-OPS"
>35.14.7. Операторы упорядочивания</A
></H2
><P
>Некоторые методы доступа индексов (в настоящее время только GiST) поддерживают концепцию <I
CLASS="FIRSTTERM"
>операторов упорядочивания</I
>. Операторы, которые мы обсуждали до этого, были <I
CLASS="FIRSTTERM"
>операторами поиска</I
>. Оператором поиска называется такой оператор, для которого можно выполнить поиск по индексу и найти все строки, удовлетворяющие условию <TT
CLASS="LITERAL"
>WHERE</TT
>
   <TT
CLASS="REPLACEABLE"
><I
>индексированная_колонка</I
></TT
>
   <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
>
   <TT
CLASS="REPLACEABLE"
><I
>константа</I
></TT
>. Заметьте, что при этом ничего не говорится о порядке, в котором будут возвращены подходящие строки. Оператор упорядочивания, напротив, не ограничивает набор возвращаемых строк, но определяет их порядок. С таким оператором, просканировав индекс, можно получить строки в порядке, заданным указанием <TT
CLASS="LITERAL"
>ORDER BY</TT
>
   <TT
CLASS="REPLACEABLE"
><I
>индексированная_колонка</I
></TT
>
   <TT
CLASS="REPLACEABLE"
><I
>оператор</I
></TT
>
   <TT
CLASS="REPLACEABLE"
><I
>константа</I
></TT
>. Такое определение объясняется тем, что оно поддерживает поиск ближайшего соседа, если этот оператор вычисляет расстояние. Например, запрос </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;</PRE
><P> находит десять ближайших к заданной точке мест. Индекс GiST по колонке location может сделать это эффективно, так как <TT
CLASS="LITERAL"
>&lt;-&gt;</TT
> — это оператор упорядочивания.</P
><P
>Тогда как операторы поиска должны возвращать булевские результаты, операторы упорядочивания обычно возвращают другой тип, например, float или numeric для расстояний. Этот тип, как правило, отличается от типа индексируемых данных. Чтобы избежать жёстко запрограммированных предположений о поведении различных типов данных, при объявлении оператора упорядочивания должно указываться семейство операторов B-дерева, определяющее порядок сортировки результирующего типа данных. Как было отмечено в предыдущем разделе, семейства операторов B-дерева определяют понятие упорядочивания для <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, так что такое объявление оказывается естественным. Так как оператор <TT
CLASS="LITERAL"
>&lt;-&gt;</TT
> для точек возвращает <TT
CLASS="TYPE"
>float8</TT
>, его можно включить в команду создания класса операторов так: </P><PRE
CLASS="PROGRAMLISTING"
>OPERATOR 15    &lt;-&gt; (point, point) FOR ORDER BY float_ops</PRE
><P> где <TT
CLASS="LITERAL"
>float_ops</TT
> — встроенное семейство операторов, включающее операции с <TT
CLASS="TYPE"
>float8</TT
>. Это объявление означает, что индекс может возвращать строки в порядке увеличения значений оператора <TT
CLASS="LITERAL"
>&lt;-&gt;</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XINDEX-OPCLASS-FEATURES"
>35.14.8. Особенности классов операторов</A
></H2
><P
>Есть ещё две особенности классов операторов, которые мы до этого не обсуждали, в первую очередь потому, что они не востребованы для наиболее часто применяемых методов индексов.</P
><P
>Обычно объявление оператора в качестве члена класса операторов (или семейства) означает, что метод индекса может получить точно набор строк, который удовлетворяет условию <TT
CLASS="LITERAL"
>WHERE</TT
> с этим оператором. Например, запрос: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM table WHERE integer_column &lt; 4;</PRE
><P> может быть удовлетворён в точности индексом-B-деревом по целочисленной колонке. Но бывают случаи, когда индекс полезен как приблизительный указатель на соответствующие строки. Например, если индекс GiST хранит только прямоугольники, описанные вокруг геометрических объектов, он не может точно удовлетворить условие <TT
CLASS="LITERAL"
>WHERE</TT
>, которое проверяет пересечение не прямоугольных объектов, а например, многоугольников. Однако этот индекс можно применить, чтобы найти объекты, для которых описанные вокруг прямоугольники пересекаются с прямоугольником, описанным вокруг целевого объекта, а затем провести точную проверку пересечения только для найденных по индексу объектов. Если это имеет место, такой индекс называется <SPAN
CLASS="QUOTE"
>"неточным"</SPAN
> для оператора. Для реализации поиска по неточному индексу метод индекса возвращает флаг <I
CLASS="FIRSTTERM"
>recheck</I
> (перепроверить), когда строка может действительно удовлетворять, а может не удовлетворять условию запроса. Затем исполнитель запроса перепроверяет полученную строку по исходному условию запроса и определяет, должна ли она выдаваться как действительно соответствующая ему. Этот подход работает, если индекс гарантированно выдаёт все требуемые строки плюс, возможно, дополнительные строки, которые можно исключить, вызвав первоначальный оператор. Методы индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и GIN), позволяют устанавливать флаг recheck опорным функциям отдельных классов операторов, так что по сути это особенность класса операторов.</P
><P
>Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, описанный вокруг сложного объекта, такого как многоугольник. В этом случае нет большого смысла хранить в элементе индекса весь многоугольник &mdash; мы можем с тем же успехом хранить более простой объект типа <TT
CLASS="TYPE"
>box</TT
>. Это отклонение выражается указанием <TT
CLASS="LITERAL"
>STORAGE</TT
> в команде <TT
CLASS="COMMAND"
>CREATE OPERATOR CLASS</TT
>, которое записывается примерно так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;</PRE
><P> В настоящее время, только методы индексов GiST и GIN позволяют задать в <TT
CLASS="LITERAL"
>STORAGE</TT
> тип, отличный от типа данных колонки. В GiST преобразованием данных, связанным с использованием <TT
CLASS="LITERAL"
>STORAGE</TT
>, должны заниматься опорные процедуры <CODE
CLASS="FUNCTION"
>compress</CODE
> и <CODE
CLASS="FUNCTION"
>decompress</CODE
>. В GIN тип <TT
CLASS="LITERAL"
>STORAGE</TT
> определяет тип значений <SPAN
CLASS="QUOTE"
>"ключа"</SPAN
>, который обычно отличается от типа индексируемой колонки &mdash; например, в классе операторов для колонок с целочисленным массивом ключами могут быть просто целые числа. За извлечение ключей из индексированных значений в GIN отвечают опорные функции <CODE
CLASS="FUNCTION"
>extractValue</CODE
> и <CODE
CLASS="FUNCTION"
>extractQuery</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xoper-optimization.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="extend-extensions.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Информация для оптимизации операторов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Упаковывание связанных объектов в расширение</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>