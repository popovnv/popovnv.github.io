<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>TOAST</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Физическое хранение базы данных"
HREF="storage.html"><LINK
REL="PREVIOUS"
TITLE="Размещение файлов базы данных"
HREF="storage-file-layout.html"><LINK
REL="NEXT"
TITLE="Карта свободного пространства"
HREF="storage-fsm.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Размещение файлов базы данных"
HREF="storage-file-layout.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 59. Физическое хранение базы данных</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Карта свободного пространства"
HREF="storage-fsm.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STORAGE-TOAST"
>59.2. TOAST</A
></H1
><P
>В данном разделе рассматривается <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> (The Oversized-Attribute Storage Technique, Методика хранения сверхбольших атрибутов).</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> использует фиксированный размер страницы (обычно 8 Кб), и не позволяет версиям строк занимать несколько страниц. Поэтому непосредственное хранение очень больших значений полей невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или разбиваются на несколько физических строк. Это происходит незаметно для пользователя и на большую часть кода сервера влияет незначительно. Этот метод известен как <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> (тост, или <SPAN
CLASS="QUOTE"
>"лучшее, после изобретения нарезанного хлеба"</SPAN
>).</P
><P
>Лишь определённые типы данных работают с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, поскольку нет необходимости выделять дополнительную память для типов данных, которые не могут занимать большой объём. Чтобы поддерживать <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, тип данных должен представлять значение переменной длины (<I
CLASS="FIRSTTERM"
>varlena</I
>), в котором первое 32-разрядное слово любого хранящегося значения содержит всю длину значения в байтах (включая само слово). <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> не ограничивает содержание оставшейся части значения. Все функции уровня C, работающие с типами данных, поддерживающими <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, должны адекватно воспринимать входные значения в формате <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>. (Обычно это выполняется через вызов <CODE
CLASS="FUNCTION"
>PG_DETOAST_DATUM</CODE
> перед тем, как сделать что-либо с входным значением, но в некоторых случаях возможны более эффективные подходы.)</P
><P
><ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> занимает два бита значения, представляющего длину поля (старшие биты на машинах с порядком следования байтов, начиная со старшего; младшие биты — на машинах с порядком следования байтов, начиная с младшего), таким образом ограничивая логический размер любого значения типа данных, работающего с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, до 1 Гб (2<SUP
>30</SUP
> - 1 байт). Когда оба бита равны нулю, значение является нормальным значением типа данных, не <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, а оставшиеся биты значения длины данных представляют общий размер элемента данных (включая слово длины) в байтах. Когда установлен бит самого высокого или самого низкого разряда, значение имеет только однобайтовый заголовок вместо обычного четырёхбайтового, а оставшиеся биты составляют общий размер элемента данных (включая байт, содержащий длину строки) в байтах. В особом случае, если все оставшиеся биты равны нулю (что было бы невозможно для длины, учитывающей длину своего представления), значение является указателем на данные, хранящиеся в отдельной таблице TOAST. (Размер TOAST-указателя дан во втором байте элемента данных.) Значения с однобайтовыми заголовками также не выровнены по какой-либо конкретной границе. И наконец, когда бит самого высокого или самого низкого разряда является свободным, но установлен смежный бит, содержание элемента данных было сжато и должно быть распаковано перед использованием. В этом случае оставшиеся биты слова длины составляют общий размер сжатого элемента данных, но не исходных данных. Заметьте, что сжатие также возможно для отдельных от таблицы данных, но заголовок varlena не сообщает, выполнено ли оно &mdash; об этом сообщает содержание TOAST-указателя.</P
><P
>Если какие-либо столбцы таблицы хранятся в формате <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, у таблицы будет связанная с ней таблица <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, OID которой хранится в значении <TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>reltoastrelid</TT
> для данной таблицы. Отдельно хранящиеся <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>-значения хранятся в таблице <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, что подробнее описано ниже.</P
><P
>Используемый метод сжатия является одним из довольно простых и очень быстрых методов семейства LZ. Подробнее см. <TT
CLASS="FILENAME"
>src/backend/utils/adt/pg_lzcompress.c</TT
>.</P
><P
>Значения, хранящиеся отдельно, делятся на порции (после сжатия, если оно используется) размером не более <TT
CLASS="SYMBOL"
>TOAST_MAX_CHUNK_SIZE</TT
> байт (по умолчанию это значение выбирается таким образом, чтобы на странице помещались четыре строки порций, каждая из которых составляла бы около 2000 байт). Каждая порция хранится как отдельная строка в таблице <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, созданной для исходной таблицы-владельца. Каждая таблица <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> имеет столбцы <TT
CLASS="STRUCTFIELD"
>chunk_id</TT
> (OID, идентифицирующий конкретное <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>-значение), <TT
CLASS="STRUCTFIELD"
>chunk_seq</TT
> (последовательный номер для порции внутри его значения) и <TT
CLASS="STRUCTFIELD"
>chunk_data</TT
> (фактические данные порции). Уникальный индекс на <TT
CLASS="STRUCTFIELD"
>chunk_id</TT
> и <TT
CLASS="STRUCTFIELD"
>chunk_seq</TT
> обеспечивает быструю выдачу значений. По этой причине элементу указателя элемента данных, представляющему отдельное <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>-значение, необходимо хранить OID таблицы <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, к которой нужно обращаться, и OID определённого значения (его <TT
CLASS="STRUCTFIELD"
>chunk_id</TT
>). Для удобства элементы данных указателя также хранят логический размер элемента данных (размер исходных данных без сжатия) и фактический размер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка, указывающие длину значения, общий размер элемента данных указателя <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> составляет 18 байт, независимо от фактического размера значения, которое он представляет.</P
><P
>Код <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> срабатывает, только когда значение строки, которая должна храниться в таблице, по размеру больше, чем <TT
CLASS="SYMBOL"
>TOAST_TUPLE_THRESHOLD</TT
> байт (обычно это 2 Кб). Код <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> будет сжимать и/или выносить значения поля за пределы таблицы до тех пор пока значение строки не будет меньше <TT
CLASS="SYMBOL"
>TOAST_TUPLE_TARGET</TT
> байт (также обычно 2 Кб) или не сможет занять пространства больше, чем это значение. Во время операции UPDATE, значения неизменённых полей обычно сохраняются как есть, поэтому UPDATE строки с хранящимися отдельно значениями не несёт издержек, связанных с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, если все эти значения остаются без изменений.</P
><P
>Код <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> распознаёт четыре различные стратегии хранения столбцов, совместимых с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>: <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>PLAIN</TT
> не допускает ни сжатие, ни отдельное хранение вне таблицы; кроме того, отключается использование однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для столбцов типов данных, которые несовместимы с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>.</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>EXTENDED</TT
> допускает как сжатие, так и хранение вне таблицы. Это стандартный вариант для большинства типов данных, совместимых с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>. Сначала происходит попытка выполнить сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>EXTERNAL</TT
> допускает хранение вне таблицы, но не сжатие. Использование <TT
CLASS="LITERAL"
>EXTERNAL</TT
> ускорит операции над частями строк в больших столбцах <TT
CLASS="TYPE"
>text</TT
> и <TT
CLASS="TYPE"
>bytea</TT
> (за счёт увеличения объёма памяти для хранения), так как эти операции оптимизированы для извлечения только требуемых частей вынесенного значения, когда оно не является сжатым.</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>MAIN</TT
> допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого способа уменьшить строку так, чтобы она помещалась на странице.)</P
></LI
></UL
><P> Каждый тип совместимых с <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> данных определяет стандартную стратегию для столбцов этого типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью <TT
CLASS="COMMAND"
>ALTER TABLE SET STORAGE</TT
>.</P
><P
>Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются выполнением сравнения с относительно маленькими значениями ключа, большая часть работы будет выполняться с использованием главной записи строки. Большие значения атрибутов в формате <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
> будут просто передаваться (если будут выбраны) в тот момент, когда результирующий набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в общий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хранения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполняться исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая таблицу <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обработки таблицы без использования <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, в которой размер всех HTML-страниц был уменьшен до 7 Кб, чтобы они уместились в строках.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage-file-layout.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="storage-fsm.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Размещение файлов базы данных</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Карта свободного пространства</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>