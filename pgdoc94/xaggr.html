<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Пользовательские агрегатные функции</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Расширение SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Функции на языке C"
HREF="xfunc-c.html"><LINK
REL="NEXT"
TITLE="Пользовательские типы"
HREF="xtypes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Функции на языке C"
HREF="xfunc-c.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 35. Расширение <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Пользовательские типы"
HREF="xtypes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XAGGR"
>35.10. Пользовательские агрегатные функции</A
></H1
><P
>Агрегатные функции в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> определяются в терминах <I
CLASS="FIRSTTERM"
>значений состояния</I
> и <I
CLASS="FIRSTTERM"
>функций перехода состояния</I
>. То есть агрегатная функция работает со значением состояния, которое меняется при обработке каждой последующей строки. Чтобы определить агрегатную функцию, нужно выбрать тип данных для значения состояния, начальное значение состояния и функцию перехода состояния. Функция перехода состояния принимает предыдущее значение состояния и входное агрегируемое значение для текущей строки и возвращает новое значение состояния. Также можно указать <I
CLASS="FIRSTTERM"
>функцию завершения</I
>, на случай, если ожидаемый результат агрегатной функции отличается от данных, которые сохраняются в изменяющемся значении состояния. Функция завершения принимает последнее значение состояния и возвращает то, что она хочет вернуть в виде результата агрегирования. В принципе, функции перехода и завершения представляют собой просто обычные функции, которые также могут применяться вне контекста агрегирования. (На практике, для большей производительности часто создаются специализированные функции перехода, которые работают, только когда вызываются при агрегировании.)</P
><P
>Таким образом, помимо типов данных аргументов и результата, с которыми имеет дело пользователь агрегатной функции, есть также тип данных внутреннего состояния, который может отличаться от этих типов.</P
><P
>Если мы определяем агрегат, не использующий функцию завершения, наш агрегат будет вычислять бегущее значение функции по колонкам каждой строки. Примером такой агрегатной функции является <CODE
CLASS="FUNCTION"
>sum</CODE
>. Вычисление <CODE
CLASS="FUNCTION"
>sum</CODE
> начинается с нуля, а затем к накапливаемой сумме всегда прибавляется значение из текущей строки. Например, если мы хотим сделать агрегатную функцию <CODE
CLASS="FUNCTION"
>sum</CODE
> для комплексных чисел, нам потребуется только функция сложения для такого типа данных. Такая агрегатная функция может быть определена так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);</PRE
><P> Использовать её можно будет так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT sum(a) FROM test_complex;

   sum
-----------
 (34,53.9)</PRE
><P> (Заметьте, что мы задействуем перегрузку функций: в системе есть несколько агрегатных функций с именем <CODE
CLASS="FUNCTION"
>sum</CODE
>, но <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может определить, какая именно из них применима к колонке типа <TT
CLASS="TYPE"
>complex</TT
>.)</P
><P
>Определённая выше функция <CODE
CLASS="FUNCTION"
>sum</CODE
> вернёт ноль (начальное значение состояния), если в наборе данных не окажется значений, отличных от NULL. У нас может возникнуть желание вернуть NULL в этом случае &mdash; стандарт SQL требует, чтобы <CODE
CLASS="FUNCTION"
>sum</CODE
> работала так. Мы можем добиться этого, просто опустив фразу <TT
CLASS="LITERAL"
>initcond</TT
>, так что начальным значением состояния будет NULL. Обычно это будет означать, что в <TT
CLASS="LITERAL"
>sfunc</TT
> придётся проверять входное значение состояния на NULL. Но для <CODE
CLASS="FUNCTION"
>sum</CODE
> и некоторых других простых агрегатных функций, как <CODE
CLASS="FUNCTION"
>max</CODE
> и <CODE
CLASS="FUNCTION"
>min</CODE
>, достаточно вставить в переменную состояния первое входное значение не NULL, а затем начать применять функцию перехода со следующего значения не NULL. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> сделает это автоматически, если начальное значение состояние равно NULL и функция перехода помечена как <SPAN
CLASS="QUOTE"
>"strict"</SPAN
> (то есть не должна вызываться для аргументов NULL).</P
><P
>Ещё одна особенность поведения по умолчанию <SPAN
CLASS="QUOTE"
>"строгой"</SPAN
> функции перехода — предыдущее значение состояния остаётся без изменений, когда встречается значение NULL. Другими словами, значения NULL игнорируются. Если вам нужно другое поведение для входных значений NULL, не объявляйте свою функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие значения на NULL и обработайте их, как требуется.</P
><P
>Функция <CODE
CLASS="FUNCTION"
>avg</CODE
> (вычисляющая среднее арифметическое) представляет собой более сложный пример агрегатной функции. Ей необходимы два компонента текущего состояния: сумма входных значений и их количество. Окончательный результат получается как частное этих величин. При реализации этой функции для значения состояния обычно используется массив. Например, встроенная реализация <CODE
CLASS="FUNCTION"
>avg(float8)</CODE
> выглядит так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);</PRE
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Функция <CODE
CLASS="FUNCTION"
>float8_accum</CODE
> принимает массив из трёх, а не двух элементов, так как в дополнение к количеству и сумме значений она подсчитывает ещё сумму их квадратов. Это сделано для того, чтобы её можно было применять для <CODE
CLASS="FUNCTION"
>avg</CODE
> и для некоторых других агрегатных функций.</P
></BLOCKQUOTE
></DIV
><P
>Вызовы агрегатных функций SQL допускают указания <TT
CLASS="LITERAL"
>DISTINCT</TT
> и <TT
CLASS="LITERAL"
>ORDER BY</TT
>, которые определяют, какие строки и в каком порядке будут поступать в функцию перехода агрегата. Это реализовано на заднем плане и непосредственно не затрагивает функции, поддерживающие работу агрегата.</P
><P
>За дополнительными подробностями обратитесь к описанию <A
HREF="sql-createaggregate.html"
>CREATE AGGREGATE</A
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XAGGR-MOVING-AGGREGATES"
>35.10.1. Режим движущегося агрегата</A
></H2
><P
>Агрегатные функции могут дополнительно поддерживать <I
CLASS="FIRSTTERM"
>режим движущегося агрегата</I
>, который позволяет значительно быстрее выполнять агрегатные функции в окнах со сдвигающимся началом рамки. (За информацией об использовании агрегатных функций в качестве оконных обратитесь к <A
HREF="tutorial-window.html"
>Разделу 3.5</A
> и <A
HREF="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS"
>Подразделу 4.2.8</A
>.) Основная идея состоит в том, что помимо добавления обычной функции перехода <SPAN
CLASS="QUOTE"
>"вперёд"</SPAN
>, для агрегатной функции задаётся <I
CLASS="FIRSTTERM"
>функция обратного перехода</I
>, которая позволяет убирать строки из накапливаемого значения состояния, когда они покидают рамку окна. Например, для <CODE
CLASS="FUNCTION"
>sum</CODE
> в качестве функции прямого перехода выполняется сложение, а в качестве функции обратного перехода выполняется вычитание. Без функции обратного перехода механизм оконных функций вынужден вычислять агрегат заново при каждом перемещении начала рамки, в результате чего время обработки оказывается пропорциональным количеству входных строк, помноженному на средний размер рамки. С функцией обратного перехода это время пропорционально только количеству входных строк.</P
><P
>Функции обратного перехода передаётся текущее значение состояния и агрегируемое входное значение(я) для строки, ранее учтённой в текущем состоянии. Она должна восстановить то значение состояния, которое было бы получено, если бы эта строка не агрегировалась, но агрегировались все последующие. Иногда для этого нужно, чтобы функция обратного перехода сохраняла больше информации о состоянии, чем это требуется для простого режима агрегирования. Таким образом, для режима движущегося агрегата используется реализация, отличная от простого режима: для него определяется отдельный тип данных, отдельная функция прямого перехода и отдельная функция завершения, при необходимости. Они могут совпадать с типом данных и аналогичными функциями обычного режима, если в дополнительном состоянии необходимости нет.</P
><P
>В качестве примера мы можем доработать показанную выше агрегатную функцию <CODE
CLASS="FUNCTION"
>sum</CODE
>, чтобы она поддерживала режим движущегося агрегата так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);</PRE
><P> Параметры, имена которых начинаются с <TT
CLASS="LITERAL"
>m</TT
>, определяют реализацию для движущегося агрегата. За исключением функции обратного перехода, <TT
CLASS="LITERAL"
>minvfunc</TT
>, они соответствуют параметрам обычного агрегата без <TT
CLASS="LITERAL"
>m</TT
>.</P
><P
>Функции прямого перехода в режиме движущегося агрегата не разрешено возвращать NULL в качестве нового значения состояния. Если функция обратного перехода возвращает NULL, это воспринимается как признак того, что она не может восстановить предыдущее состояние для полученных данных, и значит, агрегатное вычисление нужно производить заново с текущей позиции начала рамки. Это соглашение позволяет применять режим движущегося агрегата и в ситуациях, когда прокручивать назад значение состояния непрактично. Функция обратного перехода может <SPAN
CLASS="QUOTE"
>"спасовать"</SPAN
> в таких случаях, но включаться в работу, насколько это возможно в большинстве случаев. Например, агрегатная функция, работающая с числами с плавающей точкой, может спасовать, когда от неё потребуется убрать значение <TT
CLASS="LITERAL"
>NaN</TT
> (не число, not a number) из текущего значения состояния.</P
><P
>Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы функция обратного перехода могла восстановить в точности требуемое значение состояния. В противном случае, в результатах могут проявляться различия, в зависимости от того, использовался ли режим движущегося агрегата. Например, на первый взгляд может показаться, что легко добавить функцию обратного перехода для сложения, но заявленное требование не будет выполняться для <CODE
CLASS="FUNCTION"
>sum</CODE
> с типом <TT
CLASS="TYPE"
>float4</TT
> или <TT
CLASS="TYPE"
>float8</TT
>. Наивное объявление <CODE
CLASS="FUNCTION"
>sum(<TT
CLASS="TYPE"
>float8</TT
>)</CODE
> может быть таким: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);</PRE
><P> Однако такой агрегат может выдавать результаты, радикально отличающиеся от тех, что он выдавал бы без функции обратного перехода. Например, рассмотрите запрос </P><PRE
CLASS="PROGRAMLISTING"
>SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);</PRE
><P> Он возвращает <TT
CLASS="LITERAL"
>0</TT
> в качестве второго результата, а не ожидаемое значение <TT
CLASS="LITERAL"
>1</TT
>. Это связано с ограниченной точностью значений с плавающей точкой: при добавлении <TT
CLASS="LITERAL"
>1</TT
> к <TT
CLASS="LITERAL"
>1e20</TT
> снова получается <TT
CLASS="LITERAL"
>1e20</TT
>, а при вычитании <TT
CLASS="LITERAL"
>1e20</TT
> из результата получается <TT
CLASS="LITERAL"
>0</TT
>, а не <TT
CLASS="LITERAL"
>1</TT
>. Заметьте, что это принципиальное ограничение арифметики чисел с плавающей точкой, а не недостаток <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XAGGR-POLYMORPHIC-AGGREGATES"
>35.10.2. Агрегатные функции с полиморфными и переменными аргументами</A
></H2
><P
>Агрегатная функция может использовать полиморфные функции перехода состояния или функции завершения, так что эти функции могут применяться для реализации нескольких агрегатов. За объяснением полиморфных функций обратитесь к <A
HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC"
>Подразделу 35.2.5</A
>. Более того, сама агрегатная функция может описываться с полиморфными типами входных данных и состояния, так что одно определение агрегатной функции может служить для использования с разными типами данных. Пример полиморфного агрегата: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);</PRE
><P> Здесь фактическим типом состояния для любого конкретного агрегатного вызова будет массив, элементы которого будут иметь тип входных данных. Действие данного агрегата заключается в накоплении всех входных значений в массиве этого типа. (К вашему сведению: встроенная агрегатная функция <CODE
CLASS="FUNCTION"
>array_agg</CODE
> обеспечивает подобную функциональность, но работает быстрее, чем могла бы функция с приведённым определением.)</P
><P
>Так будут выглядеть результаты с аргументами двух различных типов: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum              
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)</PRE
><P></P
><P
>Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный тип состояния, как в предыдущем примере. Это необходимо, так как иначе нельзя будет объявить функцию завершения: она должна будет иметь полиморфный тип результата, но не будет иметь полиморфного аргумента, что команда <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> не примет на основании того, что тип результата нельзя будет определить при вызове. Чаще всего эта проблема возникает, когда функции реализации агрегата пишутся на C и тип состояния должен объявляться как <TT
CLASS="TYPE"
>internal</TT
>, так как для него нет соответствующего типа на уровне SQL. Чтобы решить эту проблему, можно объявить функцию завершения как принимающую дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. В этих фиктивных аргументах всегда передаются значения NULL, так как при вызове функции завершения какое-либо определённое значение отсутствует. Единственное их предназначение — позволить связать тип результата полиморфной функции завершения с типом входных данных агрегата. Например, определение встроенного агрегата <CODE
CLASS="FUNCTION"
>array_agg</CODE
> выглядит так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION array_agg_transfn(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anyelement)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anyelement)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);</PRE
><P> Здесь параметр <TT
CLASS="LITERAL"
>finalfunc_extra</TT
> указывает, что функция завершения помимо значения состояния получит дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. Дополнительный аргумент <TT
CLASS="TYPE"
>anyelement</TT
> позволяет сделать объявление <CODE
CLASS="FUNCTION"
>array_agg_finalfn</CODE
> допустимым.</P
><P
>Агрегатную функцию можно сделать принимающей переменное число аргументов, объявив её последний аргумент как массив <TT
CLASS="LITERAL"
>VARIADIC</TT
>, в том же ключе, как и обычную функцию; см. <A
HREF="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS"
>Подраздел 35.4.5</A
>. При этом у функций перехода агрегата их последний аргумент должен иметь тот же тип массива. Такие функции обычно также объявляются как <TT
CLASS="LITERAL"
>VARIADIC</TT
>, но строго это не требуется.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Агрегатные функции с переменными аргументами легко допускают ошибочное использование в сочетании с указанием <TT
CLASS="LITERAL"
>ORDER BY</TT
> (см. <A
HREF="sql-expressions.html#SYNTAX-AGGREGATES"
>Подраздел 4.2.7</A
>), так как анализатор запроса не может определить, было ли передано нужное количество фактических параметров в такой комбинации. Помните, что всё, находящееся справа от <TT
CLASS="LITERAL"
>ORDER BY</TT
>, является ключом сортировки, а не аргументом агрегатной функции. Например, в </P><PRE
CLASS="PROGRAMLISTING"
>SELECT myaggregate(a ORDER BY a, b, c) FROM ...</PRE
><P> анализатор запроса увидит один агрегатный аргумент функции и три ключа сортировки. Однако пользователь мог подразумевать и следующее: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT myaggregate(a, b, c ORDER BY a) FROM ...</PRE
><P> Если функция <TT
CLASS="LITERAL"
>myaggregate</TT
> принимает переменные аргументы, оба эти вызова будут вполне допустимы.</P
><P
>По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные функции с одинаковыми именами, но разным числом обычных аргументов.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XAGGR-ORDERED-SET-AGGREGATES"
>35.10.3. Сортирующие агрегатные функции</A
></H2
><P
>Описанные выше агрегатные функции были <SPAN
CLASS="QUOTE"
>"обычными"</SPAN
> агрегатами. Но <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> также поддерживает <I
CLASS="FIRSTTERM"
>сортирующие агрегатные функции</I
>, которые имеют два отличия от обычных. Во-первых, в дополнение к обычным агрегируемым аргументам, вычисляемых для каждой входной строки, сортирующий агрегат может иметь <SPAN
CLASS="QUOTE"
>"прямые"</SPAN
> аргументы, которые должны вычисляться в операции агрегирования только один раз. Во-вторых, для обычных агрегируемых аргументов порядок их сортировки задаётся явно, а сортирующий агрегат обычно выполняет вычисления, зависящие от конкретного порядка строк, например, вычисляет ранг или перцентиль, так что порядок сортировки критичен для каждого вызова. Например, встроенное определение функции <CODE
CLASS="FUNCTION"
>percentile_disc</CODE
> равнозначно следующему: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);</PRE
><P> Этот агрегат принимает прямой аргумент <TT
CLASS="TYPE"
>float8</TT
> (дробь перцентиля) и агрегируемые данные, которые могут быть любого упорядочиваемого типа. Используя его, можно рассчитать средний семейный доход следующим образом: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489</PRE
><P> В данном случае, <TT
CLASS="LITERAL"
>0.5</TT
> — это прямой аргумент; если бы дробь перцентиля менялась от строки к строке, это не имело бы смысла.</P
><P
>В отличие от случая с обычными агрегатами, сортировка входных строк для сортирующего агрегата <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> выполняется на заднем плане, а является задачей функций, реализующих агрегат. Обычный подход к такой реализации заключается в сохранении ссылки на объект <SPAN
CLASS="QUOTE"
>"tuplesort"</SPAN
> в значении состояния агрегата, загрузке поступающих строк в этот объект, и собственно завершении сортировки и обработки данных в функции завершения. Такая конструкция позволяет функции завершения выполнять специальные операции, в частности, вставлять дополнительные <SPAN
CLASS="QUOTE"
>"гипотетические"</SPAN
> строки в сортируемые данные. Тогда как обычные агрегаты часто реализуются функциями, написанными на <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> или другом процедурном языке, сортирующие агрегатные функции обычно должны быть написаны на C, так как их значение состояния нельзя выразить каким-либо типом данных SQL. (Обратите внимание, что в приведённом выше примере значение состояния объявлено как имеющее тип <TT
CLASS="TYPE"
>internal</TT
> &mdash; это типичный вариант.)</P
><P
>Функция перехода состояния для сортирующего агрегата получает значение текущего состояния плюс агрегируемые входные данные для каждой строки и возвращает изменённое значение состояния. Это определение распространяется и на обычные агрегаты, но заметьте, что прямые аргументы (если они есть) при этом не передаются. Функция завершения же получает последнее значение состояния и значения прямых аргументов (если они есть), а также (если присутствует указание <TT
CLASS="LITERAL"
>finalfunc_extra</TT
>) значения NULL, соответствующие агрегируемым данным. С обычными агрегатами указание <TT
CLASS="LITERAL"
>finalfunc_extra</TT
> действительно полезно, только если агрегат полиморфный; тогда дополнительные фиктивные аргументы необходимы, чтобы связать тип результата функции завершения с типом(ами) входных данных агрегата.</P
><P
>В настоящее время сортирующие агрегаты не могут использоваться в качестве оконных функций, поэтому от них поддержка режима движущегося агрегата не требуется.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XAGGR-SUPPORT-FUNCTIONS"
>35.10.4. Вспомогательные функции для агрегатов</A
></H2
><P
>Функция, написанная на C, может определить, была ли она вызвана как функция агрегатного перехода или завершения, вызвав <CODE
CLASS="FUNCTION"
>AggCheckCallContext</CODE
>, например, так: </P><PRE
CLASS="PROGRAMLISTING"
>if (AggCheckCallContext(fcinfo, NULL))</PRE
><P> Смысл такой проверки в том, что для функции перехода (когда эта функция возвращает true) первым входным аргументом является временное значение состояния, которое можно безопасно модифицировать на месте, не создавая новую копию. Пример вы можете увидеть в функции <TT
CLASS="LITERAL"
>int8inc()</TT
>. (Это <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>единственный</I
></SPAN
> случай, когда функция может безопасно изменять входные данные, передаваемые по ссылке. В частности, функции завершения для обычных агрегатов не должны изменять входные данные ни в коем случае, так как в некоторых ситуациях они могут вызываться повторно с тем же конечным значением состояния.)</P
><P
>Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных функций, написанных на C, называется <CODE
CLASS="FUNCTION"
>AggGetAggref</CODE
>. Эта функция возвращает узел разбора <TT
CLASS="LITERAL"
>Aggref</TT
>, описывающий вызов агрегата. Это в основном полезно для сортирующих агрегатов, которые могут исследовать структуру узла <TT
CLASS="LITERAL"
>Aggref</TT
> и выяснить, какой порядок сортировки они должны реализовать. Примеры использования можно найти в <TT
CLASS="FILENAME"
>orderedsetaggs.c</TT
> в исходном коде <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-c.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xtypes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Функции на языке C</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Пользовательские типы</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>