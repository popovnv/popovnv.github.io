<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Замечания о блокировке с индексами</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Определение интерфейса для методов доступа индекса"
HREF="indexam.html"><LINK
REL="PREVIOUS"
TITLE="Сканирование индекса"
HREF="index-scanning.html"><LINK
REL="NEXT"
TITLE="Проверки уникальности в индексе"
HREF="index-unique-checks.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Сканирование индекса"
HREF="index-scanning.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexam.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 55. Определение интерфейса для методов доступа индекса</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Проверки уникальности в индексе"
HREF="index-unique-checks.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INDEX-LOCKING"
>55.4. Замечания о блокировке с индексами</A
></H1
><P
>Методы доступа индекса должны справляться с параллельными операциями обновления индекса, производимыми несколькими процессами. Ядро системы <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> получает блокировку <TT
CLASS="LITERAL"
>AccessShareLock</TT
> для индекса в процессе сканирования и <TT
CLASS="LITERAL"
>RowExclusiveLock</TT
> при модификации индекса (включая и обычную очистку командой <TT
CLASS="COMMAND"
>VACUUM</TT
>). Так как эти типы блокировок не конфликтуют, метод доступа должен сам устанавливать более тонкие блокировки, которые ему могут потребоваться. Исключительная блокировка индекса в целом устанавливается только при создании и уничтожении индекса или операции <TT
CLASS="COMMAND"
>REINDEX</TT
>.</P
><P
>Реализация типа индекса, поддерживающего параллельные изменения, обычно требует глубокого и всестороннего анализа требуемого поведения. Для общего представления вы можете узнать о конструктивных решениях, принятых при реализации B-дерева и индекса по хешу, обратившись к <TT
CLASS="FILENAME"
>src/backend/access/nbtree/README</TT
> и <TT
CLASS="FILENAME"
>src/backend/access/hash/README</TT
>.</P
><P
>Помимо собственных внутренних требований индексов к целостности, при параллельном обновлении данных возникают вопросы согласованности родительской таблицы (<I
CLASS="FIRSTTERM"
>основных данных</I
>) и индекса. Вследствие того, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> отделяет чтение и изменение основных данных от чтения и изменения индекса, образуются временные интервалы, в которых индекс может быть несогласованным с данными. Мы решаем эту проблему, применяя следующие правила: <P
></P
></P><UL
><LI
><P
>Новая запись в области данных добавляется до того, как для неё будут созданы записи в индексах. (Таким образом, при параллельном сканировании индекса эта запись в данных скорее всего не будет замечена. Это не проблема, так как читателю индекса всё равно не нужны незафиксированные строки. Но учтите написанное в <A
HREF="index-unique-checks.html"
>Разделе 55.5</A
>.)</P
></LI
><LI
><P
>Когда запись данных удаляется (командой <TT
CLASS="COMMAND"
>VACUUM</TT
>), сначала должны удалиться все созданные для неё записи в индексах.</P
></LI
><LI
><P
>Сканирование индекса должно закрепить страницу индекса, на которой находится элемент, возвращённый последним вызовом <CODE
CLASS="FUNCTION"
>amgettuple</CODE
>, а <CODE
CLASS="FUNCTION"
>ambulkdelete</CODE
> не должна удалять записи со страниц, закреплённых другими процессами. Чем обосновано это правило, описывается ниже.</P
></LI
></UL
><P> Без третьего правила читатель индекса мог бы увидеть запись индекса за мгновение до того, как она была удалена процедурой <TT
CLASS="COMMAND"
>VACUUM</TT
>, а затем обратиться к соответствующей записи данных после того, как <TT
CLASS="COMMAND"
>VACUUM</TT
> удалит и её. Это не приведёт к серьёзным проблемам, если данный элемент остаётся незадействованным, когда к нему обращается читатель, так как пустой слот будет игнорироваться функцией <CODE
CLASS="FUNCTION"
>heap_fetch()</CODE
>. Но как быть, если третий процесс уже занял этот слот какими-то своими данными? Когда применяется снимок, совместимый с MVCC, и это не проблема, так как эти данные определённо окажутся слишком новыми при проверке видимости для данного снимка. Однако, для снимка несовместимого с MVCC (например, снимка <TT
CLASS="LITERAL"
>SnapshotAny</TT
>), может так получиться, что будет возвращена строка, на самом деле не соответствующая ключам сканирования. Мы можем защититься от такого исхода, потребовав, чтобы ключи сканирования всегда перепроверялись для строки данных, но это слишком дорогостоящее решение. Вместо этого, мы закрепляем страницу индекса как промежуточный объект, показывающий, что читатель может всё ещё быть <SPAN
CLASS="QUOTE"
>"в пути"</SPAN
> от записи индекса к соответствующей строке данных. Благодаря тому, что <CODE
CLASS="FUNCTION"
>ambulkdelete</CODE
> блокируется при обращении к этой закреплённой странице, процедура <TT
CLASS="COMMAND"
>VACUUM</TT
> не сможет удалить строку данных, пока её извлечение не закончит читатель. Это решение оказывается очень недорогим по времени выполнения, а издержки блокирования привносятся только в редких случаях, когда действительно возникает конфликт.</P
><P
>Такое решение требует, чтобы сканирования индексов выполнялись <SPAN
CLASS="QUOTE"
>"синхронно"</SPAN
>: мы должны выбирать каждый следующий кортеж данных сразу после того получили соответствущую запись индекса. Это оказывается невыгодно по ряду причин. <SPAN
CLASS="QUOTE"
>"Асинхронное"</SPAN
> сканирование, при котором мы собираем множество TID из индекса, и обращаемся за кортежами данных только после этого, влечёт гораздо меньше издержек с блокировками и позволяет обращаться к данным более эффективным образом. Согласно проведённому выше анализу, мы должны использовать синхронный подход для снимков, несовместимых с MVCC, но для запросов со снимками MVCC будет работать и асинхронное сканирование.</P
><P
>При сканировании индекса с <CODE
CLASS="FUNCTION"
>amgetbitmap</CODE
>, метод доступа не закрепляет страницы индекса ни для каких из возвращаемых кортежей. Поэтому такое сканирование можно безопасно применять только со снимками MVCC.</P
><P
>Когда флаг <TT
CLASS="STRUCTFIELD"
>ampredlocks</TT
> не установлен, любое сканирование с данным методом доступа в сериализуемой транзакции будет получать неблокирующую предикатную блокировку для всего индекса. Это будет приводить к конфликту чтения-записи при добавлении любого кортежа в этот индекс параллельной сериализуемой транзакцией. Если среди набора параллельных сериализуемых транзакций выявляются определённые варианты конфликтов чтения-записи, одна из этих транзакций может быть отменена для сохранения целостности данных. Когда данный флаг установлен, это означает, что метод доступа реализует более точную предикатную блокировку, что способствует сокращению частоты отмены транзакций по этой причине.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index-scanning.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="index-unique-checks.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Сканирование индекса</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indexam.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Проверки уникальности в индексе</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>