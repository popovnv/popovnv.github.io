<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Поток сообщений</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Клиент-серверный протокол"
HREF="protocol.html"><LINK
REL="PREVIOUS"
TITLE="Обзор"
HREF="protocol-overview.html"><LINK
REL="NEXT"
TITLE="Протокол потоковой репликации"
HREF="protocol-replication.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Обзор"
HREF="protocol-overview.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="protocol.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 49. Клиент-серверный протокол</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Протокол потоковой репликации"
HREF="protocol-replication.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PROTOCOL-FLOW"
>49.2. Поток сообщений</A
></H1
><P
>В этом разделе описывается поток сообщений и семантика каждого типа сообщений. (Подробнее точное представление каждого сообщения описывается в <A
HREF="protocol-message-formats.html"
>Разделе 49.5</A
>.) В зависимости от состояния соединения выделяются несколько различных подразделов протокола: запуск, запрос, вызов функции, копирование (<TT
CLASS="COMMAND"
>COPY</TT
>) и завершение. Есть также специальные средства для асинхронных операций (в частности, для уведомлений и отмены команд), которые могут выполняться в любой момент после этапа запуска.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN102720"
>49.2.1. Запуск</A
></H2
><P
>Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт стартовое сообщение. В этом сообщении содержатся имена пользователя и базы данных, к которой пользователь хочет подключиться; в нём также определяется, какая именно версия протокола будет использоваться. (Стартовое сообщение также может содержать дополнительные значения для параметров времени выполнения.) Проанализировав эту информацию и содержимое своих файлов конфигурации (в частности, <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>), сервер определяет, можно ли предварительно разрешить это подключение, и какая дополнительная проверка подлинности требуется.</P
><P
>Затем сервер отправляет соответствующее сообщение с запросом аутентификации, на которое клиент должен ответить сообщением, подтверждающим его подлинность (например, по паролю). Для всех методов аутентификации, за исключением GSSAPI и SSPI, может быть максимум один запрос и один ответ. Для некоторых методов ответ клиента вообще не требуется, так что запрос аутентификации также не передаётся. Методы GSSAPI и SSPI для прохождения проверки подлинности могут потребовать выполнить серию обменов пакетами.</P
><P
>Цикл аутентификации заканчивает сервер, либо запрещая соединение (ErrorResponse), либо принимая его (отправляя AuthenticationOk).</P
><P
>Сервер может передавать в этой фазе следующие сообщения: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>ErrorResponse (Ошибочный ответ)</DT
><DD
><P
>Попытка соединения была отвергнута. Сразу после этого сервер закрывает соединение.</P
></DD
><DT
>AuthenticationOk (Аутентификация пройдена)</DT
><DD
><P
>Обмен сообщениями для проверки подлинности завершён успешно.</P
></DD
><DT
>AuthenticationKerberosV5 (Аутентификация Kerberos V5)</DT
><DD
><P
>Клиент должен теперь принять участие в диалоге аутентификации по протоколу Kerberos V5 (здесь его детали не описывается, так как они относятся к спецификации Kerberos) с сервером. Если этот диалог завершается успешно, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Этот вариант аутентификации больше не поддерживается.</P
></DD
><DT
>AuthenticationCleartextPassword (Аутентификация с открытым паролем)</DT
><DD
><P
>Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль в открытом виде. Если пароль правильный, сервер отвечает ему AuthenticationOk, иначе — ErrorResponse.</P
></DD
><DT
>AuthenticationMD5Password (Аутентификация с паролем MD5)</DT
><DD
><P
>Клиент должен передать в ответ сообщение PasswordMessage с результатом преобразования пароля (и имени пользователя) в хеш MD5 с последующим хешированием с четырёхбайтовым случайным значением соли, переданным в сообщении AuthenticationMD5Password. Если пароль правильный, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Содержимое сообщения PasswordMessage можно вычислить в SQL как <TT
CLASS="LITERAL"
>concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</TT
>. (Учтите, что функция <CODE
CLASS="FUNCTION"
>md5()</CODE
> возвращает результат в виде шестнадцатеричной строки.)</P
></DD
><DT
>AuthenticationSCMCredential (Аутентификация по учётным данным SCM)</DT
><DD
><P
>Этот ответ возможен только для локальных подключений через доменные сокеты Unix на платформах, поддерживающих сообщения с учётными данными SCM. Клиент должен выдать сообщение с учётными данными SCM и дополнительно отправить один байт данных. (Содержимое этого байта не представляет интереса; его нужно передавать, только чтобы сервер дожидался сообщения с учётными данными.) Если сервер принимает учётные данные, он отвечает AuthenticationOk, иначе — ErrorResponse. (Этот тип сообщений выдают только серверы версии до 9.1. В конце концов он может быть исключён из спецификации протокола.)</P
></DD
><DT
>AuthenticationGSS (Аутентификация GSS)</DT
><DD
><P
>Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент отправляет PasswordMessage с первой частью потока данных GSSAPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</P
></DD
><DT
>AuthenticationSSPI (Аутентификация SSPI)</DT
><DD
><P
>Клиент должен начать согласование SSPI. В ответ на это сообщение клиент отправляет PasswordMessage с первой частью потока данных SSPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</P
></DD
><DT
>AuthenticationGSSContinue (Продолжение аутентификации GSS)</DT
><DD
><P
>Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом сообщении указывается, что для завершения аутентификации требуются дополнительные данные, клиент должен передать их в очередном сообщении PasswordMessage. Если этим сообщением завершается проверка подлинности GSSAPI или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной проверке подлинности, либо ErrorResponse, сообщая об ошибке.</P
></DD
></DL
></DIV
><P></P
><P
>Если клиент не поддерживает метод проверки подлинности, запрошенный сервером, он должен немедленно закрыть соединение.</P
><P
>Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений от сервера. В этой фазе запускается обслуживающий процесс, а клиент представляет собой просто заинтересованного наблюдателя. Ошибка запуска может быть неудачной (и клиент получит ErrorResponse), но в обычной ситуации обслуживающий процесс передаёт несколько сообщений ParameterStatus, BackendKeyData и, наконец, ReadyForQuery.</P
><P
>В ходе этой фазы обслуживающий процесс попытается применить все параметры времени выполнения, полученные в стартовом сообщении. Если это удастся, эти значения становятся сеансовыми значениями по умолчанию. При ошибке он передаёт ErrorResponse и завершается.</P
><P
>Обслуживающий процесс может передавать в этой фазе следующие сообщения: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>BackendKeyData (Данные ключа сервера)</DT
><DD
><P
>В этом сообщении передаётся секретный ключ, который клиент должен сохранить, чтобы впоследствии иметь возможность выполнять запросы. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</P
></DD
><DT
>ParameterStatus (Состояние параметров)</DT
><DD
><P
>Это сообщение говорит клиенту о текущих (начальных) значениях параметров обслуживающего процесса, например, <A
HREF="runtime-config-client.html#GUC-CLIENT-ENCODING"
>client_encoding</A
> или <A
HREF="runtime-config-client.html#GUC-DATESTYLE"
>DateStyle</A
>. Клиент может проигнорировать это сообщение или сохранить значения для дальнейшего использования; за дополнительными подробностями обратитесь к <A
HREF="protocol-flow.html#PROTOCOL-ASYNC"
>Подразделу 49.2.6</A
>. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</P
></DD
><DT
>ReadyForQuery (Готов к запросам)</DT
><DD
><P
>Запуск завершён. Теперь клиент может выполнять команды.</P
></DD
><DT
>ErrorResponse (Ошибочный ответ)</DT
><DD
><P
>Запуск не удался. Соединение закрывается после передачи этого сообщения.</P
></DD
><DT
>NoticeResponse (Ответ с замечанием)</DT
><DD
><P
>Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но продолжать ожидать сообщения ReadyForQuery или ErrorResponse.</P
></DD
></DL
></DIV
><P></P
><P
>Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, который передаёт сервер после каждого цикла команд. В зависимости от условий реализации клиента, можно воспринимать сообщение ReadyForQuery как начинающее цикл команд, либо как завершающее фазу запуска и каждый последующий цикл команд.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN102795"
>49.2.2. Простой запрос</A
></H2
><P
>Цикл простого запроса начинает клиент, передавая серверу сообщение Query. Это сообщение включает команду (или команды) SQL, выраженную в виде текстовой строки. В ответ сервер передаёт одно или несколько сообщений, в зависимости от строки запроса, и завершает цикл сообщением ReadyForQuery. ReadyForQuery говорит клиенту, что он может безопасно передавать новую команду. (На самом деле клиент может передать следующую команду, не дожидаясь ReadyForQuery, но тогда он сам должен разобраться в ситуации, когда первая команда завершается ошибкой, а последующая выполняется успешно.)</P
><P
>Сервер может передавать в этой фазе следующие ответные сообщения: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>CommandComplete (Команда завершена)</DT
><DD
><P
>Команда SQL выполнена нормально.</P
></DD
><DT
>CopyInResponse (Ответ входящего копирования)</DT
><DD
><P
>Сервер готов копировать данные, получаемые от клиента, в таблицу; см. <A
HREF="protocol-flow.html#PROTOCOL-COPY"
>Подраздел 49.2.5</A
>.</P
></DD
><DT
>CopyOutResponse (Ответ исходящего копирования)</DT
><DD
><P
>Сервер готов копировать данные из таблицы клиенту; см. <A
HREF="protocol-flow.html#PROTOCOL-COPY"
>Подраздел 49.2.5</A
>.</P
></DD
><DT
>RowDescription (Описание строк)</DT
><DD
><P
>Показывает, что в ответ на запрос <TT
CLASS="COMMAND"
>SELECT</TT
>, <TT
CLASS="COMMAND"
>FETCH</TT
> и т. п. будут возвращены строки. В содержимом этого сообщения описывается структура колонок этих строк. За ним для каждой строки, возвращаемой клиенту, следует сообщение DataRow.</P
></DD
><DT
>DataRow (Строка данных)</DT
><DD
><P
>Одна строка из набора, возвращаемого запросом <TT
CLASS="COMMAND"
>SELECT</TT
>, <TT
CLASS="COMMAND"
>FETCH</TT
> и т. п.</P
></DD
><DT
>EmptyQueryResponse (Ответ на пустой запрос)</DT
><DD
><P
>Была принята пустая строка запроса.</P
></DD
><DT
>ErrorResponse (Ошибочный ответ)</DT
><DD
><P
>Произошла ошибка.</P
></DD
><DT
>ReadyForQuery (Готов к запросам)</DT
><DD
><P
>Обработка строки запроса завершена. Чтобы отметить это, отправляется отдельное сообщение, так как строка запроса может содержать несколько команд SQL. (Сообщение CommandComplete говорит о завершении обработки одной команды SQL, а не всей строки.) ReadyForQuery передаётся всегда, и при успешном завершении обработки, и при ошибке.</P
></DD
><DT
>NoticeResponse (Ответ с замечанием)</DT
><DD
><P
>Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать команду.</P
></DD
></DL
></DIV
><P></P
><P
>Ответ на запрос <TT
CLASS="COMMAND"
>SELECT</TT
> (или другие запросы, возвращающие наборы строк, такие как <TT
CLASS="COMMAND"
>EXPLAIN</TT
> и <TT
CLASS="COMMAND"
>SHOW</TT
>) обычно состоит из RowDescription, нуля или нескольких сообщений DataRow, и завершающего CommandComplete. Для команды <TT
CLASS="COMMAND"
>COPY</TT
> с вводом или выводом данных через клиента, применяется специальный протокол, описанный в <A
HREF="protocol-flow.html#PROTOCOL-COPY"
>Подразделе 49.2.5</A
>. Со всеми другими типами запросами обычно выдаётся только сообщение CommandComplete.</P
><P
>Так как строка запроса может содержать несколько запросов (разделённых точкой с запятой), до завершения обработки всей строки сервер может передать несколько серий таких ответов. Когда сервер завершает обработку всей строки и готов принять следующую строку запроса, он выдаёт сообщение ReadyForQuery.</P
><P
>Если получена полностью пустая строка запроса (не содержащая ничего, кроме пробельных символов), ответом будет EmptyQueryResponse с последующим ReadyForQuery.</P
><P
>В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. Сообщение ErrorResponse прерывает дальнейшую обработку строки запроса (даже если в ней остались другие запросы). Заметьте, что оно может быть выдано и в середине последовательности сообщений, выдаваемых в ответ на отдельный запрос.</P
><P
>В режиме простых запросов получаемые значения всегда передаются в текстовом формате, за исключением результатов команды <TT
CLASS="COMMAND"
>FETCH</TT
> для курсора, объявленного с атрибутом <TT
CLASS="LITERAL"
>BINARY</TT
>. С такой командой значения передаются в двоичном формате. Какой именно формат используется, определяют коды формата, передаваемые в сообщении RowDescription.</P
><P
>Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, ожидая любой другой тип сообщений. Также обратитесь к <A
HREF="protocol-flow.html#PROTOCOL-ASYNC"
>Подразделу 49.2.6</A
> за информацией о сообщениях, которые сервер может выдавать в ответ на внешние события.</P
><P
>Код клиента рекомендуется реализовывать в виде машины состояний, которая в любой момент будет принимать сообщения всех типов, имеющих смысл на данном этапе, но не программировать жёстко обработку точной последовательности сообщений.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-FLOW-EXT-QUERY"
>49.2.3. Расширенный запрос</A
></H2
><P
>Протокол расширенных запросов разбивает вышеописанный протокол простых запросов на несколько шагов. Результаты подготовительных шагов можно неоднократно использовать повторно для улучшения эффективности. Кроме того, он открывает дополнительные возможности, в частности, возможность передавать значения данных в отдельных параметрах вместо того, чтобы внедрять их непосредственно в строку запроса.</P
><P
>В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой строкой запроса и, возможно, некоторыми сведениями о типах параметров и именем целевого объекта подготовленного оператора (если имя пустое, создаётся безымянный подготовленный оператор). Ответом на это сообщение будет ParseComplete или ErrorResponse. Типы параметров указываются по OID; при отсутствии явного указания анализатор запроса пытается определить типы данных так же, как он делал бы для нетипизированных строковых констант.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Тип данных параметра можно оставить неопределённым, задав для него значение ноль, либо сделав массив с OID типов параметров короче, чем набор символов параметров (<TT
CLASS="LITERAL"
>$</TT
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>), используемых в строке запроса. Другой особый случай — передача типа параметра как <TT
CLASS="TYPE"
>void</TT
> (то есть передача OID псевдотипа <TT
CLASS="TYPE"
>void</TT
>). Это предусмотрено для того, чтобы символы параметров можно было использовать для параметров функций, на самом деле представляющих собой параметры OUT. Обычно параметр <TT
CLASS="TYPE"
>void</TT
> нельзя использовать ни в каком контексте, но если такой параметр фигурирует в списке параметров функции, он фактически игнорируется. Например, вызову функции <TT
CLASS="LITERAL"
>foo($1,$2,$3,$4)</TT
> может соответствовать функция с аргументами IN и двумя OUT, если аргументы <TT
CLASS="LITERAL"
>$3</TT
> и <TT
CLASS="LITERAL"
>$4</TT
> объявлены как имеющие тип <TT
CLASS="TYPE"
>void</TT
>.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Строка запроса, содержащаяся в сообщении Parse, не может содержать больше одного оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение отсутствует в протоколе простых запросов, но присутствует в расширенном протоколе, так как добавление поддержки подготовленных операторов или порталов, содержащих несколько команд, неоправданно усложнило бы протокол.</P
></BLOCKQUOTE
></DIV
><P
>В случае успешного создания именованный подготовленный оператор продолжает существовать до завершения текущего сеанса, если только он не будет уничтожен явно. Безымянный подготовленный оператор сохраняется только до следующей команды Parse, в которой целевым является безымянный оператор. (Заметьте, что сообщение простого запроса также уничтожает безымянный оператор.) Именованные операторы должны явно закрываться, прежде чем их можно будет переопределить другим сообщением Parse, но для безымянных операторов это не требуется. Именованные подготовленные операторы также можно создавать и вызывать на уровне команд SQL, используя команды <TT
CLASS="COMMAND"
>PREPARE</TT
> и <TT
CLASS="COMMAND"
>EXECUTE</TT
>.</P
><P
>Когда подготовленный оператор существует, его можно подготовить к выполнению сообщением Bind. В сообщении Bind задаётся имя исходного подготовленного оператора (пустая строка подразумевает безымянный подготовленный оператор), имя целевого портала (пустая строка подразумевает безымянный портал) и значения для любых шаблонов параметров, представленных в подготовленном операторе. Набор передаваемых значений должен соответствовать набору параметров, требующихся для подготовленного оператора. (Если вы объявили параметры <TT
CLASS="TYPE"
>void</TT
> в сообщении Parse, передайте для них значения NULL в сообщении Bind.) Bind также принимает указание формата для данных, возвращаемых в результате запроса; формат можно указать для всех данных, либо для отдельных колонок. Ответом на это сообщение будет BindComplete или ErrorResponse.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Выбор между текстовым и двоичным форматом вывода определяется кодами формата, передаваемыми в Bind, вне зависимости от команды SQL. При использовании протокола расширенных запросов атрибут <TT
CLASS="LITERAL"
>BINARY</TT
> в объявлении курсоров не имеет значения.</P
></BLOCKQUOTE
></DIV
><P
>Планирование запроса обычно имеет место при обработке сообщения Bind. Если подготовленный оператор не имеет параметров, либо он выполняется многократно, сервер может сохранить созданный план и использовать его повторно при последующих сообщениях Bind для того же подготовленного оператора. Однако он будет делать это, только если решит, что можно получить универсальный план, который не будет значительно неэффективнее планов, зависящих от конкретных значений параметров. С точки зрения протокола это происходит незаметно.</P
><P
>В случае успешного создания объект именованного портала продолжает существование до конца текущей транзакции, если только он не будет уничтожен явно. Безымянный портал уничтожается в конце транзакции или при выполнении следующей команды Bind, в которой в качестве целевого выбирается безымянный портал. (Заметьте, что сообщение простого запроса также уничтожает безымянный портал.) Именованные порталы должны явно закрываться, прежде чем их можно будет явно переопределить другим сообщением Bind, но это не требуется для безымянных порталов. Именованные порталы также можно создавать и вызывать на уровне команд SQL, используя команды <TT
CLASS="COMMAND"
>DECLARE CURSOR</TT
> и <TT
CLASS="COMMAND"
>FETCH</TT
>.</P
><P
>Когда портал существует, его можно запустить на выполнение сообщением Execute. В сообщении Execute указывается имя портала (пустая строка подразумевает безымянный портал) и максимальное число результирующих строк (ноль означает <SPAN
CLASS="QUOTE"
>"выбрать все строки"</SPAN
>). Число результирующих строк имеет значение только для порталов, которые содержат команды, возвращающие наборы строк; в других случаях команда всегда выполняется до завершения и число строк игнорируется. В ответ на Execute могут быть получены те же сообщения, что описаны выше для запросов, выполняемых через протокол простых запросов, за исключением того, что после Execute не выдаются сообщения ReadyForQuery и RowDescription.</P
><P
>Если операция Execute оканчивается до завершения выполнения портала (из-за достижения ненулевого ограничения на число строк), сервер отправляет сообщение PortalSuspended; появление этого сообщения говорит клиенту о том, что для завершения операции с данным порталом нужно выдать ещё одно сообщение Execute. Сообщение CommandComplete, говорящее о завершении исходной команды SQL, не передаётся до завершения выполнения портала. Таким образом, фаза Execute всегда заканчивается при появлении одного из сообщений: CommandComplete, EmptyQueryResponse (если портал был создан из пустой строки запроса), ErrorResponse или PortalSuspended.</P
><P
>В конце каждой серии сообщений расширенных запросов клиент должен выдать сообщение Sync. Получив это сообщение без параметров, сервер закрывает текущую транзакцию, если команды выполняются не внутри блока транзакции <TT
CLASS="COMMAND"
>BEGIN</TT
>/<TT
CLASS="COMMAND"
>COMMIT</TT
> (под <SPAN
CLASS="QUOTE"
>"закрытием"</SPAN
> понимается фиксация при отсутствии ошибок или откат в противном случае). Затем он выдаёт ответ ReadyForQuery. Целью сообщения Sync является обозначение точки синхронизации для восстановления в случае ошибок. Если при обработке сообщений расширенных запросов происходит ошибка, сервер выдаёт ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего выдаёт ReadyForQuery и возвращается к обычной обработке сообщений. (Но заметьте, что он не будет пропускать следующие сообщения, если ошибка происходит <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>в процессе</I
></SPAN
> обработки Sync &mdash; это гарантирует, что для каждого Sync будет передаваться в точности одно сообщение ReadyForQuery.)</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Сообщение Sync не приводит к закрытию блока транзакции, открытого командой <TT
CLASS="COMMAND"
>BEGIN</TT
>. Выявить эту ситуацию можно, используя информацию о состоянии транзакции, содержащуюся в сообщении ReadyForQuery.</P
></BLOCKQUOTE
></DIV
><P
>В дополнение к этим фундаментальным и обязательным операциям, протокол расширенных запросов позволяет выполнить и несколько дополнительных операций.</P
><P
>В сообщении Describe (в вариации для портала) задаётся имя существующего портала (пустая строка обозначает безымянный портал). В ответ передаётся сообщение RowDescription, описывающее строки, которые будут возвращены при выполнении портала; либо сообщение NoData, если портал не содержит запроса, возвращающего строки; либо ErrorResponse, если такого портала нет.</P
><P
>В сообщении Describe (в вариации для оператора) задаётся имя существующего подготовленного оператора (пустая строка обозначает безымянный подготовленный оператор). В ответ передаётся сообщение ParameterDescription, описывающее параметры, требующиеся для оператора, за которым следует сообщение RowDescription, описывающее строки, которые будут возвращены, когда оператор будет собственно выполнен (или сообщение NoData, если оператор не возвратит строки). ErrorResponse выдаётся, если такой подготовленный оператор отсутствует. Заметьте, что так как команда Bind не выполнялась, сервер ещё не знает, в каком формате будут возвращаться колонки; в этом случае поля кодов формата в сообщении RowDescription будут содержать нули.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>В большинстве случаев клиент должен выдать ту или иную вариацию Describe, прежде чем выдавать Execute, чтобы понять, как интерпретировать результаты, которые он получит.</P
></BLOCKQUOTE
></DIV
><P
>Сообщение Close закрывает существующий подготовленный оператор или портал и освобождает связанные ресурсы. При попытке выполнить Close для имени несуществующего портала или оператора ошибки не будет. Ответ на это сообщение обычно CloseComplete, но может быть и ErrorResponse, если при освобождении ресурсов возникают проблемы. Заметьте, что при закрытии подготовленного оператора неявно закрываются все открытые порталы, которые были получены из этого оператора.</P
><P
>Сообщение Flush не приводит к генерации каких-либо данных, а указывает серверу передать все данные, находящиеся в очереди в его буферах вывода. Сообщение Flush клиент должен отправлять после любой команды расширенных запросов, кроме Sync, если он желает проанализировать результаты этой команды, прежде чем выдавать следующие команды. Без Flush сообщения, возвращаемые сервером, будут объединяться вместе в минимальное количество пакетов с целью уменьшения сетевого трафика.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Простое сообщение Query примерно равнозначно последовательности сообщений Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием объектов подготовленного оператора и портала без имён и без параметров. Одно отличие состоит в том, что такое сообщение может содержать в строке запроса несколько операторов SQL, для каждого из которых по очереди автоматически выполняется последовательность Bind/Describe/Execute. Другое отличие состоит в том, что в ответ на него не приходят сообщения ParseComplete, BindComplete, CloseComplete или NoData.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN102906"
>49.2.4. Вызов функций</A
></H2
><P
>Подраздел протокола &laquo;Вызов функций&raquo; позволяет клиенту запросить непосредственный вызов любой функции, существующей в системном каталоге <TT
CLASS="STRUCTNAME"
>pg_proc</TT
>. При этом клиент должен иметь право на выполнение этой функции.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Этот подраздел протокола считается устаревшим и в новом коде использовать его не следует. Примерно тот же результат можно получить, подготовив оператор с командой <TT
CLASS="LITERAL"
>SELECT function($1, ...)</TT
>. При таком подходе цикл вызова функции заменяется последовательностью Bind/Execute.</P
></BLOCKQUOTE
></DIV
><P
>Цикл вызова функции начинает клиент, передавая серверу сообщение FunctionCall. Сервер возвращает одно или несколько сообщений ответа, в зависимости от результата вызова функции, и завершающее сообщение ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно передавать новый запрос или вызов функции.</P
><P
>Сервер может передавать в этой фазе следующие ответные сообщения: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>ErrorResponse (Ошибочный ответ)</DT
><DD
><P
>Произошла ошибка.</P
></DD
><DT
>FunctionCallResponse (Ответ на вызов функции)</DT
><DD
><P
>Вызов функции завершён и в этом сообщении передаётся её результат. (Заметьте, что протокол вызова функций позволяет выдать только один скалярный результат, но не кортеж или набор результатов.)</P
></DD
><DT
>ReadyForQuery (Готов к запросам)</DT
><DD
><P
>Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, независимо от того, была ли функция выполнена успешно или с ошибкой.</P
></DD
><DT
>NoticeResponse (Ответ с замечанием)</DT
><DD
><P
>Выдаётся предупреждение, связанное с вызовом функции. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать вызов.</P
></DD
></DL
></DIV
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-COPY"
>49.2.5. Операции COPY</A
></H2
><P
>Команда <TT
CLASS="COMMAND"
>COPY</TT
> позволяет обеспечить скоростную передачу данных на сервер или с сервера. Операции входящего и исходящего копирования переключают соединение в отдельные режимы протокола, которые завершаются только в конце операции.</P
><P
>Режим входящего копирования (передача данных на сервер) включается, когда клиент выполняет SQL-оператор <TT
CLASS="COMMAND"
>COPY FROM STDIN</TT
>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyInResponse. После этого клиент должен передать ноль или более сообщений CopyData, образующих поток входных данных. (При этом границы сообщений не обязательно должны совпадать с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может завершить режим входящего копирования, передав либо сообщение CopyDone (говорящее об успешном завершении), либо CopyFail (которое приведёт к завершению SQL-оператора <TT
CLASS="COMMAND"
>COPY</TT
> с ошибкой). При этом сервер вернётся в обычный режим обработки, в котором он находился до выполнения команды <TT
CLASS="COMMAND"
>COPY</TT
> (это может быть протокол простых или расширенных запросов). Затем он отправит сообщение CommandComplete (в случае успешного завершения) или ErrorResponse (в противном случае).</P
><P
>В случае возникновения ошибки в режиме входящего копирования (включая получение сообщения CopyFail), сервер выдаёт сообщение ErrorResponse. Если команда <TT
CLASS="COMMAND"
>COPY</TT
> была получена в сообщении расширенного запроса, сервер не будет обрабатывать последующие сообщения клиента, пока не получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в обычный режим работы. Если команда <TT
CLASS="COMMAND"
>COPY</TT
> была получена в сообщении простого запроса, остальная часть сообщения игнорируется и сразу выдаётся ReadyForQuery. В любом случае все последующие сообщения CopyData, CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться.</P
><P
>В режиме входящего копирования сервер игнорирует поступающие сообщения Flush и Sync. При поступлении сообщений любого другого типа, не связанного с копированием, возникает ошибка, приводящая к прерыванию режима входящего копирования, как описано выше. (Исключение для сообщений Flush и Sync сделано для удобства клиентских библиотек, которые всегда передают Flush или Sync после сообщения Execute, не проверяя, не запускается ли в нём команда <TT
CLASS="COMMAND"
>COPY FROM STDIN</TT
>.)</P
><P
>Режим исходящего копирования (передача данных с сервера) включается, когда клиент выполняет SQL-оператор <TT
CLASS="COMMAND"
>COPY TO STDOUT</TT
>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyOutResponse, за ним ноль или более сообщений CopyData (всегда одно сообщение для каждой строки) и в завершение CopyDone. Затем сервер возвращается в обычный режим обработки, в котором он находился до выполнения команды <TT
CLASS="COMMAND"
>COPY</TT
>, и передаёт CommandComplete. Клиент не может прервать передачу (кроме как закрыв соединение или выдав запрос Cancel), но он может игнорировать ненужные ему сообщения CopyData и CopyDone.</P
><P
>В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт сообщение ErrorResponse и возвращается к обычной обработке. Клиент должен воспринимать поступление ErrorResponse как завершение режима исходящего копирования.</P
><P
>Между сообщениями CopyData могут поступать сообщения NoticeResponse и ParameterStatus; клиенты должны обрабатывать их и быть готовы принимать и другие типы асинхронных сообщений (см. <A
HREF="protocol-flow.html#PROTOCOL-ASYNC"
>Подраздел 49.2.6</A
>). В остальном, сообщения любых типов, кроме CopyData и CopyDone, могут восприниматься как завершающие режим исходящего копирования.</P
><P
>Есть ещё один режим копирования, называемый двусторонним копированием и обеспечивающий высокоскоростную передачу данных на <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>и</I
></SPAN
> с сервера. Двустороннее копирование запускается, когда клиент в режиме walsender выполняет оператор <TT
CLASS="COMMAND"
>START_REPLICATION</TT
>. В ответ сервер передаёт клиенту сообщение CopyBothResponse. Затем и сервер, и клиент могут передавать друг другу сообщения CopyData, пока кто-то из них не завершит передачу сообщением CopyDone. Когда сообщение CopyDone передаёт клиент, соединение переходит из режима двустороннего в режим исходящего копирования и клиент больше не может передавать сообщения CopyData. Аналогично, когда сообщение CopyDone передаёт сервер, соединение переходит в режим входящего копирования и сервер больше не может передавать сообщения CopyData. Когда сообщения CopyDone переданы обеими сторонами, режим копирования завершается и сервер возвращается в режим обработки команд. В случае обнаружения ошибки на стороне сервера в режиме двустороннего копирования, сервер выдаёт сообщение ErrorResponse, пропускает следующие сообщения клиента, пока не будет получено сообщение Sync, а затем выдаёт ReadyForQuery и возвращается к обычной обработке. Клиент должен воспринимать получение ErrorResponse как завершение двустороннего копирования; в этом случае сообщение CopyDone посылаться не должно. За дополнительной информацией о подразделе протокола, управляющем двусторонним копированием, обратитесь к <A
HREF="protocol-replication.html"
>Разделу 49.3</A
>.</P
><P
>Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, из которых клиент может узнать количество колонок в строке и код формата для каждой колонки. (В текущей реализации для всех колонок в заданной операции <TT
CLASS="COMMAND"
>COPY</TT
> устанавливается один формат, но в конструкции сообщения это не заложено.)</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-ASYNC"
>49.2.6. Асинхронные операции</A
></H2
><P
>Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не предполагаемые потоком команд в текущем режиме. Клиенты должны быть готовы принять эти сообщения в любой момент, даже не в процессе выполнения запроса. Как минимум, следует проверять такие сообщения, прежде чем начинать читать ответ на запрос.</P
><P
>Сообщения NoticeResponse могут выдаваться вследствие внешней активности; например, если администратор инициирует <SPAN
CLASS="QUOTE"
>"быстрое"</SPAN
> отключение баз данных, сервер отправит NoticeResponse, сигнализирующее об этом факте, прежде чем закрывать соединение. Соответственно, клиенты должны быть готовы всегда принять и вывести сообщения NoticeResponse, даже когда соединение фактически простаивает.</P
><P
>Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется действующее значение одного из параметров, об изменении которых, по мнению сервера, должен знать клиент. Чаще всего это происходит в ответ на SQL-команду <TT
CLASS="COMMAND"
>SET</TT
>, выполняемую клиентом и в таком случае это сообщение по сути синхронно &mdash; но состояние параметров может меняться и когда администратор изменяет файл конфигурации, а затем посылает серверу сигнал <SPAN
CLASS="SYSTEMITEM"
>SIGHUP</SPAN
>. Также, если действие команды <TT
CLASS="COMMAND"
>SET</TT
> отменяется, клиенту передаётся сообщение ParameterStatus, в котором отражается текущее значение параметра.</P
><P
>В настоящее время есть жёстко зафиксированный набор параметров, при изменении которых выдаётся ParameterStatus: <TT
CLASS="VARNAME"
>server_version</TT
>, <TT
CLASS="VARNAME"
>server_encoding</TT
>, <TT
CLASS="VARNAME"
>client_encoding</TT
>, <TT
CLASS="VARNAME"
>application_name</TT
>, <TT
CLASS="VARNAME"
>is_superuser</TT
>, <TT
CLASS="VARNAME"
>session_authorization</TT
>, <TT
CLASS="VARNAME"
>DateStyle</TT
>, <TT
CLASS="VARNAME"
>IntervalStyle</TT
>, <TT
CLASS="VARNAME"
>TimeZone</TT
>, <TT
CLASS="VARNAME"
>integer_datetimes</TT
> и <TT
CLASS="VARNAME"
>standard_conforming_strings</TT
>. (<TT
CLASS="VARNAME"
>server_encoding</TT
>, <TT
CLASS="VARNAME"
>TimeZone</TT
> и <TT
CLASS="VARNAME"
>integer_datetimes</TT
> не отслеживались до версии 8.0; <TT
CLASS="VARNAME"
>standard_conforming_strings</TT
> не отслеживался до 8.1; <TT
CLASS="VARNAME"
>IntervalStyle</TT
> — до версии 8.4; <TT
CLASS="VARNAME"
>application_name</TT
> — до версии 9.0.) Заметьте, что <TT
CLASS="VARNAME"
>server_version</TT
>, <TT
CLASS="VARNAME"
>server_encoding</TT
> и <TT
CLASS="VARNAME"
>integer_datetimes</TT
> — это псевдопараметры, которые не могут меняться после запуска сервера. Этот набор может быть изменён в будущем или даже будет настраиваемым. Соответственно, клиент может просто игнорировать сообщения ParameterStatus для параметров, которые ему неизвестны или не представляют интереса.</P
><P
>Если клиент выполняет команду <TT
CLASS="COMMAND"
>LISTEN</TT
>, сервер будет передавать ему сообщения NotificationResponse (не путайте с NoticeResponse!), когда для канала с тем же именем затем будет выполняться команда <TT
CLASS="COMMAND"
>NOTIFY</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>В настоящее время, сообщение NotificationResponse может быть передано только вне транзакции, так что оно не может оказаться в середине серии ответов на команду, хотя может поступить сразу после ReadyForQuery. Однако полагаться на это при проектировании логики клиента неразумно. Лучше разработать код так, чтобы NotificationResponse могло быть принято в любой фазе протокола.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN102992"
>49.2.7. Отмена выполняющихся запросов</A
></H2
><P
>В процессе обработки запроса клиент может запросить отмену этого запроса. Запрос отмены не передаётся серверу непосредственно через открытое соединение из соображений эффективности: мы не хотим, чтобы сервер постоянно проверял поступающие от клиента сообщения в процессе выполнения запроса. Запросы отмены должны быть относительно редкими, поэтому мы выбрали для них не самый простой путь во избежание негативного влияния на обычный режим работы.</P
><P
>Чтобы запросить отмену запроса, клиент должен установить новое подключение к серверу и отправить ему сообщение CancelRequest, вместо StartupMessage, обычно передаваемого при установлении нового подключения. Сервер обработает полученную команду и закроет это подключение. По соображениям безопасности сервер не отвечает непосредственно на сообщение с запросом отмены.</P
><P
>Сообщение CancelRequest обрабатывается, только если оно содержит те же ключевые данные (PID и секретный ключ), что были переданы клиенту при запуске. Если PID и секретный ключ в запросе соответствуют данным выполняющегося в данный момент обслуживающего процесса, обработка текущего запроса в нём прерывается. (В существующей реализации это осуществляется путём передачи специального сигнала данному обслуживающему процессу.)</P
><P
>Сигнал отмены может подействовать, а может и не подействовать (например, если он поступит после того, как сервер завершит обработку запроса). Если отмена действительно происходит, текущая команда прерывается досрочно с сообщением об ошибке.</P
><P
>Вследствие такой организации, объясняемой соображениями безопасности и эффективности, клиент не может непосредственно определить, был ли запрос отмены успешен. Он должен продолжать ожидать ответа сервера на исходный запрос. Запрос отмены просто увеличивает вероятность того, что текущий запрос завершится быстрее, как и вероятность того, что он будет завершён не успешно, а с ошибкой.</P
><P
>Так как запрос отмены передаётся серверу через новое подключение к серверу, а не через обычный канал связи клиент-сервер, такие запросы могут выдавать любые процессы, а не только клиентский процесс, запрос которого требуется отменить. Это может дать дополнительную гибкость при построении многопроцессных приложений. Это также представляет собой угрозу безопасности, так как попытаться отменить запросы могут и неавторизованные пользователи. Для ликвидации этой угрозы в запросах отмены требуется передавать динамически генерируемый секретный ключ.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN103000"
>49.2.8. Завершение</A
></H2
><P
>Обычная процедура мягкого завершения заключается в том, что клиент отправляет сообщение Terminate и немедленно закрывает соединение. Получая это сообщение, обслуживающий процесс закрывает соединение и завершается.</P
><P
>В редких случаях (например, при отключении базы данных по команде администратора) обслуживающий процесс может отключиться, даже если клиент не запрашивает этого. В таких случаях, перед тем, как закрыть соединение, этот процесс пытается передать сообщение с ошибкой или уведомлением, в котором будет указана причина отключения.</P
><P
>Другие сценарии завершения возникают с различными вариантами отказа, например, при критическом сбое с дампом памяти на одной или другой стороне, при потере канала соединения, потере синхронизации по границам сообщений и т. д. Если клиент или сервер обнаруживает, что соединение было неожиданно закрыто, он должен очистить ресурсы и завершиться. Клиент при этом может запустить новый обслуживающий процесс, переподключившись к серверу, если он сам хочет продолжать работу. Закрывать соединение также рекомендуется при получении сообщений нераспознанного типа, так как это может быть признаком потери синхронизации по границам сообщений.</P
><P
>При штатном или нештатном завершении сеанса любая открытая транзакция откатывается, а не фиксируется. Однако следует заметить, что при отключении клиента в процессе обработки запроса, отличного от <TT
CLASS="COMMAND"
>SELECT</TT
>, обслуживающий процесс вероятнее всего завершит запрос, прежде чем заметит отключение. Если запрос выполняется не в блоке транзакции (вне последовательности <TT
CLASS="COMMAND"
>BEGIN</TT
> ... <TT
CLASS="COMMAND"
>COMMIT</TT
>), его результаты могут быть зафиксированы до того, как будет обнаружено отключение.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN103009"
>49.2.9. Защита сеанса с <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
></A
></H2
><P
>Если <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> был собран с поддержкой <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>, взаимодействие клиента с сервером может быть зашифровано с применением <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>. Это обеспечивает защиту на уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. За дополнительными сведениями о шифровании трафика сеансов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> с использованием <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>, обратитесь к <A
HREF="ssl-tcp.html"
>Разделу 17.9</A
>.</P
><P
>Чтобы начать сеанс с <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>-шифрованием, клиент передаёт серверу вместо StartupMessage сообщение SSLRequest. В ответ сервер передаёт один байт, содержащий символ <TT
CLASS="LITERAL"
>S</TT
> или <TT
CLASS="LITERAL"
>N</TT
>, показывающий, что он желает, либо не желает включать <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>, соответственно. Если клиент не удовлетворён ответом, он должен закрыть соединение на этом этапе. Чтобы продолжить установление соединения после получения <TT
CLASS="LITERAL"
>S</TT
>, он выполняет начальное согласование <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> с сервером (не описывается здесь, так как относится к протоколу <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>). Если эта процедура выполняется успешно, он продолжает соединение, передавая обычное сообщение StartupMessage. При этом StartupMessage и все последующие данные будут защищены <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>-шифрованием. Чтобы продолжить после получения <TT
CLASS="LITERAL"
>N</TT
>, клиент может передать обычное сообщение StartupMessage и дальше взаимодействовать с сервером без шифрования.</P
><P
>Клиент также должен быть готов обработать сообщение ErrorMessage, полученное от сервера в ответ на SSLRequest. Такая ситуация возможна, только если сервер имеет версию, которая ещё не поддерживала <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. (Такие серверы сейчас антикварная редкость, и скорее всего их уже не встретить в природе.) В этом случае соединение должно быть закрыто, но клиент может решить открыть новое соединение, не запрашивая <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>-шифрование.</P
><P
>Начальный запрос SSLRequest может также передаваться при установлении соединения, открываемого для передачи сообщения CancelRequest.</P
><P
>Так как в самом протоколе не предусмотрено принудительное включение <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>-шифрования сервером, администратор может настроить сервер так, чтобы в качестве дополнительного условия при проверке подлинности клиента он не принимал незашифрованные сеансы.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="protocol-overview.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="protocol-replication.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Обзор</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="protocol.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Протокол потоковой репликации</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>