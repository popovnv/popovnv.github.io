<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Проверки целостности данных на уровне приложения</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Управление конкурентным доступом"
HREF="mvcc.html"><LINK
REL="PREVIOUS"
TITLE="Явные блокировки"
HREF="explicit-locking.html"><LINK
REL="NEXT"
TITLE="Блокировки и индексы"
HREF="locking-indexes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Явные блокировки"
HREF="explicit-locking.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 13. Управление конкурентным доступом</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Блокировки и индексы"
HREF="locking-indexes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="APPLEVEL-CONSISTENCY"
>13.4. Проверки целостности данных на уровне приложения</A
></H1
><P
>Используя транзакции Read Committed, очень сложно обеспечить целостность данных с точки зрения бизнес-логики, так как представление данных смещается с каждым оператором и даже один оператор может не ограничиваться своим снимком состояния в случае конфликта записи.</P
><P
>Хотя транзакция Repeatable Read получает стабильное представление данных в процессе выполнения, с использованием снимков <ACRONYM
CLASS="ACRONYM"
>MVCC</ACRONYM
> для проверки целостности данных всё же связаны тонкие моменты, включая так называемые <I
CLASS="FIRSTTERM"
>конфликты чтения/записи</I
>. Если одна транзакция записывает данные, а другая в это же время пытается их прочитать (до или после записи), она не может увидеть результат работы первой. В таком случае создаётся впечатление, что читающая транзакция выполняется первой вне зависимости от того, какая из них была начата или зафиксирована раньше. Если этим всё и ограничивается, нет никаких проблем, но если читающая транзакция также пишет данные, которые читает параллельная транзакция, получается, что теперь эта транзакция будет исполняться, как будто она запущена перед другими вышеупомянутыми. Если же транзакция, которая должна исполняться как последняя, на самом деле зафиксирована первой, в графе упорядоченных транзакций легко может возникнуть цикл. И когда он возникает, проверки целостности не будут работать правильно без дополнительных мер.</P
><P
>Как было сказано в <A
HREF="transaction-iso.html#XACT-SERIALIZABLE"
>Подразделе 13.2.3</A
>, сериализуемые транзакции представляют собой те же транзакции Repeatable Read, но дополненные неблокирующим механизмом отслеживания опасных условий конфликтов чтения/записи. Когда выявляется условие, приводящее к циклу в порядке транзакций, одна из этих транзакций откатывается и этот цикл таким образом разрывается.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SERIALIZABLE-CONSISTENCY"
>13.4.1. Обеспечение согласованности в сериализуемых транзакциях</A
></H2
><P
>Если для всех операций чтения и записи, нуждающихся в согласованном представлении данных, используются транзакции уровня изоляции Serializable, это обеспечивает необходимую согласованность без дополнительных усилий. Приложения из других окружений, применяющие сериализуемые транзакции для обеспечения целостности, в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> в этом смысле будут <SPAN
CLASS="QUOTE"
>"просто работать"</SPAN
>.</P
><P
>Применение этого подхода избавляет программистов приложений от лишних сложностей, если приложение использует инфраструктуру, которая автоматически повторяет транзакции в случае отката из-за сбоев сериализации. Возможно, <TT
CLASS="LITERAL"
>serializable</TT
> стоит даже установить в качестве уровня изоляции по умолчанию (<TT
CLASS="LITERAL"
>default_transaction_isolation</TT
>). Также имеет смысл принять меры для предотвращения использования других уровней изоляции, непреднамеренного или с целью обойти проверки целостности, например проверять уровень изоляции в триггерах.</P
><P
>Рекомендации по увеличению быстродействия приведены в <A
HREF="transaction-iso.html#XACT-SERIALIZABLE"
>Подразделе 13.2.3</A
>.</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Внимание</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Защита целостности с применением сериализуемых транзакций пока ещё не поддерживается в режиме горячего резерва (<A
HREF="hot-standby.html"
>Раздел 25.5</A
>). Поэтому там, где применяется горячий резерв, следует использовать уровень Repeatable Read и явные блокировки на главном сервере.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NON-SERIALIZABLE-CONSISTENCY"
>13.4.2. Применение явных блокировок для обеспечения согласованности</A
></H2
><P
>Когда возможны не сериализуемые операции записи, для обеспечения целостности строк и защиты от одновременных изменений, следует использовать <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>, <TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
> или соответствующий оператор <TT
CLASS="COMMAND"
>LOCK TABLE</TT
>. (<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> и <TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
> защищают от параллельных изменений только возвращаемые строки, тогда как <TT
CLASS="COMMAND"
>LOCK TABLE</TT
> блокирует всю таблицу.) Это следует учитывать, перенося в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> приложения из других СУБД.</P
><P
>Мигрируя в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> из других СУБД также следует учитывать, что команда <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> сама по себе не гарантирует, что параллельная транзакция не изменит или не удалит выбранную строку. Для получения такой гарантии в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> нужно именно изменить эту строку, даже если никакие значения в ней менять не требуется. <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>временно блокирует</I
></SPAN
> другие транзакции, не давая им получить ту же блокировку или выполнить команды <TT
CLASS="COMMAND"
>UPDATE</TT
> или <TT
CLASS="COMMAND"
>DELETE</TT
>, которые бы повлияли на заблокированную строку, но как только транзакция, владеющая этой блокировкой, фиксируется или откатывается, заблокированная транзакция сможет выполнить конфликтующую операцию, если только для данной строки действительно не был выполнен <TT
CLASS="COMMAND"
>UPDATE</TT
>, пока транзакция владела блокировкой.</P
><P
>Реализация глобальной целостности с использованием не сериализуемых транзакций <ACRONYM
CLASS="ACRONYM"
>MVCC</ACRONYM
> требует более вдумчивого подхода. Например, банковскому приложению может потребоваться проверить, равняется ли сумма всех расходов в одной таблице сумме приходов в другой, при том, что обе таблицы активно изменяются. Просто сравнивать результаты двух успешных последовательных команд <TT
CLASS="LITERAL"
>SELECT sum(...)</TT
> в режиме Read Committed нельзя, так как вторая команда может захватить результаты транзакций, пропущенных первой. Подсчитывая суммы в одной транзакции Repeatable Read, можно получить точную картину только для транзакций, которые были зафиксированы до начала данной, но при этом может возникнуть законный вопрос &mdash; будет ли этот результат актуален тогда, когда он будет выдан. Если транзакция Repeatable Read сама вносит какие-то изменения, прежде чем проверять равенство сумм, полезность этой проверки становится ещё более сомнительной, так как при проверке будут учитываться некоторые, но не все изменения, произошедшие после начала транзакции. В таких случаях предусмотрительный разработчик может заблокировать все таблицы, задействованные в проверке, чтобы получить картину действительности, не вызывающую сомнений. Для этого применяется блокировка <TT
CLASS="LITERAL"
>SHARE</TT
> (или более строгая), которая гарантирует, что в заблокированной таблице не будет незафиксированных изменений, за исключением тех, что внесла текущая транзакция.</P
><P
>Также заметьте, что, применяя явные блокировки для предотвращения параллельных операций записи, следует использовать либо режим Read Committed, либо в режиме Repeatable Read обязательно получать блокировки прежде, чем выполнять запросы. Блокировка, получаемая транзакцией Repeatable Read, гарантирует, что никакая другая транзакция, изменяющая таблицу, не выполняется, но если снимок состояния, полученный транзакций, предшествует блокировке, он может не включать на данный момент уже зафиксированные изменения. Снимок состояния в транзакции Repeatable Read создаётся фактически на момент начала первой команды выборки или изменения данных (<TT
CLASS="LITERAL"
>SELECT</TT
>, <TT
CLASS="LITERAL"
>INSERT</TT
>, <TT
CLASS="LITERAL"
>UPDATE</TT
> или <TT
CLASS="LITERAL"
>DELETE</TT
>), так что получить явные блокировки можно до того, как он будет сформирован.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="explicit-locking.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="locking-indexes.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Явные блокировки</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Блокировки и индексы</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>