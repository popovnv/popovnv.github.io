<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Регламентная очистка</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Регламентные задачи обслуживания базы данных"
HREF="maintenance.html"><LINK
REL="PREVIOUS"
TITLE="Регламентные задачи обслуживания базы данных"
HREF="maintenance.html"><LINK
REL="NEXT"
TITLE="Регулярная переиндексация"
HREF="routine-reindex.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Регламентные задачи обслуживания базы данных"
HREF="maintenance.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="maintenance.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 23. Регламентные задачи обслуживания базы данных</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Регулярная переиндексация"
HREF="routine-reindex.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ROUTINE-VACUUMING"
>23.1. Регламентная очистка</A
></H1
><P
>Базы данных <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> требуют периодического проведения процедуры обслуживания, которая называется <I
CLASS="FIRSTTERM"
>очисткой</I
>. Во многих случаях очистку достаточно выполнять с помощью <I
CLASS="FIRSTTERM"
>демона автоочистки</I
>, который описан в <A
HREF="routine-vacuuming.html#AUTOVACUUM"
>Подразделе 23.1.6</A
>. Возможно, в вашей ситуации для получения оптимальных результатов потребуется настроить описанные там же параметры автоочистки. Некоторые администраторы СУБД могут дополнить или заменить действие этого демона командами <TT
CLASS="COMMAND"
>VACUUM</TT
> (обычно они выполняются по расписанию в заданиях <SPAN
CLASS="APPLICATION"
>cron</SPAN
> или <SPAN
CLASS="APPLICATION"
>Планировщика задач</SPAN
>). Чтобы правильно организовать очистку вручную, необходимо понимать темы, которые будут рассмотрены в следующих подразделах. Администраторы, которые полагаются на автоочистку, возможно, всё же захотят просмотреть этот материал, чтобы лучше понимать и настраивать эту процедуру.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="VACUUM-BASICS"
>23.1.1. Основные принципы очистки</A
></H2
><P
>Команды <A
HREF="sql-vacuum.html"
>VACUUM</A
> в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> должны обрабатывать каждую таблицу по следующим причинам: <P
></P
></P><OL
TYPE="1"
><LI
><P
>Для высвобождения или повторного использования дискового пространства, занятого изменёнными или удалёнными строками.</P
></LI
><LI
><P
>Для обновления статистики по данным, используемой планировщиком запросов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.</P
></LI
><LI
><P
>Для обновления карты видимости, которая ускоряет сканирование только индекса.</P
></LI
><LI
><P
>Для предотвращения потери очень старых данных из-за зацикливания идентификаторов <I
CLASS="FIRSTTERM"
>транзакций</I
> или <I
CLASS="FIRSTTERM"
>мультитранзакций</I
>.</P
></LI
></OL
><P> Разные причины диктуют выполнение действий <TT
CLASS="COMMAND"
>VACUUM</TT
> с разной частотой и в разном объёме, как рассматривается в следующих подразделах.</P
><P
>Существует два варианта <TT
CLASS="COMMAND"
>VACUUM</TT
>: обычный <TT
CLASS="COMMAND"
>VACUUM</TT
> и <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>. Команда <TT
CLASS="COMMAND"
>VACUUM FULL</TT
> может высвободить больше дискового пространства, однако работает медленнее. Кроме того, обычная команда <TT
CLASS="COMMAND"
>VACUUM</TT
> может выполняться параллельно с использованием производственной базы данных. (При этом такие команды как <TT
CLASS="COMMAND"
>SELECT</TT
>, <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
> и <TT
CLASS="COMMAND"
>DELETE</TT
> будут выполняться нормально, хотя нельзя будет изменить определение таблицы командами типа <TT
CLASS="COMMAND"
>ALTER TABLE</TT
>.) Команда <TT
CLASS="COMMAND"
>VACUUM FULL</TT
> требует исключительной блокировки обрабатываемой таблицы и поэтому не может выполняться параллельно с другими операциями с этой таблицей. По этой причине администраторы, как правило, должны стараться использовать обычную команду <TT
CLASS="COMMAND"
>VACUUM</TT
> и избегать <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>.</P
><P
>Команда <TT
CLASS="COMMAND"
>VACUUM</TT
> порождает существенный объём трафика ввода/вывода, который может стать причиной низкой производительности в других активных сеансах. Это влияние фоновой очистки можно регулировать, настраивая параметры конфигурации (см. <A
HREF="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST"
>Подраздел 18.4.4</A
>).</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="VACUUM-FOR-SPACE-RECOVERY"
>23.1.2. Высвобождение дискового пространства</A
></H2
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> команды <TT
CLASS="COMMAND"
>UPDATE</TT
> или <TT
CLASS="COMMAND"
>DELETE</TT
> не вызывают немедленного удаления старой версии изменяемых строк. Этот подход необходим для реализации эффективного многоверсионного управления конкурентным доступом (<ACRONYM
CLASS="ACRONYM"
>MVCC</ACRONYM
>, см. <A
HREF="mvcc.html"
>Главу 13</A
>): версия строки не должна удаляться до тех пор, пока она остаётся потенциально видимой для других транзакций. Однако в конце концов устаревшая или удалённая версия строки оказывается не нужна ни одной из транзакций. После этого занимаемое ей место должно быть освобождено и может быть отдано новым строкам, во избежание неограниченного роста потребности в дисковом пространстве. Это происходит при выполнении команды <TT
CLASS="COMMAND"
>VACUUM</TT
>.</P
><P
>Обычная форма <TT
CLASS="COMMAND"
>VACUUM</TT
> удаляет неиспользуемые версии строк в таблицах и индексах и помечает пространство свободным для дальнейшего использования. Однако это дисковое пространство не возвращается операционной системе, кроме особого случая, когда полностью освобождаются одна или несколько страниц в конце таблицы и можно легко получить исключительную блокировку таблицы. Команда <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>, напротив, кардинально сжимает таблицы, записывая абсолютно новую версию файла таблицы без неиспользуемого пространства. Это минимизирует размер таблицы, однако может занять много времени. Кроме того, для этого требуется больше места на диске для записи новой копии таблицы до завершения операции.</P
><P
>Обычно цель регулярной очистки — выполнять простую очистку (<TT
CLASS="COMMAND"
>VACUUM</TT
>) достаточно часто, чтобы не возникала необходимость в <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>. Демон автоочистки пытается работать в этом режиме, и на самом деле он сам никогда не выполняет <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>. Основная идея такого подхода не в том, чтобы минимизировать размер таблиц, а в том, чтобы поддерживать использование дискового пространства на стабильном уровне: каждая таблица занимает объём, равный её минимальному размеру, плюс объём, который был занят между процедурами очистки. Хотя с помощью <TT
CLASS="COMMAND"
>VACUUM FULL</TT
> можно сжать таблицу до минимума и возвратить дисковое пространство операционной системе, большого смысла в этом нет, если в будущем таблица так же вырастет снова. Следовательно, для активно изменяемых таблиц лучше с умеренной частотой выполнять <TT
CLASS="COMMAND"
>VACUUM</TT
>, чем очень редко выполнять <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>.</P
><P
>Некоторые администраторы предпочитают планировать очистку БД самостоятельно, например, проводя все работы ночью в период низкой загрузки. Однако очистка только по фиксированному расписанию плоха тем, что при резком скачке интенсивности изменений таблица может разрастить настолько, что для высвобождения пространства действительно понадобится выполнить <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>. Использование демона автоочистки снимает эту проблему, поскольку он планирует очистку динамически, отслеживая интенсивность изменений. Полностью отключать этот демон может иметь смысл, только если вы имеете дело с предельно предсказуемой загрузкой. Возможен и компромиссный вариант — настроить параметры демона автоочистки так, чтобы он реагировал только на необычайно высокую интенсивность изменений и мог удержать ситуацию под контролем, в то время как команды <TT
CLASS="COMMAND"
>VACUUM</TT
>, запускаемые по расписанию, будут выполнять основную работу в периоды нормальной загрузки.</P
><P
>Если же автоочистка не применяется, обычно планируется выполнение <TT
CLASS="COMMAND"
>VACUUM</TT
> для всей базы данных раз в сутки в период низкой активности, и в случае необходимости оно дополняется более частой очисткой интенсивно изменяемых таблиц. (В некоторых ситуациях, когда изменения производятся крайне интенсивно, самые востребованные таблицы могут очищаться раз в несколько минут.) Если в вашем кластере несколько баз данных, не забывайте выполнять <TT
CLASS="COMMAND"
>VACUUM</TT
> для каждой из них; при этом может быть полезна программа <A
HREF="app-vacuumdb.html"
>            <SPAN
CLASS="APPLICATION"
>vacuumdb</SPAN
>
          </A
>.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Результат обычного <TT
CLASS="COMMAND"
>VACUUM</TT
> может быть неудовлетворительным, когда вследствие массового изменения или удаления строк в таблице оказывается много мёртвых версий строк. Если у вас есть такая таблица и вам нужно освободить лишнее пространство, которое она занимает, используйте команду <TT
CLASS="COMMAND"
>VACUUM FULL</TT
> или, в качестве альтернативы, <A
HREF="sql-cluster.html"
>CLUSTER</A
> или один из вариантов <A
HREF="sql-altertable.html"
>ALTER TABLE</A
>, выполняющий перезапись таблицы. Эти команды записывают абсолютно новую копию таблицы и строят для неё индексы. Все эти варианты требуют исключительной блокировки. Заметьте, что они также на время требуют дополнительного пространства на диске в объёме, приблизительно равном размеру таблицы, поскольку старые копии таблицы и индексов нельзя удалить до завершения создания новых копий.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Если у вас есть таблица, всё содержимое которой периодически удаляется, рассмотрите возможность использования <A
HREF="sql-truncate.html"
>TRUNCATE</A
> вместо <TT
CLASS="COMMAND"
>DELETE</TT
> с последующей командой <TT
CLASS="COMMAND"
>VACUUM</TT
>. <TT
CLASS="COMMAND"
>TRUNCATE</TT
> немедленно удаляет всё содержимое таблицы, не требуя последующей очистки (<TT
CLASS="COMMAND"
>VACUUM</TT
> или <TT
CLASS="COMMAND"
>VACUUM FULL</TT
>) для высвобождения неиспользуемого дискового пространства. Недостатком такого подхода является нарушение строгой семантики MVCC.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="VACUUM-FOR-STATISTICS"
>23.1.3. Обновление статистики планировщика</A
></H2
><P
>Планировщик запросов в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, выбирая эффективные планы запросов, полагается на статистическую информацию о содержимом таблиц. Эта статистика собирается командой <A
HREF="sql-analyze.html"
>ANALYZE</A
>, которая может вызываться сама по себе или как дополнительное действие команды <TT
CLASS="COMMAND"
>VACUUM</TT
>. Статистика должна быть достаточно точной, так как в противном случае неудачно выбранные планы запросов могут снизить производительность базы данных.</P
><P
>Демон автоочистки, если он включён, будет автоматически выполнять <TT
CLASS="COMMAND"
>ANALYZE</TT
> после существенных изменений содержимого таблицы. Однако администраторы могут предпочесть выполнение <TT
CLASS="COMMAND"
>ANALYZE</TT
> вручную, в частности, если известно, что производимые в таблице изменения не повлияют на статистику по <SPAN
CLASS="QUOTE"
>"интересным"</SPAN
> колонкам. Демон же планирует выполнение <TT
CLASS="COMMAND"
>ANALYZE</TT
> в зависимости только от количества вставленных или изменённых строк; он не знает, приведут ли они к значимым изменениям статистики.</P
><P
>Как и процедура очистки для высвобождения пространства, частое обновление статистики полезнее для интенсивно изменяемых таблиц, нежели для тех таблиц, которые изменяются редко. Однако даже в случае часто изменяемой таблицы обновление статистики может не требоваться, если статистическое распределение данных меняется слабо. Как правило, достаточно оценить, насколько меняются максимальное и минимальное значения в колонках таблицы. Например, максимальное значение в колонке <TT
CLASS="TYPE"
>timestamp</TT
>, хранящей время изменения строки, будет постоянно увеличиваться по мере добавления и изменения строк; для такой колонки может потребоваться более частое обновление статистики, чем, к примеру, для колонки, содержащей адреса страниц (URL), которые запрашивались с сайта. Колонка с URL-адресами может меняться столь же часто, однако статистическое распределение её значений, вероятно, будет изменяться относительно медленно.</P
><P
>Команду <TT
CLASS="COMMAND"
>ANALYZE</TT
> можно выполнять для отдельных таблиц и даже просто для отдельных колонок таблицы, поэтому, если того требует приложение, одни статистические данные можно обновлять чаще, чем другие. Однако на практике обычно лучше просто анализировать всю базу данных, поскольку это быстрая операция, так как <TT
CLASS="COMMAND"
>ANALYZE</TT
> читает не каждую отдельную строку, а статистически случайную выборку строк таблицы.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Хотя индивидуальная настройка частоты <TT
CLASS="COMMAND"
>ANALYZE</TT
> для отдельных колонок может быть не очень полезной, смысл может иметь настройка детализации статистики, собираемой командой <TT
CLASS="COMMAND"
>ANALYZE</TT
>. Для колонок, которые часто используются в предложениях <TT
CLASS="LITERAL"
>WHERE</TT
>, и имеют очень неравномерное распределение данных, может потребоваться более детальная, по сравнению с другими колонками, гистограмма данных. В таких случаях можно воспользоваться командой <TT
CLASS="COMMAND"
>ALTER TABLE SET STATISTICS</TT
> или изменить значение по умолчанию параметра уровня БД <A
HREF="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET"
>default_statistics_target</A
>.</P
><P
>Кроме того, по умолчанию информация об избирательности функций ограничена. Однако если вы создаёте индекс по выражению с вызовом функции, об этой функции будет собрана полезная статистическая информация, которая может значительно улучшить планы запросов, в которых используется данный индекс.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Подсказка: </B
>Демон автоочистки не выполняет команды <TT
CLASS="COMMAND"
>ANALYZE</TT
> для сторонних таблиц, поскольку он не знает, как часто это следует делать. Если для получения качественных планов вашим запросам необходима статистика по сторонним таблицам, будет хорошей идеей дополнительно запускать <TT
CLASS="COMMAND"
>ANALYZE</TT
> для них по подходящему расписанию.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="VACUUM-FOR-VISIBILITY-MAP"
>23.1.4. Обновление карты видимости</A
></H2
><P
>Процедура очистки поддерживает <A
HREF="storage-vm.html"
>карты видимости</A
> для каждой таблицы, позволяющие определить, в каких страницах есть только записи, заведомо видимые для всех активных транзакций (и всех будущих транзакций, пока страница не будет изменена). Это имеет два применения. Во-первых, сам процесс очистки может пропускать такие страницы при следующем запуске, поскольку на этих страницах вычищать нечего.</P
><P
>Во-вторых, с такими картами <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может возвращать результаты некоторых запросов, используя только индекс, не обращаясь к данным таблицы. Так как индексы <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не содержат информацию о видимости записей, при обычном сканировании по индексу необходимо извлечь соответствующую запись из таблицы и проверить её видимость для текущей транзакции. Поэтому при <I
CLASS="FIRSTTERM"
>сканировании только индекса</I
>, наоборот, сначала проверяется карта видимости. Если известно, что все записи на странице видимы, то выборку из таблицы можно пропустить. Это наиболее полезно с большими наборах данных, когда благодаря карте видимости, можно оптимизировать чтение с диска. Карта видимости значительно меньше таблицы, поэтому она легко помещается в кеш, даже когда объём страниц очень велик.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="VACUUM-FOR-WRAPAROUND"
>23.1.5. Предотвращение ошибок из-за зацикливания счётчика транзакций</A
></H2
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> семантика транзакций MVCC зависит от возможности сравнения номеров идентификаторов транзакций (<ACRONYM
CLASS="ACRONYM"
>XID</ACRONYM
>): версия строки, у которой XID добавившей её транзакции больше, чем XID текущей транзакции, относится <SPAN
CLASS="QUOTE"
>"к будущему"</SPAN
> и не должна быть видна в текущей транзакции. Однако поскольку идентификаторы транзакций имеют ограниченный размер (32 бита), кластер, работающий долгое время (более 4 миллиардов транзакций) столкнётся с <I
CLASS="FIRSTTERM"
>зацикливанием идентификаторов транзакций</I
>: счётчик XID прокрутится до нуля, и внезапно транзакции, которые относились к прошлому, окажутся в будущем &mdash; это означает, что их результаты станут невидимыми. Одним словом, это катастрофическая потеря данных. (На самом деле данные никуда не пропадают, однако если вы не можете их получить, то это слабое утешение.) Для того чтобы этого избежать, необходимо выполнять очистку для каждой таблицы в каждой базе данных как минимум единожды на два миллиардов транзакций.</P
><P
>Периодическое выполнение очистки решает эту проблему, потому что процедура <TT
CLASS="COMMAND"
>VACUUM</TT
> помечает строки как <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>замороженные</I
></SPAN
>, указывая, что они были вставлены транзакцией, которая фиксировала данные достаточно давно в прошлом, так что эффект добавляющей транзакции с точки зрения MVCC определённо будет виден во всех текущих и будущих транзакциях. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> резервирует особенный XID <TT
CLASS="LITERAL"
>FrozenTransactionId</TT
>, который не подчиняется правилам сравнения обычных XID и всегда считается старше любого обычного XID. Обычные значения XID сравниваются по модулю 2<SUP
>32</SUP
>. Это означает, что для каждого обычного XID существуют два миллиарда значений XID, которые <SPAN
CLASS="QUOTE"
>"старше"</SPAN
> него, и два миллиарда значений, которые <SPAN
CLASS="QUOTE"
>"младше"</SPAN
> него; другими словами, пространство значений XID циклично и не имеет конечной точки. Следовательно, как только создаётся версия строки с обычным XID, для следующих двух миллиардов транзакций эта версия строки оказывается <SPAN
CLASS="QUOTE"
>"в прошлом"</SPAN
>, неважно о каком значении обычного XID идет речь. Если после двух миллиардов транзакций эта версия строки всё ещё существует, она внезапно окажется в будущем. Для того чтобы это предотвратить, в какой-то момент значение XID для старых версий строк должно быть заменено на <TT
CLASS="LITERAL"
>FrozenTransactionId</TT
> (заморожено) до того, как будет достигнута граница в два миллиарда транзакций. После получения этого особенного XID для всех обычных транзакций эти версии строк будут относиться <SPAN
CLASS="QUOTE"
>"к прошлому"</SPAN
>, независимо от зацикливания, и, таким образом, эти версии строк будут действительны до момента их удаления, когда бы это ни произошло.</P
><P
>Параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE"
>vacuum_freeze_min_age</A
> определяет, насколько старым должен стать XID, чтобы эта версия строки была заморожена. Увеличение его значения помогает избежать ненужной работы, если строки, которые могли бы быть заморожены в ближайшее время, будут изменены ещё раз, а уменьшение приводит к увеличению количества транзакций, которые могут выполниться, прежде чем потребуется очередная очистка таблицы.</P
><P
>Обычно операция <TT
CLASS="COMMAND"
>VACUUM</TT
> пропускает страницы, в которых нет мёртвых версий строк, однако в этих страницах могут всё-таки находиться версии строк со старыми значениями XID. Чтобы гарантировать, что все старые значения XID были заморожены, необходимо сканирование всей таблицы. Параметр <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE"
>vacuum_freeze_table_age</A
> задаёт момент, когда <TT
CLASS="COMMAND"
>VACUUM</TT
> будет выполнять эту операцию: полное сканирование таблицы выполняется, если таблица не сканировалась полностью в течение <TT
CLASS="VARNAME"
>vacuum_freeze_table_age</TT
> минус <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
> транзакций. При значении, равном 0, команда <TT
CLASS="COMMAND"
>VACUUM</TT
> всегда сканирует все страницы, фактически игнорируя карту видимости.</P
><P
>Максимальное время, в течение которого таблица может обходиться без очистки, составляет два миллиарда транзакций минус значение <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
>, с момента, когда команда <TT
CLASS="COMMAND"
>VACUUM</TT
> последний раз производила полное сканирование таблицы. Если бы таблица не подвергалась очистке дольше, была бы возможна потеря данных. Чтобы гарантировать, что это не произойдёт, для любой таблицы, которая может содержать значения XID старше, чем возраст, указанный в конфигурационном параметре <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE"
>autovacuum_freeze_max_age</A
>, вызывается автоочистка. (Это случится, даже если автоочистка отключена.)</P
><P
>Это означает, что если очистка таблицы не вызывается другим способом, то автоочистка для неё будет вызываться приблизительно через каждые <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> минус <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
> транзакций. Для таблиц, очищаемых регулярно для высвобождения пространства, это неактуально. В то же время статичные таблицы (включая таблицы, в которых данные вставляются, но не изменяются и не удаляются) не нуждаются в очистке для высвобождения пространства, поэтому для очень больших статичных таблиц имеет смысл увеличить интервал между вынужденными запусками автоочистки. Очевидно, это можно сделать, либо увеличив <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
>, либо уменьшив <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
>.</P
><P
>Фактический максимум для <TT
CLASS="VARNAME"
>vacuum_freeze_table_age</TT
> составляет 0.95 * <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
>; большее значение будет ограничено этим пределом. Значение, превышающее <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
>, не имело бы смысла, поскольку по достижении этого значения в любом случае вызывалась бы автоочистка для предотвращения зацикливания, а коэффициент 0.95 оставляет немного времени для того, чтобы запустить команду <TT
CLASS="COMMAND"
>VACUUM</TT
> вручную до того, как это произойдёт. Как правило, установленное значение <TT
CLASS="COMMAND"
>vacuum_freeze_table_age</TT
> должно быть несколько меньше <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
>, чтобы оставленный промежуток был достаточен для выполнения в этом окне <TT
CLASS="COMMAND"
>VACUUM</TT
> по расписанию или автоочистки, управляемой обычной активностью операций удаления и изменения. Если это значение будет слишком близким к максимуму, автоочистка для предотвращения зацикливания будет выполняться, даже если таблица только что была очищена для высвобождения пространства, в то же время при небольшом значении будет чаще осуществляться полное сканирование таблицы.</P
><P
>Единственный минус увеличения <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> (и <TT
CLASS="VARNAME"
>vacuum_freeze_table_age</TT
> с ним) заключается в том, что подкаталог <TT
CLASS="FILENAME"
>pg_clog</TT
> в кластере базы данных будет занимать больше места, поскольку в нём нужно будет хранить статус фиксации всех транзакций вплоть до горизонта <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
>. Для статуса фиксации используется по два бита на транзакцию, поэтому если в <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> установлено максимально допустимое значение в два миллиарда, то размер <TT
CLASS="FILENAME"
>pg_clog</TT
> может составить примерно половину гигабайта. Если по сравнению с объёмом вашей базы данных этот объём незначителен, тогда рекомендуется установить для <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> максимально допустимое значение. В противном случае, установите значение этого параметра в зависимости от объёма, который вы готовы выделить для <TT
CLASS="FILENAME"
>pg_clog</TT
>. (Значению по умолчанию, 200 миллионам транзакций, соответствует приблизительно 50 Мб в <TT
CLASS="FILENAME"
>pg_clog</TT
>.)</P
><P
>Уменьшение значения <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
>, с другой стороны, чревато тем, что команда <TT
CLASS="COMMAND"
>VACUUM</TT
> может выполнять бесполезную работу: замораживание версии строки — пустая трата времени, если эта строка будет вскоре изменена (и в результате получит новый XID). Поэтому значение этого параметра должно быть достаточно большим для того, чтобы строки не замораживались, пока их последующее изменение не станет маловероятным.</P
><P
>Для отслеживания возраста самых старых значений XID в базе данных команда <TT
CLASS="COMMAND"
>VACUUM</TT
> сохраняет статистику по XID в системных таблицах <TT
CLASS="STRUCTNAME"
>pg_class</TT
> и <TT
CLASS="STRUCTNAME"
>pg_database</TT
>. В частности, колонка <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
> в записи для определённой таблицы в <TT
CLASS="STRUCTNAME"
>pg_class</TT
> содержит граничное значение XID, с которым в последний раз выполнялась операция <TT
CLASS="COMMAND"
>VACUUM</TT
> для всей этой таблицы. Все строки, добавленные транзакциями с более ранними XID, гарантированно будут заморожены. Аналогично колонка <TT
CLASS="STRUCTFIELD"
>datfrozenxid</TT
> в строке таблицы <TT
CLASS="STRUCTNAME"
>pg_database</TT
> представляет нижнюю границу обычных значений XID, встречающихся в этой базе данных &mdash; она просто хранит минимальное из всех значений <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
> для таблиц в этой базе данных. Эту информацию удобно получать с помощью таких запросов: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</PRE
><P> Колонка <TT
CLASS="LITERAL"
>age</TT
> показывает количество транзакций от граничного значения XID до XID текущей транзакции.</P
><P
>Обычно <TT
CLASS="COMMAND"
>VACUUM</TT
> сканирует только те страницы, которые изменялись после последней очистки, однако <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
> может увеличиться только при полном сканировании таблицы. Сканирование всей таблицы происходит, когда возраст <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
> достигает <TT
CLASS="VARNAME"
>vacuum_freeze_table_age</TT
>, когда <TT
CLASS="COMMAND"
>VACUUM</TT
> вызывается с указанием <TT
CLASS="LITERAL"
>FREEZE</TT
>, или когда оказывается, что очистку для удаления мёртвых версий строк нужно провести во всех страницах. После того как <TT
CLASS="COMMAND"
>VACUUM</TT
> завершает сканирование всей таблицы, значение <TT
CLASS="LITERAL"
>age(relfrozenxid)</TT
> должно стать немного больше, чем значение <TT
CLASS="VARNAME"
>vacuum_freeze_min_age</TT
> (больше чем на число транзакций, начатых с момента запуска <TT
CLASS="COMMAND"
>VACUUM</TT
>). Если по достижении <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> для таблицы ни разу будет выполнена операция <TT
CLASS="COMMAND"
>VACUUM</TT
> с полным сканированием, в скором времени для неё будет принудительно запущена автоочистка.</P
><P
>Если по какой-либо причине автоочистка не может вычистить старые значения XID из таблицы, система начинает выдавать предупреждающие сообщения, подобные приведённому ниже, когда самое старое значение XID в базе данных оказывается в десяти миллионах транзакций от точки зацикливания: </P><PRE
CLASS="PROGRAMLISTING"
>ПРЕДУПРЕЖДЕНИЕ:  база данных "mydb" должна быть очищена (предельное число транзакций: 177009986)
ПОДСКАЗКА:  Во избежание отключения базы данных выполните очистку (VACUUM) всей базы "mydb".</PRE
><P> (Проблему можно решить, как предлагает подсказка, запустив <TT
CLASS="COMMAND"
>VACUUM</TT
> вручную; однако учтите, что выполнять <TT
CLASS="COMMAND"
>VACUUM</TT
> должен суперпользователь, в противном случае эта процедура не сможет обработать системные каталоги и, следовательно, не сможет увеличить значение <TT
CLASS="STRUCTFIELD"
>datfrozenxid</TT
> для базы данных.) Если эти предупреждения игнорировать, система отключится и не будет начинать никаких транзакций, как только до точки зацикливания останется менее 1 миллиона транзакций: </P><PRE
CLASS="PROGRAMLISTING"
>ОШИБКА:  база данных не принимает команды во избежание потери данных из-за зацикливания в БД "mydb"
ПОДСКАЗКА:  Остановите управляющий процесс (postmaster) и выполните очистку (VACUUM) базы данных в однопользовательском режиме.</PRE
><P> Резерв в 1 миллион транзакций позволяет администратору провести восстановление без потери данных, выполнив необходимые команды <TT
CLASS="COMMAND"
>VACUUM</TT
> вручную. Однако, поскольку после безопасной остановки система не будет исполнять команды, администратору останется только перезапустить сервер в однопользовательском режиме, чтобы запустить <TT
CLASS="COMMAND"
>VACUUM</TT
>. За подробной информацией об использовании однопользовательского режима обратитесь к странице справки по <A
HREF="app-postgres.html"
>            <SPAN
CLASS="APPLICATION"
>postgres</SPAN
>
          </A
>.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="VACUUM-FOR-MULTIXACT-WRAPAROUND"
>23.1.5.1. Мультитранзакции и зацикливание</A
></H3
><P
><I
CLASS="FIRSTTERM"
>Идентификаторы мультитранзакций</I
> используются для поддержки блокировки строк несколькими транзакциями одновременно. Поскольку в заголовке строки есть только ограниченное пространство для хранения информации о блокировках, в нём указывается <SPAN
CLASS="QUOTE"
>"идентификатор множественной транзакции"</SPAN
>, или идентификатор мультитранзакции для краткости, когда строку блокируют одновременно несколько транзакций. Информация о том, какие именно идентификаторы транзакций относятся к определённой мультитранзакции, хранится отдельно в подкаталоге <TT
CLASS="FILENAME"
>pg_multixact</TT
>, а в поле <TT
CLASS="STRUCTFIELD"
>xmax</TT
> в заголовке строки сохраняется только идентификатор мультитранзакции. Как и идентификаторы транзакций, идентификаторы мультитранзакций исполнены в виде 32-разрядного счётчика и хранятся аналогично, что требует аккуратного управления их возрастом, очисткой хранилища и предотвращением зацикливаний.</P
><P
>Во время сканирования таблицы командой <TT
CLASS="COMMAND"
>VACUUM</TT
>, частичного или полного, любой идентификатор мультитранзакции, старее чем <A
HREF="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE"
>vacuum_multixact_freeze_min_age</A
>, будет заменён другим значением, которое может быть нулевым, идентификатором одиночной транзакции или новым идентификатором мультитранзакции. Для каждой таблицы в <TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>relminmxid</TT
> хранится самый старый возможный идентификатор мультитранзакции, все ещё задействованный в какой-либо строке этой таблицы. Если это значение оказывается старее <A
HREF="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE"
>vacuum_multixact_freeze_table_age</A
>, выполняется принудительное сканирование всей таблицы. Команда <TT
CLASS="COMMAND"
>VACUUM</TT
>, выполняющая полное сканирование, вне зависимости от его причины, может увеличить это значение для таблицы. В конце концов, по мере сканирования всех таблиц во всех базах данных и увеличения их старейших значений мультитранзакций, информацию о старых мультитранзакциях можно будет удалить с диска.</P
><P
>В качестве меры защиты, полное сканирование таблицы с целью очистки будет происходить для любой таблицы, возраст мультитранзакций которой больше, чем <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"
>autovacuum_multixact_freeze_max_age</A
>. Эта процедура будет выполняться, даже если процесс автоочистки отключён.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTOVACUUM"
>23.1.6. Демон автоочистки</A
></H2
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> имеется не обязательная, но настоятельно рекомендуемая к использованию функция, называемая <I
CLASS="FIRSTTERM"
>автоочисткой</I
>, предназначение которой — автоматизировать выполнение команд <TT
CLASS="COMMAND"
>VACUUM</TT
> и <TT
CLASS="COMMAND"
>ANALYZE </TT
>. Когда автоочистка включена, она проверяет, в каких таблицах было вставлено, изменено или удалено много строк. При этих проверках используются средства сбора статистики; поэтому автоочистка будет работать, только если параметр <A
HREF="runtime-config-statistics.html#GUC-TRACK-COUNTS"
>track_counts</A
> имеет значение <TT
CLASS="LITERAL"
>true</TT
>. В конфигурации по умолчанию автоочистка включена и соответствующие параметры имеют подходящие значения.</P
><P
><SPAN
CLASS="QUOTE"
>"Демон автоочистки"</SPAN
> на самом деле состоит из нескольких процессов. Существует постоянный фоновый процесс, называемый <I
CLASS="FIRSTTERM"
>процессом запуска автоочистки</I
>, который отвечает за запуск <I
CLASS="FIRSTTERM"
>рабочих процессов автоочистки</I
> для всех баз данных. Этот контролирующий процесс распределяет работу по времени, стараясь запускать рабочий процесс для каждой базы данных каждые <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-NAPTIME"
>autovacuum_naptime</A
> секунд. (Следовательно, если всего имеется <TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
> баз данных, новый рабочий процесс будет запускаться каждые <TT
CLASS="VARNAME"
>autovacuum_naptime</TT
>/<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
> секунд.) Одновременно могут выполняться до <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
> рабочих процессов. Если число баз данных, требующих обработки, превышает <TT
CLASS="VARNAME"
>autovacuum_max_workers</TT
>, обработка следующей базы начинается сразу по завершении первого рабочего процесса. Каждый рабочий процесс проверяет все таблицы в своей базе данных и в случае необходимости выполняет <TT
CLASS="COMMAND"
>VACUUM</TT
> и/или <TT
CLASS="COMMAND"
>ANALYZE</TT
>. Для отслеживания действий автоочистки можно воспользоваться параметром <TT
CLASS="VARNAME"
>log_autovacuum_min_duration</TT
>.</P
><P
>Если в течение короткого промежутка времени потребность в очистке возникает для нескольких больших таблиц, все рабочие процессы автоочистки могут продолжительное время заниматься очисткой только этих таблиц. В результате другие таблицы и базы данных будут ожидать очистки, пока не появится свободный рабочий процесс. Число рабочих процессов для одной базы не ограничивается, при этом каждый процесс старается не повторять работу, только что выполненную другими. Заметьте, что в ограничениях <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
> или <A
HREF="runtime-config-connection.html#GUC-SUPERUSER-RESERVED-CONNECTIONS"
>superuser_reserved_connections</A
> число выполняющихся рабочих процессов не учитывается.</P
><P
>Для таблиц с <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
>, устаревшим более чем на <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE"
>autovacuum_freeze_max_age</A
> транзакций, очистка выполняется всегда (это также применимо к таблицам, для которых максимальный порог заморозки был изменён через параметры хранения; см. ниже). В противном случае, очистка таблицы производится, если количество кортежей, устаревших с момента последнего выполнения <TT
CLASS="COMMAND"
>VACUUM</TT
>, превышает <SPAN
CLASS="QUOTE"
>"пороговое значение очистки"</SPAN
>. Пороговое значение очистки определяется как: </P><PRE
CLASS="PROGRAMLISTING"
>порог очистки = базовый порог очистки + коэффициент доли для очистки * количество кортежей</PRE
><P> где базовый порог очистки — значение <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD"
>autovacuum_vacuum_threshold</A
>, коэффициент доли — <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR"
>autovacuum_vacuum_scale_factor</A
>, а количество кортежей — <TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>reltuples</TT
>. Количество устаревших кортежей получается от сборщика статистики; оно представляет собой приблизительное число, обновляемое после каждой операции <TT
CLASS="COMMAND"
>UPDATE</TT
> и <TT
CLASS="COMMAND"
>DELETE</TT
>. (Точность не гарантируется, потому что при большой нагрузке часть информации может быть утеряна.) Если значение <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
> для таблицы старее <TT
CLASS="VARNAME"
>vacuum_freeze_table_age</TT
> транзакций, производится сканирование всей таблицы с целью заморозить старые версии строк и увеличить значение <TT
CLASS="STRUCTFIELD"
>relfrozenxid</TT
>, в противном случае сканируются только страницы, изменённые после последней очистки.</P
><P
>Для выполнения сбора статистики используется аналогичное условие: пороговое значение, определяемое как: </P><PRE
CLASS="PROGRAMLISTING"
>порог анализа = базовый порог анализа + коэффициент доли для анализа * количество кортежей</PRE
><P> сравнивается с общим количеством кортежей добавленных, изменённых или удалённых после последнего выполнения <TT
CLASS="COMMAND"
>ANALYZE</TT
>.</P
><P
>Автоочистка не обрабатывает временные таблицы. Поэтому очистку и сбор статистики в них нужно производить с помощью SQL-команд в обычном сеансе.</P
><P
>Используемые по умолчанию пороговые значения и коэффициенты берутся из <TT
CLASS="FILENAME"
>postgresql.conf</TT
>, однако их можно переопределить для каждой таблицы; за подробностями обратитесь к <A
HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"
><I
>Параметры хранения</I
></A
>. Если какие-либо значения определены через параметры хранения, действуют они, а в противном случае — глобальные параметры. За более подробной информацией о глобальных параметрах обратитесь к <A
HREF="runtime-config-autovacuum.html"
>Разделу 18.10</A
>.</P
><P
>Помимо базовых пороговых значений и коэффициентов, существуют ещё шесть параметров, относящихся к автоочистке, которые можно задать для каждой таблицы через параметры хранения. Если первому параметру, <TT
CLASS="LITERAL"
>autovacuum_enabled</TT
>, присвоить значение <TT
CLASS="LITERAL"
>false</TT
>, демон автоочистки полностью исключит данную таблицу из рассмотрения. В этом случае автоочистка затронет эту таблицу, только если это потребуется для предотвращения зацикливания идентификаторов транзакций. Другие два параметра, <TT
CLASS="VARNAME"
>autovacuum_vacuum_cost_delay</TT
> и <TT
CLASS="VARNAME"
>autovacuum_vacuum_cost_limit</TT
>, используются для того, чтобы задать для отдельных таблиц задержку очистки на основе стоимости (см. <A
HREF="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST"
>Подраздел 18.4.4</A
>). Параметры <TT
CLASS="VARNAME"
>autovacuum_freeze_min_age</TT
>, <TT
CLASS="VARNAME"
>autovacuum_freeze_max_age</TT
> и <TT
CLASS="VARNAME"
>autovacuum_freeze_table_age</TT
> задают значения для переменных <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE"
>vacuum_freeze_min_age</A
>, <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE"
>autovacuum_freeze_max_age</A
> и <A
HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE"
>vacuum_freeze_table_age</A
>, соответственно.</P
><P
>Когда выполняются несколько рабочих процессов, параметры задержки по стоимости <SPAN
CLASS="QUOTE"
>"распределяются"</SPAN
> между всеми этими процессами, так что общее воздействие на систему остаётся неизменным, независимо от их числа. Однако этот алгоритм распределения нагрузки не учитывает процессы, обрабатывающие таблицы с индивидуальными значениями <TT
CLASS="LITERAL"
>autovacuum_vacuum_cost_delay</TT
> и <TT
CLASS="LITERAL"
>autovacuum_vacuum_cost_limit</TT
>.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="maintenance.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="routine-reindex.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Регламентные задачи обслуживания базы данных</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="maintenance.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Регулярная переиндексация</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>