<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Частичные индексы</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Индексы"
HREF="indexes.html"><LINK
REL="PREVIOUS"
TITLE="Индексы по выражениям"
HREF="indexes-expressional.html"><LINK
REL="NEXT"
TITLE="Семейства и классы операторов"
HREF="indexes-opclass.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Индексы по выражениям"
HREF="indexes-expressional.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 11. Индексы</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Семейства и классы операторов"
HREF="indexes-opclass.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INDEXES-PARTIAL"
>11.8. Частичные индексы</A
></H1
><P
><I
CLASS="FIRSTTERM"
>Частичный индекс</I
> &mdash; это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется <I
CLASS="FIRSTTERM"
>предикатом</I
> частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть очень полезны.</P
><P
>Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования распространённых значений. Так как при поиске распространённого значения (такого, которое содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хранить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции изменения данных в таблице, так как индекс будет обновляться не всегда. Возможное применение этой идеи проиллюстрировано в <A
HREF="indexes-partial.html#INDEXES-PARTIAL-EX1"
>Примере 11-1</A
>.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="INDEXES-PARTIAL-EX1"
></A
><P
><B
>Пример 11-1. Настройка частичного индекса, исключающего распространённые значения</B
></P
><P
>Предположим, что вы храните в базе данных журнал обращений к корпоративному сайту. Большая часть обращений будет происходить из диапазона IP-адресов вашей компании, а остальные могут быть откуда угодно (например, к нему могут подключаться внешние сотрудники с динамическими IP). Если при поиске по IP вас обычно интересуют внешние подключения, IP-диапазон внутренней сети компании можно не включать в индекс.</P
><P
>Пусть у вас есть такая таблица: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</PRE
><P></P
><P
>Создать частичный индекс для нашего примера можно так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');</PRE
><P></P
><P
>Так будет выглядеть типичный запрос, использующий этот индекс: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</PRE
><P> А следующий запрос не будет использовать этот индекс: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';</PRE
><P></P
><P
>Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые значения были известны заранее, так что такие индексы лучше использовать, когда распределение данных не меняется. Хотя такие индексы можно пересоздавать время от времени, подстраиваясь под новое распределение, это значительно усложняет поддержку.</P
></DIV
><P
>Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить из индекса значения, которые обычно не представляют интереса; это проиллюстрировано в <A
HREF="indexes-partial.html#INDEXES-PARTIAL-EX2"
>Примере 11-2</A
>. При этом вы получаете те же преимущества, что и в предыдущем случае, но система не сможет извлечь <SPAN
CLASS="QUOTE"
>"неинтересные"</SPAN
> значения по этому индексу, даже если сканирование индекса может быть эффективным. Очевидно, настройка частичных индексов в таких случаях требует тщательного анализа и тестирования.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="INDEXES-PARTIAL-EX2"
></A
><P
><B
>Пример 11-2. Настройка частичного индекса, исключающего неинтересные значения</B
></P
><P
>Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные счета, и при этом неоплаченные счета составляют только небольшую часть всей таблицы, но представляют наибольший интерес, производительность запросов можно увеличить, создав индекс только по неоплаченным счетам. Сделать это можно следующей командой: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;</PRE
><P></P
><P
>Этот индекс будет применяться, например в таком запросе: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;</PRE
><P> Однако он также может применяться в запросах, где <TT
CLASS="STRUCTFIELD"
>order_nr</TT
> вообще не используется, например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</PRE
><P> Конечно, он будет не так эффективен, как мог бы быть частичный индекс по колонке <TT
CLASS="STRUCTFIELD"
>amount</TT
>, так как системе придётся сканировать его целиком. Тем не менее, если неоплаченных счетов сравнительно мало, выиграть при поиске неоплаченного счёта можно и с таким частичным индексом.</P
><P
>Заметьте, что в таком запросе этот индекс не будет использоваться: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM orders WHERE order_nr = 3501;</PRE
><P> Счёт с номером 3501 может оказаться, как в числе неоплаченных, так и оплаченных.</P
></DIV
><P
><A
HREF="indexes-partial.html#INDEXES-PARTIAL-EX2"
>Пример 11-2</A
> также показывает, что индексируемая колонка не обязательно должна совпадать с колонкой, используемой в предикате. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> поддерживает частичные индексы с произвольными предикатами &mdash; главное, чтобы в них фигурировали только колонки индексируемой таблицы. Однако не забывайте, что предикат должен соответствовать условиям запросов, для оптимизации которых предназначается данный индекс. Точнее, частичный индекс будет применяться в запросе, только если система сможет понять, что условие <TT
CLASS="LITERAL"
>WHERE</TT
> данного запроса математически сводится к предикату индекса. Но учтите, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не умеет доказывать математические утверждения об эквивалентности выражений, записанных в разных формах. (Составить программу для таких доказательств крайне сложно, и если даже это удастся, скорость её будет неприемлема для применения на практике.) Система может выявить только самые простые следствия с неравенствами; например, понять, что из <SPAN
CLASS="QUOTE"
>"x &lt; 1"</SPAN
> следует <SPAN
CLASS="QUOTE"
>"x &lt; 2"</SPAN
>; во всех остальных случаях условие предиката должно точно совпадать с условием в предложении <TT
CLASS="LITERAL"
>WHERE</TT
>, иначе индекс будет считаться неподходящим. Сопоставление условий происходит во время планирования запросов, а не во время выполнения. Как следствие, запросы с параметрами не будут работать с частичными индексами. Например, условие с параметром <SPAN
CLASS="QUOTE"
>"x &lt; ?"</SPAN
> в подготовленном запросе никогда не будет сведено к <SPAN
CLASS="QUOTE"
>"x &lt; 2"</SPAN
> при всех возможных значениях параметра.</P
><P
>Третье возможное применение частичных индексов вообще не связано с использованием индекса в запросах. Идея заключается в том, чтобы создать уникальный индекс по подмножеству строк таблицы, как в <A
HREF="indexes-partial.html#INDEXES-PARTIAL-EX3"
>Примере 11-3</A
>. Это обеспечит уникальность среди строк, удовлетворяющих условию предиката, но никак не будет ограничивать остальные.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="INDEXES-PARTIAL-EX3"
></A
><P
><B
>Пример 11-3. Настройка частичного уникального индекса</B
></P
><P
>Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы для каждого сочетания предмета и целевой темы была только одна запись об успешном результате, а неудачных попыток могло быть много. Вот как можно этого добиться: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</PRE
><P> Это подход будет особенно эффективным, когда неудачных попыток будет намного больше, чем удачных.</P
></DIV
><P
>Наконец, с помощью частичных индексов можно также переопределять выбираемый системой план запроса. Возможно, что для данных с неудачным распределением система решит использовать индекс, тогда как на самом деле это неэффективно. В этом случае индекс можно настроить так, чтобы в подобных запросах он не работал. Обычно <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> принимает разумные решения относительно применения индексов (т. е. старается не использовать их для получения распространённых значений, так что частичный индекс в вышеприведённом примере помог только уменьшить размер индекса, для отказа от использования индекса он не требовался), поэтому крайне неэффективный план может быть поводом для сообщения об ошибке.</P
><P
>Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете о данных гораздо больше, чем планировщик запросов. В частности, вы знаете, когда такой индекс может быть полезен. Это знание обязательно должно подкрепляться опытом и пониманием того, как работают индексы в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. В большинстве случаев преимущества частичных индексов по сравнению с обычными будут минимальными.</P
><P
>Узнать о частичных индексах больше можно в следующих источниках: <A
HREF="biblio.html#STON89B"
><I
><A
HREF="http://db.cs.berkeley.edu/papers/ERL-M89-17.pdf"
TARGET="_top"
>The case for partial indexes</A
></I
></A
>, <A
HREF="biblio.html#OLSON93"
><I
>Partial indexing in POSTGRES: research project</I
></A
> и <A
HREF="biblio.html#SESHADRI95"
><I
>Generalized Partial Indexes <A
HREF="http://citeseer.ist.psu.edu/seshadri95generalized.html"
TARGET="_top"
>(cached version) </A
></I
></A
>.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes-expressional.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="indexes-opclass.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Индексы по выражениям</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Семейства и классы операторов</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>