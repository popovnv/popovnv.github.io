<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>ALTER TABLE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Команды SQL"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="ALTER SYSTEM"
HREF="sql-altersystem.html"><LINK
REL="NEXT"
TITLE="ALTER TABLESPACE"
HREF="sql-altertablespace.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ALTER SYSTEM"
HREF="sql-altersystem.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="ALTER TABLESPACE"
HREF="sql-altertablespace.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-ALTERTABLE"
></A
>ALTER TABLE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN69485"
></A
><H2
>Название</H2
>ALTER TABLE&nbsp;--&nbsp;изменить определение таблицы</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN69488"
></A
><H2
>Синтаксис</H2
><PRE
CLASS="SYNOPSIS"
>ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> [ * ]
    <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> [ * ]
    RENAME [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>новое_имя_колонки</I
></TT
>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> [ * ]
    RENAME CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>имя_нового_ограничения</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
>
    RENAME TO <TT
CLASS="REPLACEABLE"
><I
>новое_имя</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
>
    SET SCHEMA <TT
CLASS="REPLACEABLE"
><I
>новая_схема</I
></TT
>
ALTER TABLE ALL IN TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
> [ OWNED BY <TT
CLASS="REPLACEABLE"
><I
>имя_роли</I
></TT
> [, ... ] ]
    SET TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>новое_табл_пространство</I
></TT
> [ NOWAIT ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>Где возможные варианты <TT
CLASS="REPLACEABLE"
><I
>действие</I
></TT
>:</SPAN
></SPAN
>

    ADD [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>ограничение_колонки</I
></TT
> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> [ SET DATA ] TYPE <TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>правило_сортировки</I
></TT
> ] [ USING <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
> ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> SET DEFAULT <TT
CLASS="REPLACEABLE"
><I
>выражение</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> DROP DEFAULT
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> SET STATISTICS <TT
CLASS="REPLACEABLE"
><I
>integer</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> SET ( <TT
CLASS="REPLACEABLE"
><I
>атрибут</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> RESET ( <TT
CLASS="REPLACEABLE"
><I
>атрибут</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
> [ NOT VALID ]
    ADD <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы_по_индексу</I
></TT
>
    ALTER CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
>
    DROP CONSTRAINT [ IF EXISTS ]  <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>имя_триггера</I
></TT
> | ALL | USER ]
    ENABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>имя_триггера</I
></TT
> | ALL | USER ]
    ENABLE REPLICA TRIGGER <TT
CLASS="REPLACEABLE"
><I
>имя_триггера</I
></TT
>
    ENABLE ALWAYS TRIGGER <TT
CLASS="REPLACEABLE"
><I
>имя_триггера</I
></TT
>
    DISABLE RULE <TT
CLASS="REPLACEABLE"
><I
>имя_правила_перезаписи</I
></TT
>
    ENABLE RULE <TT
CLASS="REPLACEABLE"
><I
>имя_правила_перезаписи</I
></TT
>
    ENABLE REPLICA RULE <TT
CLASS="REPLACEABLE"
><I
>имя_правила_перезаписи</I
></TT
>
    ENABLE ALWAYS RULE <TT
CLASS="REPLACEABLE"
><I
>имя_правила_перезаписи</I
></TT
>
    CLUSTER ON <TT
CLASS="REPLACEABLE"
><I
>имя_индекса</I
></TT
>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> [, ... ] )
    RESET ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [, ... ] )
    INHERIT <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
>
    NO INHERIT <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
>
    OF <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
>
    NOT OF
    OWNER TO <TT
CLASS="REPLACEABLE"
><I
>новый_владелец</I
></TT
>
    SET TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>новое_табл_пространство</I
></TT
>
    REPLICA IDENTITY {DEFAULT | USING INDEX <TT
CLASS="REPLACEABLE"
><I
>имя_индекса</I
></TT
> | FULL | NOTHING}

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>и <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы_по_индексу</I
></TT
>:</SPAN
></SPAN
>

    [ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <TT
CLASS="REPLACEABLE"
><I
>имя_индекса</I
></TT
>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN69555"
></A
><H2
>Описание</H2
><P
><TT
CLASS="COMMAND"
>ALTER TABLE</TT
> меняет определение существующей таблицы. Несколько её разновидностей описаны ниже. Заметьте, что для разных разновидностей могут требоваться разные уровни блокировок. Если явно не отмечено другое, требуется блокировка <TT
CLASS="LITERAL"
>ACCESS EXCLUSIVE</TT
>. При перечислении нескольких подкоманд будет запрашиваться самая сильная блокировка из требуемых ими. <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ADD COLUMN</TT
></DT
><DD
><P
>Эта форма добавляет в таблицу новую колонку, с тем же синтаксисом, что и <A
HREF="sql-createtable.html"
>CREATE TABLE</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DROP COLUMN [ IF EXISTS ]</TT
></DT
><DD
><P
>Эта форма удаляет колонку из таблицы. При этом автоматически будут удалены индексы и ограничения таблицы, связанные с этой колонкой. Если от этой колонки зависят какие-либо объекты вне этой таблицы, например, внешние ключи или представления, удалить и их можно, добавив указание <TT
CLASS="LITERAL"
>CASCADE</TT
>. Если в команде указано <TT
CLASS="LITERAL"
>IF EXISTS</TT
> и эта колонка не существует, это не считается ошибкой, вместо этого просто выдаётся замечание.</P
></DD
><DT
><TT
CLASS="LITERAL"
>IF EXISTS</TT
></DT
><DD
><P
>Не считать ошибкой, если таблица не существует. В этом случае будет выдано замечание.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET DATA TYPE</TT
></DT
><DD
><P
>Эта форма меняет тип колонки таблицы. Индексы и простые табличные ограничения, включающие эту колонку, будут автоматически преобразованы для использования нового типа колонки, для чего будет заново разобрано определяющее их выражение. Необязательное предложение <TT
CLASS="LITERAL"
>COLLATE</TT
> задаёт правило сортировки для новой колонки; если оно опущено, выбирается правило сортировки по умолчанию для нового типа. Необязательное предложение <TT
CLASS="LITERAL"
>USING</TT
> определяет, как новое значение колонки будет получено из старого; если оно отсутствует, выполняется приведение типа по умолчанию, как обычное присваивание значения старого типа новому. Предложение <TT
CLASS="LITERAL"
>USING</TT
> становится обязательным, если неявное приведение или присваивание с приведением старого типа к новому не определено.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET</TT
>/<TT
CLASS="LITERAL"
>DROP DEFAULT</TT
></DT
><DD
><P
>Эти формы задают или удаляют значение по умолчанию для колонок. Значения по умолчанию применяются только при последующих командах <TT
CLASS="COMMAND"
>INSERT</TT
> или <TT
CLASS="COMMAND"
>UPDATE</TT
>; их изменения не отражаются в строках, уже существующих в таблице.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET</TT
>/<TT
CLASS="LITERAL"
>DROP NOT NULL</TT
></DT
><DD
><P
>Эти формы определяют, будет ли колонка принимать значения NULL или нет. Задать <TT
CLASS="LITERAL"
>SET NOT NULL</TT
> можно, только если колонка не содержит значений NULL.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET STATISTICS</TT
></DT
><DD
><P
>Эта форма задаёт ориентир сбора статистики по колонке для последующих операций <A
HREF="sql-analyze.html"
>ANALYZE</A
>. Диапазон допустимых значений ориентира: 0..10000; при -1 применяется системное значение по умолчанию (<A
HREF="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET"
>default_statistics_target</A
>). За дополнительными сведениями об использовании статистики планировщиком запросов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> обратитесь к <A
HREF="planner-stats.html"
>Разделу 14.2</A
>.</P
><P
>SET STATISTICS запрашивает блокировку <TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET ( <TT
CLASS="REPLACEABLE"
><I
>атрибут</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> [, ... ] )</TT
><BR><TT
CLASS="LITERAL"
>RESET ( <TT
CLASS="REPLACEABLE"
><I
>атрибут</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>Эта форма устанавливает или сбрасывает параметры атрибутов. В настоящее время единственными параметрами атрибутов являются <TT
CLASS="LITERAL"
>n_distinct</TT
> и <TT
CLASS="LITERAL"
>n_distinct_inherited</TT
>, которые переопределяют оценку кол-ва_различных_значений, производимую последующими операциями <A
HREF="sql-analyze.html"
>ANALYZE</A
>. Атрибут <TT
CLASS="LITERAL"
>n_distinct</TT
> влияет на расчёт статистики по самой таблице, а <TT
CLASS="LITERAL"
>n_distinct_inherited</TT
> — на статистику по таблице и её потомкам. Если заданное значение положительно, <TT
CLASS="COMMAND"
>ANALYZE</TT
> будет считать, что колонка содержит именно это количество различных значений не NULL. Если заданное значение отрицательно (оно должно быть больше или равно -1), <TT
CLASS="COMMAND"
>ANALYZE</TT
> будет считать, что количество различных значений не NULL в колонке линейно зависит от размера таблицы; точное число будет получено умножением примерного размера таблицы на абсолютное значение параметра. Например, при -1 будет предполагаться, что различны все значения в колонке, а при -0,5 — что в среднем каждое значение повторяется дважды. Это может быть полезно, когда размер таблицы меняется со временем, так как умножение на число строк в таблице производится только во время планирования запроса. С 0 количество различных значений оценивается как обычно. За дополнительными сведениями об использовании статистики планировщиком запросов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> обратитесь к <A
HREF="planner-stats.html"
>Разделу 14.2</A
>.</P
><P
>Для изменения параметров атрибутов запрашивается блокировка <TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET STORAGE</TT
></DT
><DD
><P
>Эта форма устанавливает режим хранения колонки. Она определяет, хранятся ли данные внутри таблицы или в отдельной таблице <ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>, а также, сжимаются ли они. Режим <TT
CLASS="LITERAL"
>PLAIN</TT
> должен применяться для значений фиксированной длины, таких как <TT
CLASS="TYPE"
>integer</TT
>; это вариант хранения внутри, без сжатия. Режим <TT
CLASS="LITERAL"
>MAIN</TT
> применяется для хранения внутри, но сжатых данных, <TT
CLASS="LITERAL"
>EXTERNAL</TT
> — для внешнего хранения несжатых данных, а <TT
CLASS="LITERAL"
>EXTENDED</TT
> — для внешнего хранения сжатых данных. <TT
CLASS="LITERAL"
>EXTENDED</TT
> используется по умолчанию для большинства типов данных, поддерживающих хранилище не <TT
CLASS="LITERAL"
>PLAIN</TT
>. Применение <TT
CLASS="LITERAL"
>EXTERNAL</TT
> позволяет ускорить операции с подстроками на очень больших значениях <TT
CLASS="TYPE"
>text</TT
> и <TT
CLASS="TYPE"
>bytea</TT
>, за счёт проигрыша в объёме хранилища. Заметьте, что предложение <TT
CLASS="LITERAL"
>SET STORAGE</TT
> само по себе не меняет ничего в таблице, оно только задаёт стратегию, которая будет реализована при будущих изменениях в таблице. За дополнительными сведениями обратитесь к <A
HREF="storage-toast.html"
>Разделу 59.2</A
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ADD <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
> [ NOT VALID ]</TT
></DT
><DD
><P
>Эта форма добавляет в таблицу новое ограничение, с тем же синтаксисом, что и <A
HREF="sql-createtable.html"
>CREATE TABLE</A
>, и дополнительным указанием <TT
CLASS="LITERAL"
>NOT VALID</TT
>, которое в настоящее время разрешено только для ограничений внешнего ключа и ограничений-проверок. Если ограничение помечено как <TT
CLASS="LITERAL"
>NOT VALID</TT
>, потенциально длительная начальная проверка того, что ему удовлетворяют все строки, пропускается. Тем не менее это ограничение будет действовать при последующих добавлениях или изменениях (то есть, эти операции не будут выполнены, если, в случае с внешним ключом, в главной таблице не найдётся соответствующая строка, либо, в случае с ограничением-проверкой, новая строка нарушит проверочное условие). Но база данных не будет считать, что ограничение выполняется для всех строк таблицы, пока оно не будет проверено с применением указания <TT
CLASS="LITERAL"
>VALIDATE CONSTRAINT</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ADD <TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы_по_индексу</I
></TT
></TT
></DT
><DD
><P
>Эта форма добавляет в таблицу новое ограничение <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> или <TT
CLASS="LITERAL"
>UNIQUE</TT
> на базе существующего уникального индекса. В это ограничение будут включены все колонки данного индекса.</P
><P
>Индекс не может быть частичным и включать колонки-выражения. Кроме того, это должен быть индекс-B-дерево с порядком сортировки по умолчанию. С такими ограничениями добавляемые индексы не будут ничем отличаться от индексов, создаваемых обычными командами <TT
CLASS="LITERAL"
>ADD PRIMARY KEY</TT
> и <TT
CLASS="LITERAL"
>ADD UNIQUE</TT
>.</P
><P
>В случае с указанием <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>, если колонки индекса ещё не помечены <TT
CLASS="LITERAL"
>NOT NULL</TT
>, данная команда попытается выполнить <TT
CLASS="LITERAL"
>ALTER COLUMN SET NOT NULL</TT
> для каждой колонки. При этом потребуется произвести полное сканирование таблицы, чтобы убедиться, что колонка(и) не содержат NULL. Во всех остальных случаях это быстрая операция.</P
><P
>Если задано имя ограничения, индекс будет переименован и получит заданное имя. В противном случае, именем ограничения станет имя индекса.</P
><P
>После выполнения этой команды индекс становится <SPAN
CLASS="QUOTE"
>"принадлежащим"</SPAN
> ограничению, так же, как если бы он был создан обычной командой <TT
CLASS="LITERAL"
>ADD PRIMARY KEY</TT
> или <TT
CLASS="LITERAL"
>ADD UNIQUE</TT
>. Это значит, в частности, что при удалении ограничения индекс будет удалён вместе с ним.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Добавление ограничения на базе существующего индекса бывает полезно в ситуациях, когда новое ограничение требуется добавить, не блокируя изменения в таблице на долгое время. Для этого можно создать индекс командой <TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>, а затем задействовать его как полноценное ограничение, используя эту запись. См. следующий пример.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>ALTER CONSTRAINT</TT
></DT
><DD
><P
>Эта форма меняет атрибуты созданного ранее ограничения. В настоящее время изменять можно только ограничения внешнего ключа.</P
></DD
><DT
><TT
CLASS="LITERAL"
>VALIDATE CONSTRAINT</TT
></DT
><DD
><P
>Эта форма проверяет ограничение внешнего ключа или ограничение-проверку, созданное ранее с указанием <TT
CLASS="LITERAL"
>NOT VALID</TT
>, сканируя всю таблицу с целью убедиться, что ограничению удовлетворяют все строки. Если ограничение уже помечено как верное, ничего не происходит.</P
><P
>Проверка больших таблиц может быть довольно длительной. Смысл отделения проверки от собственно создания ограничения состоит в том, что это позволяет отложить проверку на время меньшей активности или провести дополнительную работу с существующими ошибками и при этом не допустить новых. Заметьте также, что во время осуществления проверки сама по себе она не препятствует выполнению обычных команд записи в таблицу.</P
><P
>При проверке запрашивается только блокировка <TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
> целевой таблицы. Для ограничений внешнего ключа требуется также блокировка <TT
CLASS="LITERAL"
>ROW SHARE</TT
> в таблице, на которую ссылается ограничение.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DROP CONSTRAINT [ IF EXISTS ]</TT
></DT
><DD
><P
>Эта форма удаляет указанное ограничение таблицы. Если указано <TT
CLASS="LITERAL"
>IF EXISTS</TT
> и заданное ограничение не существует, это не считается ошибкой. В этом случае выдаётся только замечание.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DISABLE</TT
>/<TT
CLASS="LITERAL"
>ENABLE [ REPLICA | ALWAYS ] TRIGGER</TT
></DT
><DD
><P
>Эти формы настраивают срабатывание триггера(ов), принадлежащего таблице. Отключённый триггер сохраняется в системе, но не выполняется, когда происходит вызывающего его событие. Для отложенных триггеров состояние включения проверяется при возникновении события, а не когда на самом деле вызывается функция триггера. Эта команда может отключить или включить один триггер по имени, либо все триггеры таблицы, либо только пользовательские триггеры (исключая сгенерированные внутрисистемные триггеры ограничений, например, триггеры, реализующие ограничения внешнего ключа или отложенные ограничения уникальности или исключений). Для отключения или включения сгенерированных внутрисистемных триггеров ограничений требуются права суперпользователя; отключать их следует с осторожностью, так как очевидно, что гарантировать целостность ограничений, если триггеры не работают, невозможно. На механизм срабатывания триггеров также влияет конфигурационная переменная <A
HREF="runtime-config-client.html#GUC-SESSION-REPLICATION-ROLE"
>session_replication_role</A
>. Просто включаемые триггеры будут срабатывать, когда роль репликации — <SPAN
CLASS="QUOTE"
>"origin"</SPAN
> (по умолчанию) или <SPAN
CLASS="QUOTE"
>"local"</SPAN
>. Триггеры, включённые указанием <TT
CLASS="LITERAL"
>ENABLE REPLICA</TT
>, будут срабатывать, только если текущий режим сеанса — <SPAN
CLASS="QUOTE"
>"replica"</SPAN
>, а после указания <TT
CLASS="LITERAL"
>ENABLE ALWAYS</TT
> триггеры срабатывают вне зависимости от текущего режима репликации.</P
></DD
><DT
><TT
CLASS="LITERAL"
>DISABLE</TT
>/<TT
CLASS="LITERAL"
>ENABLE [ REPLICA | ALWAYS ] RULE</TT
></DT
><DD
><P
>Эти формы настраивают срабатывание правил перезаписи, относящихся к таблице. Отключённое правило сохраняется в системе, но не применяется во время переписывания запроса. По сути эти операции подобны операциям включения/отключения триггеров. Однако это не распространяется на правила <TT
CLASS="LITERAL"
>ON SELECT</TT
> — они применяются всегда, чтобы представления продолжали работать, даже в сеансах, исполняющих не основную роль репликации.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CLUSTER ON</TT
></DT
><DD
><P
>Эта форма выбирает индекс по умолчанию для последующих операций <A
HREF="sql-cluster.html"
>CLUSTER</A
>. Собственно кластеризация таблицы при этом не выполняется.</P
><P
>Для изменения параметров кластеризации запрашивается блокировка <TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITHOUT CLUSTER</TT
></DT
><DD
><P
>Эта форма удаляет последнее заданное указание индекса для <A
HREF="sql-cluster.html"
>CLUSTER</A
>. Её действие отразится на будущих операциях кластеризации, для которых не будет задан индекс.</P
><P
>Для изменения параметров кластеризации запрашивается блокировка <TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITH OIDS</TT
></DT
><DD
><P
>Эта форма добавляет в таблицу системную колонку <TT
CLASS="LITERAL"
>oid</TT
> (см. <A
HREF="ddl-system-columns.html"
>Раздел 5.4</A
>). Если в таблице уже есть такая колонка, она не делает ничего.</P
><P
>Заметьте, что это не равнозначно команде <TT
CLASS="LITERAL"
>ADD COLUMN oid oid</TT
> (эта команда добавит не системную, а обычную колонку с подходящим именем <TT
CLASS="LITERAL"
>oid</TT
>).</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITHOUT OIDS</TT
></DT
><DD
><P
>Эта форма удаляет из таблицы системную колонку <TT
CLASS="LITERAL"
>oid</TT
>. Это в точности равнозначно <TT
CLASS="LITERAL"
>DROP COLUMN oid RESTRICT</TT
>, за исключением того, что в случае отсутствия колонки <TT
CLASS="LITERAL"
>oid</TT
> ошибки не будет.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>Эта форма меняет один или несколько параметров хранения таблицы. Подробнее допустимые параметры описаны в <A
HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"
><I
>Параметры хранения</I
></A
>. Заметьте, что эта команда не меняет содержимое таблицы немедленно; в зависимости от параметра может потребоваться перезаписать таблицы, чтобы получить желаемый эффект. Это можно сделать с помощью команд <A
HREF="sql-vacuum.html"
>VACUUM FULL</A
>, <A
HREF="sql-cluster.html"
>CLUSTER</A
> или одной из форм <TT
CLASS="COMMAND"
>ALTER TABLE</TT
>, принудительно перезаписывающих таблицу.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Хотя <TT
CLASS="COMMAND"
>CREATE TABLE</TT
> позволяет указать <TT
CLASS="LITERAL"
>OIDS</TT
> в синтаксисе <TT
CLASS="LITERAL"
>WITH (<TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
>)</TT
>, <TT
CLASS="COMMAND"
>ALTER TABLE</TT
> не воспринимает <TT
CLASS="LITERAL"
>OIDS</TT
> как параметр хранения. Поэтому для изменения характеристики OID следует применять формы <TT
CLASS="LITERAL"
>SET WITH OIDS</TT
> и <TT
CLASS="LITERAL"
>SET WITHOUT OIDS</TT
>.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>RESET ( <TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>Эта форма сбрасывает один или несколько параметров хранения к значениям по умолчанию. Как и с <TT
CLASS="LITERAL"
>SET</TT
>, для полного обновления таблицы может потребоваться перезаписать таблицу.</P
></DD
><DT
><TT
CLASS="LITERAL"
>INHERIT <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
></TT
></DT
><DD
><P
>Эта форма назначает целевую таблицу потомком заданной родительской таблицы. Впоследствии запросы к родительской таблице будут включать записи и целевой таблицы. Чтобы таблица могла стать потомком, она должна содержать те же колонки, что и родительская (хотя она может включать и дополнительные колонки). Колонки должны иметь одинаковые типы данных и, если в родительской таблице какие-то из них имеют ограничение <TT
CLASS="LITERAL"
>NOT NULL</TT
>, они должны иметь ограничение <TT
CLASS="LITERAL"
>NOT NULL</TT
> и в таблице-потомке.</P
><P
>Также в таблице-потомке должны присутствовать все ограничения <TT
CLASS="LITERAL"
>CHECK</TT
> родительской таблицы, за исключением ненаследуемых (то есть созданных командой <TT
CLASS="LITERAL"
>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</TT
>), которые игнорируются; при этом все соответствующие ограничения в таблице-потомке не должны быть ненаследуемыми. В настоящее время ограничения <TT
CLASS="LITERAL"
>UNIQUE</TT
>, <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> и <TT
CLASS="LITERAL"
>FOREIGN KEY</TT
> не учитываются, но в будущем это может измениться.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NO INHERIT <TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
></TT
></DT
><DD
><P
>Эта форма удаляет целевую таблицу из списка потомков указанной родительской таблицы. Результаты запросов к родительской таблице после этого не будут включать записи, взятые из целевой таблицы.</P
></DD
><DT
><TT
CLASS="LITERAL"
>OF <TT
CLASS="REPLACEABLE"
><I
>имя_типа</I
></TT
></TT
></DT
><DD
><P
>Эта форма связывает таблицу с составным типом, как если бы она была сформирована командой <TT
CLASS="COMMAND"
>CREATE TABLE OF</TT
>. При этом список имён и типов колонок должен точно соответствовать тому, что образует составной тип; отличие возможно в системном столбце <TT
CLASS="LITERAL"
>oid</TT
>. Кроме того, таблица не должна быть потомком какой-либо другой таблицы. Эти ограничения — залог того, что команда <TT
CLASS="COMMAND"
>CREATE TABLE OF</TT
> позволит создать таблицу с таким же определением.</P
></DD
><DT
><TT
CLASS="LITERAL"
>NOT OF</TT
></DT
><DD
><P
>Эта форма разрывает связь типизированной таблицы с её типом.</P
></DD
><DT
><TT
CLASS="LITERAL"
>OWNER</TT
></DT
><DD
><P
>Эта форма меняет владельца таблицы, последовательности, представления, материализованного представления или сторонней таблицы на заданного пользователя.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET TABLESPACE</TT
></DT
><DD
><P
>Эта форма меняет табличное пространство таблицы на заданное и перемещает файлы данных, связанные с таблицей, в новое пространство. Индексы таблицы, если они имеются, не перемещаются; однако их можно переместить отдельно дополнительными командами <TT
CLASS="LITERAL"
>SET TABLESPACE</TT
>. Форма <TT
CLASS="LITERAL"
>ALL IN TABLESPACE</TT
> позволяет перенести в другое табличное пространство все таблицы текущей базы данных, при этом она сначала блокирует все таблицы, а затем переносит каждую из них. Эта форма также поддерживает указание <TT
CLASS="LITERAL"
>OWNED BY</TT
>, с которым перемещаются только таблицы указанного владельца. Если указан параметр <TT
CLASS="LITERAL"
>NOWAIT</TT
>, команда завершится ошибкой, если не сможет получить все требуемые блокировки немедленно. Заметьте, что системные каталоги эта форма не перемещает; если требуется переместить их, следует использовать <TT
CLASS="COMMAND"
>ALTER DATABASE</TT
> или явные вызовы <TT
CLASS="COMMAND"
>ALTER TABLE</TT
>. Отношения <TT
CLASS="LITERAL"
>information_schema</TT
> не считаются частью системных каталогов и подлежат перемещению. См. также <A
HREF="sql-createtablespace.html"
>CREATE TABLESPACE</A
>.</P
></DD
><DT
><A
NAME="SQL-CREATETABLE-REPLICA-IDENTITY"
></A
><TT
CLASS="LITERAL"
>REPLICA IDENTITY</TT
></DT
><DD
><P
>Эта форма меняет информацию, записываемую в журнал упреждающей записи для идентификации изменяемых или удаляемых строк. Данный параметр действует только при использовании логической репликации. В режиме <TT
CLASS="LITERAL"
>DEFAULT</TT
> (по умолчанию для не системных таблиц) записывается старые значения колонок первичного ключа, если он есть. В режиме <TT
CLASS="LITERAL"
>USING INDEX</TT
> записываются старые значения колонок, составляющих заданный индекс, который должен быть уникальным, не частичным, не отложенным и включать только колонки, помеченные <TT
CLASS="LITERAL"
>NOT NULL</TT
>. В режиме <TT
CLASS="LITERAL"
>FULL</TT
> записываются старые значения всех колонок в строке, а в режиме <TT
CLASS="LITERAL"
>NOTHING</TT
> (по умолчанию для системных таблиц) никакая информация о старой строке не записывается. Во всех случаях старые значения записываются в журнал, только если как минимум в одной колонке из тех, что должны быть записаны, произошли изменения в новой строке.</P
></DD
><DT
><TT
CLASS="LITERAL"
>RENAME</TT
></DT
><DD
><P
>Формы <TT
CLASS="LITERAL"
>RENAME</TT
> меняют имя таблицы (или индекса, последовательности, представления, материализованного представления или сторонней таблицы), имя отдельной колонки таблицы или имя ограничения таблицы. На хранимые данные это не влияет.</P
></DD
><DT
><TT
CLASS="LITERAL"
>SET SCHEMA</TT
></DT
><DD
><P
>Эта форма перемещает таблицу в другую схему. Вместе с таблицей перемещаются связанные с ней индексы и ограничения, а также последовательности, принадлежащие колонкам таблицы.</P
></DD
></DL
></DIV
><P></P
><P
>Все действия, кроме <TT
CLASS="LITERAL"
>RENAME</TT
>, <TT
CLASS="LITERAL"
>SET TABLESPACE</TT
> и <TT
CLASS="LITERAL"
>SET SCHEMA</TT
>, можно объединить в список множественных изменений и применить параллельно. Например, можно добавить несколько колонок и/или изменить тип колонок в одной команде. Это особенно полезно для больших таблиц, так как вся таблица обрабатывается за один проход.</P
><P
>Выполнить <TT
CLASS="COMMAND"
>ALTER TABLE</TT
> может только владелец соответствующей таблицы. Чтоб сменить схему или табличное пространство таблицы, необходимо также иметь право <TT
CLASS="LITERAL"
>CREATE</TT
> в новой схеме или табличном пространстве. Чтобы сделать таблицу потомком другой таблицы, нужно быть владельцем и родительской таблицы. Чтобы сменить владельца, необходимо быть непосредственным или опосредованным членом новой роли-владельца, а эта роль должна иметь право <TT
CLASS="LITERAL"
>CREATE</TT
> в схеме таблицы. (С такими ограничениями при смене владельца не происходит ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать таблицу. Однако суперпользователь может сменить владельца таблицы в любом случае.) Чтобы добавить колонку, сменить тип колонки или применить предложение <TT
CLASS="LITERAL"
>OF</TT
>, необходимо также иметь право <TT
CLASS="LITERAL"
>USAGE</TT
> для соответствующего типа данных.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN69873"
></A
><H2
>Параметры</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя</I
></TT
></DT
><DD
><P
>Имя (возможно, дополненное схемой) существующей таблицы, подлежащей изменению. Если перед именем таблицы указано <TT
CLASS="LITERAL"
>ONLY</TT
>, изменяется только заданная таблица. Без <TT
CLASS="LITERAL"
>ONLY</TT
> изменяется и заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно также добавить необязательное указание <TT
CLASS="LITERAL"
>*</TT
>, чтобы явно обозначить, что изменению подлежат все дочерние таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_колонки</I
></TT
></DT
><DD
><P
>Имя новой или существующей колонки.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>новое_имя_колонки</I
></TT
></DT
><DD
><P
>Новое имя существующей колонки.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>новое_имя</I
></TT
></DT
><DD
><P
>Новое имя таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>тип_данных</I
></TT
></DT
><DD
><P
>Тип данных новой колонки или новый тип данных существующей колонки.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>ограничение_таблицы</I
></TT
></DT
><DD
><P
>Новое ограничение таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_ограничения</I
></TT
></DT
><DD
><P
>Имя нового или существующего ограничения.</P
></DD
><DT
><TT
CLASS="LITERAL"
>CASCADE</TT
></DT
><DD
><P
>Автоматически удалять объекты, зависящие от удаляемой колонки или ограничения (например, представления, содержащие эту колонку).</P
></DD
><DT
><TT
CLASS="LITERAL"
>RESTRICT</TT
></DT
><DD
><P
>Отказать в удалении колонки или ограничения, если существуют зависящие от них объекты. Это поведение по умолчанию.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_триггера</I
></TT
></DT
><DD
><P
>Имя включаемого или отключаемого триггера.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ALL</TT
></DT
><DD
><P
>Отключить или включить все триггеры, принадлежащие таблице. (Для этого требуются права суперпользователя, если в числе этих триггеров оказываются сгенерированные внутрисистемные триггеры исключений, например те, что реализуют ограничения внешнего ключа или отложенные ограничения уникальности и исключений.)</P
></DD
><DT
><TT
CLASS="LITERAL"
>USER</TT
></DT
><DD
><P
>Отключить или включить все триггеры, принадлежащие таблице, за исключением сгенерированных внутрисистемных триггеров исключений, например, тех, что реализуют ограничения внешнего ключа или отложенные ограничения уникальности и исключений.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>имя_индекса</I
></TT
></DT
><DD
><P
>Имя существующего индекса.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>параметр_хранения</I
></TT
></DT
><DD
><P
>Имя параметра хранения таблицы</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
></DT
><DD
><P
>Новое значение параметра хранения таблицы. Это может быть число или строка, в зависимости от параметра.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>таблица_родитель</I
></TT
></DT
><DD
><P
>Родительская таблица, с которой будет установлена или разорвана связь данной таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>новый_владелец</I
></TT
></DT
><DD
><P
>Имя пользователя, назначаемого новым владельцем таблицы.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>новое_табл_пространство</I
></TT
></DT
><DD
><P
>Имя табличного пространства, в которое будет перемещена таблица.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>новая_схема</I
></TT
></DT
><DD
><P
>Имя схемы, в которую будет перемещена таблица.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN69974"
></A
><H2
>Замечания</H2
><P
>Ключевое слово <TT
CLASS="LITERAL"
>COLUMN</TT
> не несёт смысловой нагрузки и может быть опущено.</P
><P
>Когда колонка добавляется с помощью <TT
CLASS="LITERAL"
>ADD COLUMN</TT
>, во всех существующих в таблице строках эта колонка инициализируется значением по умолчанию (или NULL, если предложение <TT
CLASS="LITERAL"
>DEFAULT</TT
> для колонки отсутствует). Если предложение <TT
CLASS="LITERAL"
>DEFAULT</TT
> отсутствует, это сводится только к изменению метаданных, непосредственного изменения данных таблицы не происходит; добавленные значения NULL выводятся при чтении.</P
><P
>Добавление колонки с предложением <TT
CLASS="LITERAL"
>DEFAULT</TT
> или изменение типа существующей колонки влечёт за собой перезапись всей таблицы и её индексов. Но возможно исключение при смене типа существующей колонки: если предложение <TT
CLASS="LITERAL"
>USING</TT
> не меняет содержимое колонки и старый тип двоично приводится к новому или является неограниченным доменом поверх нового типа, перезапись таблицы не требуется; хотя все индексы с затронутыми колонками всё же требуется перестроить. При добавлении или удалении системной колонки clause <TT
CLASS="LITERAL"
>oid</TT
> также необходима перезапись всей таблицы. Для перестроения больших таблиц и/или их индексов может понадобиться довольно много времени и временно потребуется вдвое больше места на диске.</P
><P
>При добавлении ограничений <TT
CLASS="LITERAL"
>CHECK</TT
> или <TT
CLASS="LITERAL"
>NOT NULL</TT
> требуется просканировать таблицу с целью убедиться в том, что все существующие строки удовлетворяют ограничению.</P
><P
>Возможность объединения множества изменений в одну команду <TT
CLASS="COMMAND"
>ALTER TABLE</TT
> полезна в основном тем, что позволяет совместить сканирования и перезаписи таблицы, требуемые этим операциям, и выполнить их за один проход.</P
><P
>Форма <TT
CLASS="LITERAL"
>DROP COLUMN</TT
> не удаляет колонку физически, а просто делает её невидимой для операций SQL. При последующих операциях добавления или изменения в эту колонку будет записываться значение NULL. Таким образом, удаление колонки выполняется быстро, но при этом размер таблицы на диске не уменьшается, так как пространство, занимаемое удалённой колонкой, не высвобождается. Это пространство будет освобождено со временем, по мере изменения существующих строк. (При удалении системной колонки <TT
CLASS="LITERAL"
>oid</TT
> это поведение не наблюдается, так как немедленно выполняется перезапись таблицы.)</P
><P
>Чтобы выполнить перезапись таблицы немедленно, можно воспользоваться командой <A
HREF="sql-vacuum.html"
>VACUUM FULL</A
>, <A
HREF="sql-cluster.html"
>CLUSTER</A
> или одной из форм ALTER TABLE, инициирующих перезапись. При этом никаких семантически видимых изменений в таблице не происходит, но таблица избавляется от уже неиспользуемых данных.</P
><P
>В указании <TT
CLASS="LITERAL"
>USING</TT
> предложения <TT
CLASS="LITERAL"
>SET DATA TYPE</TT
> на самом деле можно записать выражение со старыми значениями строки; то есть, оно может ссылаться как на преобразуемые колонки, так и на другие. Это позволяет записывать в <TT
CLASS="LITERAL"
>SET DATA TYPE</TT
> очень общие преобразования данных. Ввиду такой гибкости, выражение <TT
CLASS="LITERAL"
>USING</TT
> не применяется к значению по умолчанию данной колонки (если таковое есть); результат может быть не константным выражением, что требуется для значения по умолчанию. Это означает, что в случае отсутствия явного приведения или присваивания старого типа новому, <TT
CLASS="LITERAL"
>SET DATA TYPE</TT
> может не справиться с преобразованием значения по умолчанию, несмотря на то, что применяется предложение <TT
CLASS="LITERAL"
>USING</TT
>. В этих случаях нужно удалить значение по умолчанию с помощью <TT
CLASS="LITERAL"
>DROP DEFAULT</TT
>, выполнить <TT
CLASS="LITERAL"
>ALTER TYPE</TT
>, а затем с помощью <TT
CLASS="LITERAL"
>SET DEFAULT</TT
> задать новое подходящее значение по умолчанию. Подобные соображения применимы и в отношении индексов и ограничений с этой колонкой.</P
><P
>Если у таблицы есть дочерние таблицы, добавлять, переименовывать или менять тип колонки, либо переименовывать наследуемое ограничение в родительской таблице, не делая того же самого во всех дочерних таблицах, нельзя. То есть, команда <TT
CLASS="COMMAND"
>ALTER TABLE ONLY</TT
> выполнена не будет. Это гарантирует, что дочерние таблицы всегда будут содержать те же колонки, что и родительская.</P
><P
>Рекурсивная операция <TT
CLASS="LITERAL"
>DROP COLUMN</TT
> удалит колонку из дочерней таблицы, только если эта колонка не наследуется от каких-то других родителей и не была определена в дочерней таблице независимо. Нерекурсивная операция <TT
CLASS="LITERAL"
>DROP COLUMN</TT
> (т. е., <TT
CLASS="COMMAND"
>ALTER TABLE ONLY ... DROP COLUMN</TT
>) никогда не удаляет унаследованные колонки, но вместо этого помечает их как независимо определённые, а не наследуемые.</P
><P
>Действия <TT
CLASS="LITERAL"
>TRIGGER</TT
>, <TT
CLASS="LITERAL"
>CLUSTER</TT
>, <TT
CLASS="LITERAL"
>OWNER</TT
> и <TT
CLASS="LITERAL"
>TABLESPACE</TT
> никогда не распространяются рекурсивно на дочерние таблицы; то есть, они всегда выполняются так, как будто указано <TT
CLASS="LITERAL"
>ONLY</TT
>. Операция добавления ограничения выполняется рекурсивно только для ограничений <TT
CLASS="LITERAL"
>CHECK</TT
>, не помеченных как <TT
CLASS="LITERAL"
>NO INHERIT</TT
>.</P
><P
>Какие-либо изменения таблиц системного каталога не допускаются.</P
><P
>За более подробным описанием допустимых параметров обратитесь к <A
HREF="sql-createtable.html"
>CREATE TABLE</A
>. Дополнительно о наследовании можно узнать в <A
HREF="ddl.html"
>Главе 5</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN70025"
></A
><H2
>Примеры</H2
><P
>Добавление в таблицу колонки типа <TT
CLASS="TYPE"
>varchar</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD COLUMN address varchar(30);</PRE
><P></P
><P
>Удаление колонки из таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors DROP COLUMN address RESTRICT;</PRE
><P></P
><P
>Изменение типов двух существующих колонок в одной операции: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);</PRE
><P></P
><P
>Смена типа целочисленной колонки, содержащей время в стиле UNIX, на тип <TT
CLASS="TYPE"
>timestamp with time zone</TT
> с применением предложения <TT
CLASS="LITERAL"
>USING</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';</PRE
><P></P
><P
>То же самое, но в случае, когда у колонки есть значение по умолчанию, не приводимое автоматически к новому типу данных: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();</PRE
><P></P
><P
>Переименование существующей колонки: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME COLUMN address TO city;</PRE
><P></P
><P
>Переименование существующей таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME TO suppliers;</PRE
><P></P
><P
>Переименование существующего ограничения: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;</PRE
><P></P
><P
>Добавление в колонку ограничения NOT NULL: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;</PRE
><P> Удаление ограничения NOT NULL из колонки: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;</PRE
><P></P
><P
>Добавление ограничения-проверки в таблицу и все её потомки: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);</PRE
><P></P
><P
>Добавление ограничения-проверки только в таблицу, но не в её потомки: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;</PRE
><P> (Данное ограничение-проверка не будет наследоваться и будущими потомками тоже.)</P
><P
>Удаление ограничения-проверки из таблицы и из всех её потомков: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors DROP CONSTRAINT zipchk;</PRE
><P></P
><P
>Удаление ограничения-проверки только из самой таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;</PRE
><P> (Ограничение-проверка остаётся во всех дочерних таблицах.)</P
><P
>Добавление в таблицу ограничения внешнего ключа: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);</PRE
><P></P
><P
>Добавление в таблицу ограничения внешнего ключа с наименьшим влиянием на работу других: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;</PRE
><P></P
><P
>Добавление в таблицу ограничения уникальности (по нескольким колонкам): </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);</PRE
><P></P
><P
>Добавление в таблицу первичного ключа с автоматическим именем (учтите, что в таблице может быть только один первичный ключ): </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD PRIMARY KEY (dist_id);</PRE
><P></P
><P
>Перемещение таблицы в другое табличное пространство: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors SET TABLESPACE fasttablespace;</PRE
><P></P
><P
>Перемещение таблицы в другую схему: </P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE myschema.distributors SET SCHEMA yourschema;</PRE
><P></P
><P
>Пересоздание ограничения первичного ключа без блокировки изменений в процессе перестроения индекса: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN70071"
></A
><H2
>Совместимость</H2
><P
>Формы <TT
CLASS="LITERAL"
>ADD</TT
> (без <TT
CLASS="LITERAL"
>USING INDEX</TT
>), <TT
CLASS="LITERAL"
>DROP</TT
>, <TT
CLASS="LITERAL"
>SET DEFAULT</TT
> и <TT
CLASS="LITERAL"
>SET DATA TYPE</TT
> (без <TT
CLASS="LITERAL"
>USING</TT
>) соответствуют стандарту SQL. Другие формы являются расширениями стандарта SQL, реализованными в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Кроме того, расширением является возможность указать в одной команде <TT
CLASS="COMMAND"
>ALTER TABLE</TT
> несколько операций изменения.</P
><P
><TT
CLASS="COMMAND"
>ALTER TABLE DROP COLUMN</TT
> позволяет удалить единственную колонку таблицы и оставить таблицу без колонок. Это является расширением стандарта SQL, который не допускает существование таблиц с нулём колонок.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN70084"
></A
><H2
>См. также</H2
><A
HREF="sql-createtable.html"
>CREATE TABLE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-altersystem.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-altertablespace.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ALTER SYSTEM</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>ALTER TABLESPACE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>