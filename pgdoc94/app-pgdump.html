<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>pg_dump</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Клиентские приложения PostgreSQL"
HREF="reference-client.html"><LINK
REL="PREVIOUS"
TITLE="pg_config"
HREF="app-pgconfig.html"><LINK
REL="NEXT"
TITLE="            pg_dumpall
          "
HREF="app-pg-dumpall.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="pg_config"
HREF="app-pgconfig.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="            pg_dumpall
          "
HREF="app-pg-dumpall.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="APP-PGDUMP"
></A
>pg_dump</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN87869"
></A
><H2
>Название</H2
>pg_dump&nbsp;--&nbsp;выгрузить базу данных <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> в формате скрипта в файл или архив</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN87873"
></A
><H2
>Синтаксис</H2
><P
><TT
CLASS="COMMAND"
>pg_dump</TT
> [              <TT
CLASS="REPLACEABLE"
><I
>параметр-подключения</I
></TT
>
            ...] [              <TT
CLASS="REPLACEABLE"
><I
>параметр</I
></TT
>
            ...] [              <TT
CLASS="REPLACEABLE"
><I
>база_данных</I
></TT
>
            ]</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="PG-DUMP-DESCRIPTION"
></A
><H2
>Описание</H2
><P
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> это приложение для резервирования баз <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Оно создаёт согласованные копии, в том числе и на работающих базах данных. <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> не блокирует других пользователей базы, ни на чтение, ни на запись.</P
><P
>Приложение выводит данные либо в скрипты, либо в архивные форматы файлов. Скрипты представляют собой текстовые файлы, содержащие SQL-команды, необходимые для воссоздания базы данных до состояния на момент создания скрипта. Для восстановления из скрипта его содержимое можно передать утилите <A
HREF="app-psql.html"
>            <SPAN
CLASS="APPLICATION"
>psql</SPAN
>
          </A
>. Скрипты можно использовать для восстановления на других машинах, в том числе с иной архитектурой. Также скрипты с некоторыми изменениями можно использовать в других базах данных SQL.</P
><P
>Для восстановления из архивных форматов файлов используется утилита <A
HREF="app-pgrestore.html"
>pg_restore</A
>. Эти форматы позволяют указывать <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
> какие объекты базы данных восстановить, а также позволяют изменить порядок следования восстанавливаемых объектов. Архивные форматы файлов спроектированы так, чтобы их можно были переносить на другие платформы с другой архитектурой.</P
><P
>Применение архивных форматов в сочетании утилит <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
> и <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> позволяет организовывать эффективный механизм архивации и переноса данных. <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> можно использовать для резервирования всей базы данных, а затем при применении <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
> выбрать нужные объекты для восстановления. Наиболее гибкие форматы резервных файлов это <SPAN
CLASS="QUOTE"
>"custom"</SPAN
> (<TT
CLASS="OPTION"
>-Fc</TT
>) и <SPAN
CLASS="QUOTE"
>"directory"</SPAN
> (<TT
CLASS="OPTION"
>-Fd</TT
>). Они позволяют выбрать и изменить порядок объектов, поддерживают восстановление в несколько потоков, а также сжимаются по умолчанию. При этом формат <SPAN
CLASS="QUOTE"
>"directory"</SPAN
> единственный, позволяющий выгружать данные в несколько потоков.</P
><P
>Во время работы <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> следует обращать внимание на предупреждения, которые печатаются в стандартный поток ошибок, особенно ввиду рассмотренных далее ограничений.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="PG-DUMP-OPTIONS"
></A
><H2
>Параметры</H2
><P
>Параметры командной строки для управления содержимым и форматом вывода. <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>база_данных</I
></TT
></DT
><DD
><P
>Указывает имя базы данных, из которой будут выгружаться данные. Если имя не задано, то используется значение переменной окружения <TT
CLASS="ENVAR"
>PGDATABASE</TT
>. Если и переменная не задана, то в качестве имени базы будет взято имя пользователя, под которым осуществляется подключение.</P
></DD
><DT
><TT
CLASS="OPTION"
>-a</TT
><BR><TT
CLASS="OPTION"
>--data-only</TT
></DT
><DD
><P
>Выводить только данные, но не схемы объектов (DDL). Будут копироваться данные таблиц, большие объекты, значения последовательностей.</P
><P
>Флаг похож на <TT
CLASS="OPTION"
>--section=data</TT
>, но по историческим причинам не равнозначен ему.</P
></DD
><DT
><TT
CLASS="OPTION"
>-b</TT
><BR><TT
CLASS="OPTION"
>--blobs</TT
></DT
><DD
><P
>Включить большие объекты в копию. Это поведение по умолчанию, за исключением ситуаций, когда используются флаги <TT
CLASS="OPTION"
>--schema</TT
>, <TT
CLASS="OPTION"
>--table</TT
>, или <TT
CLASS="OPTION"
>--schema-only</TT
>, таким образом применение <TT
CLASS="OPTION"
>-b</TT
> целесообразно для копий выборочных объектов.</P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
><BR><TT
CLASS="OPTION"
>--clean</TT
></DT
><DD
><P
>Включить в выходной файл команды удаления (DROP) объектов базы данных перед командами создания (CREATE) этих объектов. Если дополнительно не указать флаг <TT
CLASS="OPTION"
>--if-exists</TT
>, то при восстановлении в базу данных, где некоторые объекты отсутствуют, попытка удаления несуществующего объекта будет приводить к ошибке, которую можно игнорировать.</P
><P
>Параметр полезен только для вывода файлов в формате <TT
CLASS="LITERAL"
>plain</TT
>. Для архивных форматов, этот параметр можно указывать при вызове <TT
CLASS="COMMAND"
>pg_restore</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-C</TT
><BR><TT
CLASS="OPTION"
>--create</TT
></DT
><DD
><P
>Сформировать в начале вывода команду для создания базы данных и затем подключения к ней. В этом случае не важно, какая база указана в параметрах подключения перед выполнением скрипта. Также, если указан ключ <TT
CLASS="OPTION"
>--clean</TT
>, то скрипт сначала удалит, а затем пересоздаст базу данных перед подключением к ней.</P
><P
>Параметр полезен только для вывода файлов в формате <TT
CLASS="LITERAL"
>plain</TT
>. Для архивных форматов, этот параметр можно указывать при вызове <TT
CLASS="COMMAND"
>pg_restore</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-E <TT
CLASS="REPLACEABLE"
><I
>кодировка</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--encoding=<TT
CLASS="REPLACEABLE"
><I
>кодировка</I
></TT
></TT
></DT
><DD
><P
>Создать копию в заданной кодировке. По умолчанию копия создаётся в кодировке, используемой базой данных. Другой способ достичь того же результата это установить желаемую кодировку в переменную окружения <TT
CLASS="ENVAR"
>PGCLIENTENCODING</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-f <TT
CLASS="REPLACEABLE"
><I
>файл</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--file=<TT
CLASS="REPLACEABLE"
><I
>файл</I
></TT
></TT
></DT
><DD
><P
>Отправить вывод в указанный файл. Параметр можно не указывать, если используется формат с выводом в файл. В этом случае будет использован стандартный вывод. Однако для формата с выводом в каталог параметр является обязательным и должен указывать на путь к каталогу. В таком случае каталог будет создан командой <TT
CLASS="COMMAND"
>pg_dump</TT
> и не должен существовать заранее.</P
></DD
><DT
><TT
CLASS="OPTION"
>-F <TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--format=<TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></TT
></DT
><DD
><P
>Указывает формат вывода копии. <TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
> может принимать следующие значения: <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>p</TT
><BR><TT
CLASS="LITERAL"
>plain</TT
></DT
><DD
><P
>Сформировать текстовый <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скрипт. Это поведение по умолчанию.</P
></DD
><DT
><TT
CLASS="LITERAL"
>c</TT
><BR><TT
CLASS="LITERAL"
>custom</TT
></DT
><DD
><P
>Вывести копию в архивном формате, пригодном для дальнейшего использования утилитой <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>. Наравне с <TT
CLASS="LITERAL"
>directory</TT
> является наиболее гибким форматом, позволяющим вручную выбирать и сортировать восстанавливаемые объекты. Вывод в этом формате по умолчанию сжимается.</P
></DD
><DT
><TT
CLASS="LITERAL"
>d</TT
><BR><TT
CLASS="LITERAL"
>directory</TT
></DT
><DD
><P
>Выгрузить в формате каталога. Этот формат пригоден для дальнейшего использования утилитой <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>. При этом будет создан каталог, в котором для каждой таблицы и большого объекта будут созданы отдельные файлы, а также файл оглавления в машинно-читаемом формате, понятном для <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>. С полученной резервной копией можно работать штатными средствами Unix, например, несжатую копию можно сжать посредством <SPAN
CLASS="APPLICATION"
>gzip</SPAN
>. Этот формат по умолчанию сжимается, а также поддерживает работу в несколько потоков.</P
></DD
><DT
><TT
CLASS="LITERAL"
>t</TT
><BR><TT
CLASS="LITERAL"
>tar</TT
></DT
><DD
><P
>Вывести копию в формате <TT
CLASS="COMMAND"
>tar</TT
>, для дальнейшего использования утилитой <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>. Этот формат совместим с форматом вывода в каталог. При распаковке полученной копии на выходе получается структура формата вывода в каталог. При этом не поддерживается сжатие и есть ограничение на размер отдельной таблицы в 8 Гб. Также нет возможности регулировать порядок восстановления таблиц из копии.</P
></DD
></DL
></DIV
><P></P
></DD
><DT
><TT
CLASS="OPTION"
>-i</TT
><BR><TT
CLASS="OPTION"
>--ignore-version</TT
></DT
><DD
><P
>Устаревший флаг и сейчас игнорируется.</P
></DD
><DT
><TT
CLASS="OPTION"
>-j <TT
CLASS="REPLACEABLE"
><I
>njobs</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--jobs=<TT
CLASS="REPLACEABLE"
><I
>njobs</I
></TT
></TT
></DT
><DD
><P
>Запустить выгрузку в несколько потоков, которые смогут параллельно обрабатывать <TT
CLASS="REPLACEABLE"
><I
>njobs</I
></TT
> таблиц. Это уменьшает время работы, но увеличивает нагрузку на сервер. Этот параметр можно использовать только с форматом вывода <TT
CLASS="LITERAL"
>directory</TT
>, так как это единственный формат, позволяющий нескольким процессам одновременно записывать данные.</P
><P
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> откроет <TT
CLASS="REPLACEABLE"
><I
>njobs</I
></TT
> + 1 соединений с базой данных. Таким образом необходимо обеспечить достаточное значение параметра <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>.</P
><P
>Если во время выгрузки в несколько потоков, параллельно работающие сессии будут запрашивать эксклюзивные блокировки на объекты базы данных, то <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> может завершиться аварийно. Дело в том, что головной процесс <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> вначале запрашивает разделяемые блокировки на объекты, которые позже будут выгружать рабочие процессы. Это делается для того, чтобы никто не смог удалить объекты на время работы <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. Если же другая сессия запросит эксклюзивную блокировку на объект, то запрос на блокировку будет поставлен в очередь, до тех пор пока разделяемая блокировка головного процесса <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> не будет снята. В последующем, любая попытка доступа к этому объекту будет вставать в очередь, вслед за эксклюзивной блокировкой. В том числе в очередь попадет и рабочий процесс <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. Если не принять меры предосторожности, то получим классическую взаимоблокировку. Для предупреждения подобных конфликтов, рабочий процесс <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> ещё раз запрашивает разделяемую блокировку на объект с указанием <TT
CLASS="LITERAL"
>NOWAIT</TT
>. И если он не смог получить блокировку, значит кто-то ещё запросил эксклюзивную блокировку объекта. А это значит, что нет возможности продолжить выгрузку, поэтому <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> прерывает дальнейшую работу.</P
><P
>Для получения целостной резервной копии серверу баз данных необходимо поддерживать функциональность синхронизированных снимков, которая была введена в версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.2. Это позволяет разным клиентам работать с одной и той же версией данных, несмотря на использование разных подключений. <TT
CLASS="COMMAND"
>pg_dump -j</TT
> использует множественные подключения. Первое подключение осуществляется головным процессом, а последующие — рабочими процессами. Без функциональности синхронизируемых снимков нет гарантии того, что каждое подключение увидит одни и те же данные, что может привести к несогласованности данных резервной копии.</P
><P
>Если необходимо выполнить выгрузку в несколько потоков на сервере версии до 9.2, необходимо быть уверенным, что база данных не будет изменяться с момента подключения головного процесса и до момента, когда последний рабочий процесс подключится к базе данных. Для этого, проще всего перед запуском <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> остановить все процессы, модифицирующие данные (DML и DDL). Также, при запуске <TT
CLASS="COMMAND"
>pg_dump -j</TT
> на сервере <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> до версии 9.2 нужно указывать параметр <TT
CLASS="OPTION"
>--no-synchronized-snapshots</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-n <TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--schema=<TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
></TT
></DT
><DD
><P
>Выгрузить только схемы, соответствующие шаблону <TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
>. Вместе с самими схемами будут выгружены и объекты схем. Если этот параметр не указан, выгружаются все не системные схемы. Для выгрузки нескольких схем параметр <TT
CLASS="OPTION"
>-n</TT
> можно использовать несколько раз в одной команде. К тому же, значение <TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
> интерпретируется как шаблон, согласно правилам, используемым командами <TT
CLASS="LITERAL"
>\d</TT
> утилиты <SPAN
CLASS="APPLICATION"
>psql</SPAN
> (см. <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><I
>Шаблоны поиска (Patterns)</I
></A
>). Поэтому несколько схем можно выбрать, используя в шаблоне символы подстановки. При использовании символов подстановки, шаблон лучше экранировать кавычками, чтобы командная оболочка ОС не интерпретировала их по-своему. (см. <A
HREF="app-pgdump.html#PG-DUMP-EXAMPLES"
><I
>Примеры</I
></A
>).</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>При использовании <TT
CLASS="OPTION"
>-n</TT
>, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> не выгружает объекты других схем, от которых выгружаемая схема может зависеть. Таким образом не гарантируется, что выгруженная схема будет успешно восстановлена на чистой базе данных.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Не принадлежащие схемам объекты (например, большие бинарные объекты), не выгружаются с параметром <TT
CLASS="OPTION"
>-n</TT
>. Однако можно указать <TT
CLASS="OPTION"
>--blobs</TT
>, чтобы они попали в выгрузку.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="OPTION"
>-N <TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--exclude-schema=<TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
></TT
></DT
><DD
><P
>Не выгружать схемы, соответствующие шаблону <TT
CLASS="REPLACEABLE"
><I
>схема</I
></TT
>. Шаблон интерпретируется по тем же правилам, что и для параметра <TT
CLASS="OPTION"
>-n</TT
>. Параметр <TT
CLASS="OPTION"
>-N</TT
> можно использовать в команде несколько раз для исключения схем, соответствующих нескольким шаблонам.</P
><P
>При одновременном использовании параметров <TT
CLASS="OPTION"
>-n</TT
> и <TT
CLASS="OPTION"
>-N</TT
> будут выгружаться схемы, соответствующие шаблону параметра <TT
CLASS="OPTION"
>-n</TT
> и не противоречащие шаблону параметра <TT
CLASS="OPTION"
>-N</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-o</TT
><BR><TT
CLASS="OPTION"
>--oids</TT
></DT
><DD
><P
>Выгружать идентификаторы объектов (<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>s) вместе с данными таблиц. Используйте этот параметр, если в приложении есть ссылки на <ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>, например во внешних ключах. В противном случае, этот параметр лучше не использовать.</P
></DD
><DT
><TT
CLASS="OPTION"
>-O</TT
><BR><TT
CLASS="OPTION"
>--no-owner</TT
></DT
><DD
><P
>Не формировать команды, устанавливающие владельца объектов базы данных. По умолчанию <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> генерирует команды <TT
CLASS="COMMAND"
>ALTER OWNER</TT
> или <TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
> для назначения владельцев объектов базы. Эти команды завершатся неудачно, если скрипт будет запущен не суперпользователем или не владельцем объектов. Чтобы создать скрипт, который можно выполнить при восстановлении от лица произвольного пользователя и назначить его в качестве владельца объектов восстанавливаемой базы, необходимо указать флаг <TT
CLASS="OPTION"
>-O</TT
>.</P
><P
>Параметр полезен только для вывода файлов в формате <TT
CLASS="LITERAL"
>plain</TT
>. Для архивных форматов, этот параметр можно указывать при вызове <TT
CLASS="COMMAND"
>pg_restore</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-R</TT
><BR><TT
CLASS="OPTION"
>--no-reconnect</TT
></DT
><DD
><P
>Параметр является устаревшим, но в целях совместимости ещё работает.</P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
><BR><TT
CLASS="OPTION"
>--schema-only</TT
></DT
><DD
><P
>Выгружать только определения объектов (схемы), без данных.</P
><P
>Действие параметра противоположно действию <TT
CLASS="OPTION"
>--data-only</TT
>. Это похоже на указание <TT
CLASS="OPTION"
>--section=pre-data --section=post-data</TT
>, но по историческим причинам не равнозначно ему.</P
><P
>(Не путайте этот параметр с <TT
CLASS="OPTION"
>--schema</TT
>, где слово <SPAN
CLASS="QUOTE"
>"схема"</SPAN
> используется в другом значении.)</P
><P
>Чтобы не выгружать данные отдельных таблиц, используйте параметр <TT
CLASS="OPTION"
>--exclude-table-data</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-S <TT
CLASS="REPLACEABLE"
><I
>имя_пользователя</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--superuser=<TT
CLASS="REPLACEABLE"
><I
>имя_пользователя</I
></TT
></TT
></DT
><DD
><P
>Указать суперпользователя, который будет использоваться для отключения триггеров. Параметр имеет значение только вместе с <TT
CLASS="OPTION"
>--disable-triggers</TT
>. Обычно его лучше не использовать, а запускать полученный скрипт от имени суперпользователя.</P
></DD
><DT
><TT
CLASS="OPTION"
>-t <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--table=<TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
></TT
></DT
><DD
><P
>Выгрузить только таблицы, соответствующие шаблону <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
>. Для выгрузки нескольких таблиц параметр <TT
CLASS="OPTION"
>-t</TT
> можно использовать несколько раз в одной команде. К тому же, значение <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
> интерпретируется как шаблон, согласно правилам, используемым командами <TT
CLASS="LITERAL"
>\d</TT
> утилиты <SPAN
CLASS="APPLICATION"
>psql</SPAN
> (см. <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><I
>Шаблоны поиска (Patterns)</I
></A
>). Поэтому несколько таблиц можно выбрать используя в шаблоне символы подстановки. При использовании символов подстановки, шаблон лучше экранировать кавычками, чтобы командная оболочка ОС не интерпретировала их по-своему. (см. <A
HREF="app-pgdump.html#PG-DUMP-EXAMPLES"
><I
>Примеры</I
></A
>).</P
><P
>Параметры <TT
CLASS="OPTION"
>-n</TT
> и <TT
CLASS="OPTION"
>-N</TT
> не оказывают влияния на параметр <TT
CLASS="OPTION"
>-t</TT
>, так как отобранные с его помощью таблицы всё равно будут выгружены.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>При использовании <TT
CLASS="OPTION"
>-t</TT
>, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> не выгружает прочие объекты, от которых выгружаемые таблицы могут зависеть. Таким образом не гарантируется, что выгруженные таблицы будут успешно восстановлены на чистой базе данных.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Поведение параметра <TT
CLASS="OPTION"
>-t</TT
> для версий ниже чем <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.2 отличается от более поздних. Прежде, указание <TT
CLASS="LITERAL"
>-t таблица</TT
> включало все таблицы, соответствующие шаблону <TT
CLASS="LITERAL"
>таблица</TT
>, а сейчас это приведёт к выгрузке только тех таблиц, которые будут обнаружены в текущем пути поиска. Для получения старого поведения можно использовать конструкцию вида <TT
CLASS="LITERAL"
>-t '*.таблица'</TT
>. Также, чтобы указать таблицу из конкретной схемы, сейчас лучше использовать <TT
CLASS="LITERAL"
>-t схема.таблица</TT
>, вместо старой конструкции <TT
CLASS="LITERAL"
>-n схема -t таблица</TT
>.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="OPTION"
>-T <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--exclude-table=<TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
></TT
></DT
><DD
><P
>Не выгружать таблицы, соответствующие шаблону <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
>. Шаблон интерпретируется по тем же правилам, что и для параметра <TT
CLASS="OPTION"
>-t</TT
>. Параметр <TT
CLASS="OPTION"
>-T</TT
> можно использовать в команде несколько раз для исключения таблиц, соответствующих нескольким шаблонам.</P
><P
>При одновременном использовании параметров <TT
CLASS="OPTION"
>-t</TT
> и <TT
CLASS="OPTION"
>-T</TT
> будут выгружаться таблицы, соответствующие шаблону параметра <TT
CLASS="OPTION"
>-t</TT
> и не противоречащие шаблону параметра <TT
CLASS="OPTION"
>-T</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-v</TT
><BR><TT
CLASS="OPTION"
>--verbose</TT
></DT
><DD
><P
>Включить подробный режим. <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> будет выводить в стандартный поток ошибок подробные комментарии к объектам, включая время начала и окончания выгрузки, а также сообщения о прогрессе выполнения.</P
></DD
><DT
><TT
CLASS="OPTION"
>-V</TT
><BR><TT
CLASS="OPTION"
>--version</TT
></DT
><DD
><P
>Вывести версию <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-x</TT
><BR><TT
CLASS="OPTION"
>--no-privileges</TT
><BR><TT
CLASS="OPTION"
>--no-acl</TT
></DT
><DD
><P
>Не выгружать права доступа (команды GRANT/REVOKE).</P
></DD
><DT
><TT
CLASS="OPTION"
>-Z <TT
CLASS="REPLACEABLE"
><I
>0..9</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--compress=<TT
CLASS="REPLACEABLE"
><I
>0..9</I
></TT
></TT
></DT
><DD
><P
>Установить уровень сжатия данных. Ноль означает, что сжатие выключено. Для архивного формата <TT
CLASS="LITERAL"
>custom</TT
> будут сжиматься файлы отдельных таблиц. По умолчанию применяется умеренный уровень сжатия. Если указать отличный от нулевого уровень сжатия для формата <TT
CLASS="LITERAL"
>plain</TT
>, то сжиматься будет весь выходной файл, как это было бы при передаче файла команде <SPAN
CLASS="APPLICATION"
>gzip</SPAN
>. Но по умолчанию для <TT
CLASS="LITERAL"
>plain</TT
> сжатие данных отключено. Формат <TT
CLASS="LITERAL"
>tar</TT
> в настоящий момент не поддерживает сжатие.</P
></DD
><DT
><TT
CLASS="OPTION"
>--binary-upgrade</TT
></DT
><DD
><P
>Этот параметр предназначен для утилит обновления сервера. Использование для иных целей не рекомендуется и не поддерживается. Поведение параметра может быть изменено в последующих версиях без предварительного уведомления.</P
></DD
><DT
><TT
CLASS="OPTION"
>--column-inserts</TT
><BR><TT
CLASS="OPTION"
>--attribute-inserts</TT
></DT
><DD
><P
>Выгружать данные таблиц в виде команд <TT
CLASS="COMMAND"
>INSERT</TT
> с явным указанием столбцов (<TT
CLASS="LITERAL"
>INSERT INTO <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>column</I
></TT
>, ...) VALUES ...</TT
>). В этом случае, скорость восстановления значительно снизится. Полезно в тех случаях, когда загружать данные нужно не в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Также, поскольку для каждой строки генерируется отдельная команда, сбой при последующей загрузке приведёт к потере конкретной строки, а не всей таблицы.</P
></DD
><DT
><TT
CLASS="OPTION"
>--disable-dollar-quoting</TT
></DT
><DD
><P
>Выключает экранирование тел функций с помощью знака доллара и принуждает к экранированию посредством стандартного синтаксиса SQL.</P
></DD
><DT
><TT
CLASS="OPTION"
>--disable-triggers</TT
></DT
><DD
><P
>Используется при выгрузке одних данных (с параметром <TT
CLASS="OPTION"
>--data-only</TT
>). Заставляет <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> включать в вывод команды для временного выключения триггеров при восстановлении в целевой базе данных. Применяется в ситуациях, когда существуют проверки ссылочной целостности или другие триггеры, которые необходимо выключить на время восстановления.</P
><P
>В настоящее время команды, генерируемые с параметром <TT
CLASS="OPTION"
>--disable-triggers</TT
>, должны исполняться от имени суперпользователя. Таким образом, необходимо также передавать флаг <TT
CLASS="OPTION"
>-S</TT
>, либо при восстановлении выполнять скрипт от имени суперпользователя.</P
><P
>Параметр полезен только для вывода файлов в формате <TT
CLASS="LITERAL"
>plain</TT
>. Для архивных форматов, этот параметр можно указывать при вызове <TT
CLASS="COMMAND"
>pg_restore</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>--exclude-table-data=<TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
></TT
></DT
><DD
><P
>Не выгружать содержимое таблиц, соответствующих шаблону <TT
CLASS="REPLACEABLE"
><I
>таблица</I
></TT
>. Шаблон таблицы интерпретируется по тем же правилам, что и для параметра <TT
CLASS="OPTION"
>-t</TT
>. Параметр <TT
CLASS="OPTION"
>--exclude-table-data</TT
> можно использовать в команде несколько раз для исключения таблиц, соответствующих нескольким шаблонам. Полезно, когда нужно получить определение таблицы, без содержимого.</P
><P
>Чтобы не выгружать содержимое всех таблиц базы, используйте параметр <TT
CLASS="OPTION"
>--schema-only</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>--if-exists</TT
></DT
><DD
><P
>При очистке целевой базы использовать условные команды (добавлять предложение <TT
CLASS="LITERAL"
>IF EXISTS</TT
>). Применяется только с параметром <TT
CLASS="OPTION"
>--clean</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>--inserts</TT
></DT
><DD
><P
>Выгружать данные таблиц в виде команд <TT
CLASS="COMMAND"
>INSERT</TT
> вместо <TT
CLASS="COMMAND"
>COPY</TT
>. В этом случае, скорость восстановления значительно снизится. Полезно в тех случаях, когда загружать данные нужно не в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Также, поскольку для каждой строки генерируется отдельная команда, сбой при последующей загрузке приведёт к потере конкретной строки, а не всей таблицы. Обратите внимание, что последующая загрузка может завершиться неудачно, если у таблицы изменён порядок столбцов. Можно использовать параметр <TT
CLASS="OPTION"
>--column-inserts</TT
>, для которого порядок столбцов не важен, но он работает ещё медленнее.</P
></DD
><DT
><TT
CLASS="OPTION"
>--lock-wait-timeout=<TT
CLASS="REPLACEABLE"
><I
>время_ожидания</I
></TT
></TT
></DT
><DD
><P
>Не ждать бесконечно получения разделяемых блокировок таблиц в начале процедуры выгрузки. Вместо этого, выдать ошибку, если не удастся заблокировать таблицы за указанное <TT
CLASS="REPLACEABLE"
><I
>время_ожидания</I
></TT
>. Это время можно задать в любом из форматов, принимаемых командой <TT
CLASS="COMMAND"
>SET statement_timeout</TT
>. (Допустимые значения зависят от версии сервера, выгружающего данные, но количество миллисекунд в виде целого числа принимают все версии, начиная с 7.3. Более ранние версии игнорируют этот параметр.)</P
></DD
><DT
><TT
CLASS="OPTION"
>--no-security-labels</TT
></DT
><DD
><P
>Не выгружать метки безопасности.</P
></DD
><DT
><TT
CLASS="OPTION"
>--no-synchronized-snapshots</TT
></DT
><DD
><P
>Позволяет запускать <TT
CLASS="COMMAND"
>pg_dump -j</TT
> на серверах с версией ниже чем 9.2. Подробнее в описании параметра <TT
CLASS="OPTION"
>-j</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>--no-tablespaces</TT
></DT
><DD
><P
>Не формировать команды для указания табличных пространств. Все объекты будут создаваться в табличном пространстве по умолчанию.</P
><P
>Параметр полезен только для вывода файлов в формате <TT
CLASS="LITERAL"
>plain</TT
>. Для архивных форматов, этот параметр можно указывать при вызове <TT
CLASS="COMMAND"
>pg_restore</TT
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>--no-unlogged-table-data</TT
></DT
><DD
><P
>Не выгружать данные нежурналируемых таблиц. Параметр не влияет на выгрузку определения таблиц, он только подавляет вывод содержимого таблиц. При запуске на резервном сервере, содержимое нежурналируемых таблиц никогда не выгружается.</P
></DD
><DT
><TT
CLASS="OPTION"
>--quote-all-identifiers</TT
></DT
><DD
><P
>Принудительно экранировать все идентификаторы. Может быть полезно при миграции на новую версию сервера, для избежания конфликтов с новыми резервными словами.</P
></DD
><DT
><TT
CLASS="OPTION"
>--section=<TT
CLASS="REPLACEABLE"
><I
>имя секции</I
></TT
></TT
></DT
><DD
><P
>Выгружать лишь указанную секцию. Имя секции может принимать значения <TT
CLASS="OPTION"
>pre-data</TT
>, <TT
CLASS="OPTION"
>data</TT
> или <TT
CLASS="OPTION"
>post-data</TT
>. Для выгрузки нескольких секций, параметр можно использовать несколько раз в одной команде. По умолчанию резервируются все секции.</P
><P
>Секция <TT
CLASS="OPTION"
>data</TT
> содержит непосредственно данные таблиц, больших объектов и значения последовательностей. Секция <TT
CLASS="OPTION"
>post-data</TT
> содержит определения индексов, триггеров, правил и ограничений (кроме ограничений проверки, созданных без <TT
CLASS="OPTION"
>NOT VALID</TT
> ). Секция <TT
CLASS="OPTION"
>pre-data</TT
> включает определения остальных элементов.</P
></DD
><DT
><TT
CLASS="OPTION"
>--serializable-deferrable</TT
></DT
><DD
><P
>Использовать при выгрузке транзакцию с уровнем изоляции <TT
CLASS="LITERAL"
>serializable</TT
> для получения снимка, согласованного с последующими состояниями базы. Правда для этого нужно выждать момент, когда в потоке транзакций нет аномалий, и поэтому нет риска, что выгрузка завершится неудачно, и риска отката других транзакций с ошибкой <TT
CLASS="LITERAL"
>serialization_failure</TT
>. Более подробно изоляция транзакций и управление одновременным доступом описывается в <A
HREF="mvcc.html"
>Главе 13</A
>.</P
><P
>Параметр не особо полезен в случаях, когда требуется восстановление после сбоя. Он полезен для создания копии базы данных, в которой формируются отчёты и выполняются другие операции чтения, в то время как в основной базе продолжается обычная работа. Без этого параметра выгрузка может содержать не целостное состояние базы данных. Например, если используется пакетная обработка, статус пакета может отражаться как завершённый, в то время как в выгрузке будут не все элементы пакета.</P
><P
>Параметр не будет влиять на результат, если во время запуска <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> нет активных транзакций на чтение-запись. Если же активные транзакции чтения-записи есть, то начало выгрузки может быть отложено на неопределённый период времени. После того как выгрузка началась, производительность с этим ключом или без него будет одинаковой.</P
></DD
><DT
><TT
CLASS="OPTION"
>--use-set-session-authorization</TT
></DT
><DD
><P
>Выводить команды <TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
>, соответствующие стандарту, вместо <TT
CLASS="COMMAND"
>ALTER OWNER</TT
>, для назначения владельцев объектов. В результате выгруженный скрипт будет более стандартизированным, но может не восстановиться корректно, в зависимости от истории объектов. Кроме того, для использования <TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
> при восстановлении нужны права суперпользователя, в то время как <TT
CLASS="COMMAND"
>ALTER OWNER</TT
> требует меньших привилегий.</P
></DD
><DT
><TT
CLASS="OPTION"
>-?</TT
><BR><TT
CLASS="OPTION"
>--help</TT
></DT
><DD
><P
>Показать справку по аргументам командной строки <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> и завершиться.</P
></DD
></DL
></DIV
><P></P
><P
>Далее описаны параметры управления подключением. <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-d <TT
CLASS="REPLACEABLE"
><I
>база_данных</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--dbname=<TT
CLASS="REPLACEABLE"
><I
>база_данных</I
></TT
></TT
></DT
><DD
><P
>Указывает имя базы данных для подключения. Эквивалентно указанию <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> в качестве первого аргумента, не являющегося параметром в командной строке.</P
><P
>Если параметр содержит символ <TT
CLASS="SYMBOL"
>=</TT
>, или начинается с допустимого префикса <ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>, например, <TT
CLASS="LITERAL"
>postgresql://</TT
> или <TT
CLASS="LITERAL"
>postgres://</TT
>, то он трактуется аналогично строке подключения <TT
CLASS="PARAMETER"
>conninfo</TT
>. За дополнительными сведениями обратитесь к <A
HREF="libpq-connect.html"
>Разделу 31.1</A
>.</P
></DD
><DT
><TT
CLASS="OPTION"
>-h <TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--host=<TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
></TT
></DT
><DD
><P
>Указывает имя компьютера, на котором запущен сервер. Если значение начинается с косой черты, оно интерпретируется как имя каталога с доменным сокетом Unix. Значение по умолчанию берётся из переменной окружения <TT
CLASS="ENVAR"
>PGHOST</TT
>, если она установлена. В противном случае выполняется подключение к доменному сокету.</P
></DD
><DT
><TT
CLASS="OPTION"
>-p <TT
CLASS="REPLACEABLE"
><I
>порт</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--port=<TT
CLASS="REPLACEABLE"
><I
>порт</I
></TT
></TT
></DT
><DD
><P
>Указывает TCP-порт или расширение локального файла Unix-сокета, на котором сервер слушает подключения. По умолчанию берётся значение переменной окружения <TT
CLASS="ENVAR"
>PGPORT</TT
>, если оно установлено, либо значение времени компиляции.</P
></DD
><DT
><TT
CLASS="OPTION"
>-U <TT
CLASS="REPLACEABLE"
><I
>имя_пользователя</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--username=<TT
CLASS="REPLACEABLE"
><I
>имя_пользователя</I
></TT
></TT
></DT
><DD
><P
>Имя пользователя, под которым производится подключение.</P
></DD
><DT
><TT
CLASS="OPTION"
>-w</TT
><BR><TT
CLASS="OPTION"
>--no-password</TT
></DT
><DD
><P
>Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль не доступен с помощью других средств, таких как файл <TT
CLASS="FILENAME"
>.pgpass</TT
>, попытка соединения не удастся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя, который вводит пароль.</P
></DD
><DT
><TT
CLASS="OPTION"
>-W</TT
><BR><TT
CLASS="OPTION"
>--password</TT
></DT
><DD
><P
>Принудительно запрашивать пароль перед подключением к базе данных.</P
><P
>Это несущественный параметр, так как <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> запрашивает пароль автоматически, если сервер проверяет подлинность по паролю. Однако, чтобы понять это, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> лишний раз подключается к серверу. Поэтому иногда имеет смысл ввести <TT
CLASS="OPTION"
>-W</TT
>, чтобы исключить эту ненужную попытку подключения.</P
></DD
><DT
><TT
CLASS="OPTION"
>--role=<TT
CLASS="REPLACEABLE"
><I
>имя роли</I
></TT
></TT
></DT
><DD
><P
>Задаёт имя роли, которая будет осуществлять выгрузку. Получив это имя, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> выполнит <TT
CLASS="COMMAND"
>SET ROLE</TT
> <TT
CLASS="REPLACEABLE"
><I
>имя_роли</I
></TT
> после подключения к базе данных. Это полезно, когда проходящий проверку пользователь (указанный в <TT
CLASS="OPTION"
>-U</TT
>) не имеет прав, необходимых для <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, но может переключиться на роль, наделённую этими правами. В некоторых окружениях правила запрещают подключаться к серверу непосредственно суперпользователю, и этот параметр позволяет выполнить выгрузку, не нарушая их.</P
></DD
></DL
></DIV
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88468"
></A
><H2
>Переменные окружения</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="ENVAR"
>PGDATABASE</TT
><BR><TT
CLASS="ENVAR"
>PGHOST</TT
><BR><TT
CLASS="ENVAR"
>PGOPTIONS</TT
><BR><TT
CLASS="ENVAR"
>PGPORT</TT
><BR><TT
CLASS="ENVAR"
>PGUSER</TT
></DT
><DD
><P
>Параметры подключения по умолчанию.</P
></DD
></DL
></DIV
><P
>Эта утилита, как и большинство других утилит <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, также использует переменные среды, поддерживаемые <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> (см. <A
HREF="libpq-envars.html"
>Раздел 31.14</A
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="APP-PGDUMP-DIAGNOSTICS"
></A
><H2
>Диагностика</H2
><P
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> на низком уровне выполняет команды <TT
CLASS="COMMAND"
>SELECT</TT
>. Если есть проблемы с работой <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, убедитесь, что в базе данных можно выполнить <TT
CLASS="COMMAND"
>SELECT</TT
>, например из <A
HREF="app-psql.html"
>            <SPAN
CLASS="APPLICATION"
>psql</SPAN
>
          </A
>. Также следует учитывать, что при этом применяются все свойства подключения по умолчанию и переменные окружения, которые использует клиентская библиотека <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>.</P
><P
>Обычно действия <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> в базе данных собираются коллектором статистики. Если это нежелательно, то можно установить параметр <TT
CLASS="VARNAME"
>track_counts</TT
> в false в переменной окружения <TT
CLASS="ENVAR"
>PGOPTIONS</TT
> или в команде <TT
CLASS="LITERAL"
>ALTER USER</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="PG-DUMP-NOTES"
></A
><H2
>Замечания</H2
><P
>Если в базу данных кластера <TT
CLASS="LITERAL"
>template1</TT
> устанавливались дополнительные объекты, то следует убедиться, что выгрузка <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> загружается в пустую базу данных. Иначе существует вероятность возникновения ошибок дублирования создаваемых объектов. Чтобы создать пустую базу данных, копируйте её из шаблона <TT
CLASS="LITERAL"
>template0</TT
>, вместо <TT
CLASS="LITERAL"
>template1</TT
>, например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE DATABASE foo WITH TEMPLATE template0;</PRE
><P></P
><P
>Если выгружаются только данные с одновременным использованием <TT
CLASS="OPTION"
>--disable-triggers</TT
>, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> сформирует команды для выключения табличных триггеров перед вставкой данных, а после них — команды, включающие триггеры обратно. Если восстановление будет прервано в середине процесса, системный каталог может остаться в неверном состоянии.</P
><P
>Отдельные файлы tar архива ограничены размером в 8 ГБ. (Это ограничение формата tar.) Таким образом этот формат вывода не может применяться для таблиц, данные которых в текстовом представлении превышают этот размер. Общий размер tar архива и любого другого формата не ограничен, если нет ограничений в операционной системе.</P
><P
>Сформированный <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> файл не содержит данных статистики, используемых планировщиком. Поэтому после восстановления следует выполнить <TT
CLASS="COMMAND"
>ANALYZE</TT
> для достижения оптимальной производительности; за дополнительной информацией обратитесь к <A
HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS"
>Подразделу 23.1.3</A
> и <A
HREF="routine-vacuuming.html#AUTOVACUUM"
>Подразделу 23.1.6</A
>. Также не выгружаются команды <TT
CLASS="COMMAND"
>ALTER DATABASE ... SET</TT
>. Эти свойства, вместе с данными о ролях и прочими глобальными объектами, выгружаются с помощью <A
HREF="app-pg-dumpall.html"
>            <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>
          </A
>.</P
><P
>Так как <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> применяется для переноса данных в новые версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, то предполагается, что вывод <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> можно загрузить на сервер <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, более новой версии, чем версия <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> может выгружать данные серверов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> более старых версий, чем его собственная, но не ниже 7.0. При этом <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> не может выгружать данные с серверов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> более новых мажорных версий. Подобные попытки будут отклонены со стороны сервера, для исключения рисков формирования некорректной выгрузки. Также нет гарантии того, что восстановление на сервере с более старой мажорной версией, чем у сформировавшего выгрузку <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, пройдёт гладко &mdash; даже, если выгрузка была сделана с сервера идентичной версии. Восстановление в этом случае может потребовать ручного редактирования файла выгрузки, для устранения синтаксиса, не поддерживаемого старой версией сервера.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="PG-DUMP-EXAMPLES"
></A
><H2
>Примеры</H2
><P
>Чтобы выгрузить базу данных <TT
CLASS="LITERAL"
>mydb</TT
> в файл SQL-скрипта: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>Для восстановления из выше полученного скрипта в чистую базу <TT
CLASS="LITERAL"
>newdb</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -d newdb -f db.sql</KBD
></PRE
><P></P
><P
>Чтобы сформировать выгрузку в формате <TT
CLASS="LITERAL"
>custom</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fc mydb &gt; db.dump</KBD
></PRE
><P></P
><P
>Чтобы сформировать выгрузку в формате <TT
CLASS="LITERAL"
>directory</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fd mydb -f dumpdir</KBD
></PRE
><P></P
><P
>Чтобы сформировать выгрузку в формате <TT
CLASS="LITERAL"
>directory</TT
> в 5 параллельных потоков: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fd mydb -j 5 -f dumpdir</KBD
></PRE
><P></P
><P
>Для восстановления в чистую базу данных <TT
CLASS="LITERAL"
>newdb</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -d newdb db.dump</KBD
></PRE
><P></P
><P
>Чтобы выгрузить отдельную таблицу <TT
CLASS="LITERAL"
>mytab</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t mytab mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>Чтобы выгрузить все таблицы, имена которых начинаются на <TT
CLASS="LITERAL"
>emp</TT
> и принадлежат схеме <TT
CLASS="LITERAL"
>detroit</TT
>, исключая таблицу <TT
CLASS="LITERAL"
>employee_log</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t 'detroit.emp*' -T detroit.employee_log mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>Чтобы выгрузить все схемы, имена которых начинаются на <TT
CLASS="LITERAL"
>east</TT
> или <TT
CLASS="LITERAL"
>west</TT
> и заканчиваются на <TT
CLASS="LITERAL"
>gsm</TT
>, исключая те, имена которых содержат <TT
CLASS="LITERAL"
>test</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -n 'east*gsm' -n 'west*gsm' -N '*test*' mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>То же самое, но с использованием регулярного выражения: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -n '(east|west)*gsm' -N '*test*' mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>Чтобы выгрузить все объекты базы данных, исключая таблицы, чьи имена начинаются с <TT
CLASS="LITERAL"
>ts_</TT
>: </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -T 'ts_*' mydb &gt; db.sql</KBD
></PRE
><P></P
><P
>Чтобы указать имя в верхнем или смешанном регистре в параметре <TT
CLASS="OPTION"
>-t</TT
> и ему подобных, его необходимо экранировать двойными кавычками, иначе оно автоматически приводится к нижнему регистру (см. <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><I
>Шаблоны поиска (Patterns)</I
></A
>). Однако стоит помнить, что двойные кавычки являются спецсимволом для командной оболочки, потому их также необходимо экранировать. Так, чтобы выгрузить таблицу с именем в смешанном регистре, нужно что-то подобное </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t "\"MixedCaseName\"" mydb &gt; mytab.sql</KBD
></PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88599"
></A
><H2
>См. также</H2
><A
HREF="app-pg-dumpall.html"
>            <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>
          </A
>, <A
HREF="app-pgrestore.html"
>pg_restore</A
>, <A
HREF="app-psql.html"
>            <SPAN
CLASS="APPLICATION"
>psql</SPAN
>
          </A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="app-pgconfig.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="app-pg-dumpall.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>pg_config</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>