<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Функции</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Преобразование типов"
HREF="typeconv.html"><LINK
REL="PREVIOUS"
TITLE="Операторы"
HREF="typeconv-oper.html"><LINK
REL="NEXT"
TITLE="Хранимое значение"
HREF="typeconv-query.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Операторы"
HREF="typeconv-oper.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 10. Преобразование типов</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Хранимое значение"
HREF="typeconv-query.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPECONV-FUNC"
>10.3. Функции</A
></H1
><P
>При выборе конкретной функции, задействованной в выражении, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> следует описанному ниже алгоритму.</P
><DIV
CLASS="PROCEDURE"
><P
><B
>Разрешение функции по типу</B
></P
><OL
TYPE="1"
><LI
CLASS="STEP"
><P
>Выбрать функции для рассмотрения из системного каталога <CODE
CLASS="CLASSNAME"
>pg_proc</CODE
>. Если имя функции не дополнено именем схемы, будут рассматриваться все функции с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <A
HREF="ddl-schemas.html#DDL-SCHEMAS-PATH"
>Подраздел 5.7.3</A
>). Если имя функции определено полностью, в рассмотрение принимаются только функции из указанной схемы.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
CLASS="STEP"
><P
>Если в пути поиска оказывается несколько функций с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Функции с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</P
></LI
><LI
CLASS="STEP"
><P
>Если в числе параметров функции есть массив <TT
CLASS="LITERAL"
>VARIADIC</TT
> и при вызове не указывается ключевое слово <TT
CLASS="LITERAL"
>VARIADIC</TT
>, функция обрабатывается, как если бы этот параметр был заменён одним или несколькими параметрами типа элементов массива, по числу аргументов при вызове. После такого расширения по фактическим типам аргументов она может совпасть с некоторой функцией с постоянным числом аргументов. В этом случае используется функция, которая находится в пути раньше, а если они оказываются в одной схеме, предпочитается вариант с постоянными аргументами.</P
></LI
><LI
CLASS="STEP"
><P
>Функции, для которых определены значения параметров по умолчанию, считаются совпадающими с вызовом, в котором опущено ноль или более параметров в соответствующих позициях. Если для вызова подходят несколько функций, используется та, что обнаруживается в пути поиска раньше. Если в одной схеме оказываются несколько функций с одинаковыми типами в позициях обязательных параметров (что возможно, если в них определены разные наборы пропускаемых параметров), система не сможет выбрать оптимальную, и выдаст ошибку <SPAN
CLASS="QUOTE"
>"неоднозначный вызов функции"</SPAN
>, если лучшее соответствие для вызова не будет найдено.</P
></LI
></OL
></LI
><LI
CLASS="STEP"
><P
>Проверить, нет ли среди них функций с точно совпадающими типами аргументов. Если такая функция есть (она может быть только одной в отобранном ранее наборе), использовать её. (В случаях с типами <TT
CLASS="TYPE"
>unknown</TT
> функция не будет выбрана на этом шаге.)</P
></LI
><LI
CLASS="STEP"
><P
>Если точное совпадение не найдено, проверить, не похож ли вызов функции на особую форму преобразования типов. Это имеет место, когда при вызове функции передаётся всего один аргумент и имя функции совпадает с именем (внутренним) некоторого типа данных. Более того, аргументом функции должна быть либо строка неопределённого типа, либо значение типа, двоично-совместимого с указанным или приводимого к нему с помощью функций ввода/вывода типа (то есть, преобразований в стандартный строковый тип и обратно). Если эти условия выполняются, вызов функции воспринимается как особая форма конструкции <TT
CLASS="LITERAL"
>CAST</TT
>. <A
NAME="AEN22879"
HREF="#FTN.AEN22879"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></P
></LI
><LI
CLASS="STEP"
><P
>Найти самый подходящий.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
CLASS="STEP"
><P
>Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <TT
CLASS="TYPE"
>unknown</TT
> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданной функции домены будут подобны свои базовым типам.</P
></LI
><LI
CLASS="STEP"
><P
>Просмотреть все кандидаты и оставить только те, для которых точно совпадают как можно больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Если какие-либо значения имеют тип <TT
CLASS="TYPE"
>unknown</TT
>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <TT
CLASS="TYPE"
>string</TT
>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу &mdash; сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Если в списке аргументов есть аргументы и типа <TT
CLASS="TYPE"
>unknown</TT
>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <TT
CLASS="TYPE"
>unknown</TT
> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <TT
CLASS="TYPE"
>unknown</TT
>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</P
></LI
></OL
></LI
></OL
></DIV
><P
>Заметьте, что для функций действуют те же правила <SPAN
CLASS="QUOTE"
>"оптимального соответствия"</SPAN
>, что и для операторов. Они проиллюстрированы следующими примерами.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22905"
></A
><P
><B
>Пример 10-6. Разрешение функции округления по типам аргументов</B
></P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть только одна функция <CODE
CLASS="FUNCTION"
>round</CODE
>, принимающая два аргумента: первый типа <TT
CLASS="TYPE"
>numeric</TT
>, а второй &mdash; <TT
CLASS="TYPE"
>integer</TT
>. Поэтому в следующем запросе первый аргумент <TT
CLASS="TYPE"
>integer</TT
> автоматически приводится к типу <TT
CLASS="TYPE"
>numeric</TT
>: </P><PRE
CLASS="SCREEN"
>SELECT round(4, 4);

 round
--------
 4.0000
(1 row)</PRE
><P> Таким образом, анализатор преобразует этот запрос в: </P><PRE
CLASS="SCREEN"
>SELECT round(CAST (4 AS numeric), 4);</PRE
><P></P
><P
>Та как числовые константы с десятичными точками изначально относятся к типу <TT
CLASS="TYPE"
>numeric</TT
>, для следующего запроса преобразование типов не потребуется, так что он немного эффективнее: </P><PRE
CLASS="SCREEN"
>SELECT round(4.0, 4);</PRE
><P></P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22919"
></A
><P
><B
>Пример 10-7. Разрешение функции извлечения подстроки</B
></P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть несколько вариантов функции <CODE
CLASS="FUNCTION"
>substr</CODE
>, и один из них принимает аргументы типов <TT
CLASS="TYPE"
>text</TT
> и <TT
CLASS="TYPE"
>integer</TT
>. Если эта функция вызывается со строковой константой неопределённого типа, система выбирает функцию, принимающую аргумент предпочитаемой категории <TT
CLASS="LITERAL"
>string</TT
> (а конкретнее, типа <TT
CLASS="TYPE"
>text</TT
>). </P><PRE
CLASS="SCREEN"
>SELECT substr('1234', 3);

 substr
--------
     34
(1 row)</PRE
><P></P
><P
>Если текстовая строка имеет тип <TT
CLASS="TYPE"
>varchar</TT
>, например когда данные поступают из таблицы, анализатор попытается привести её к типу <TT
CLASS="TYPE"
>text</TT
>: </P><PRE
CLASS="SCREEN"
>SELECT substr (varchar '1234', 3);

 substr
--------
     34
(1 row)</PRE
><P> Этот запрос анализатор фактически преобразует в: </P><PRE
CLASS="SCREEN"
>SELECT substr(CAST (varchar '1234' AS text), 3);</PRE
><P></P
><P
>            </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Анализатор узнаёт из каталога <TT
CLASS="STRUCTNAME"
>pg_cast</TT
>, что типы <TT
CLASS="TYPE"
>text</TT
> и <TT
CLASS="TYPE"
>varchar</TT
> двоично-совместимы, что означает, что один тип можно передать функции, принимающей другой, не выполняя физического преобразования. Таким образом, в данном случае операция преобразования на самом не добавляется.</P
></BLOCKQUOTE
></DIV
><P>
          </P
><P
>И если функция вызывается с аргументом типа <TT
CLASS="TYPE"
>integer</TT
>, анализатор попытается преобразовать его в тип <TT
CLASS="TYPE"
>text</TT
>: </P><PRE
CLASS="SCREEN"
>SELECT substr(1234, 3);
ОШИБКА: функция substr(integer, integer) не существует
ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. Возможно, вам
следует добавить явные преобразования типов.</PRE
><P> Этот вариант не работает, так как <TT
CLASS="TYPE"
>integer</TT
> нельзя неявно преобразовать в <TT
CLASS="TYPE"
>text</TT
>. Однако с явным преобразованием запрос выполняется: </P><PRE
CLASS="SCREEN"
>SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)</PRE
><P></P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Примечания</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN22879"
HREF="typeconv-func.html#AEN22879"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда на самом деле соответствующей функции приведения нет. Если такая функция приведения есть, она обычно называется именем выходного типа и необходимости в особом подходе нет. За дополнительными комментариями обратитесь к <A
HREF="sql-createcast.html"
>CREATE CAST</A
>.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv-oper.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="typeconv-query.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Операторы</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Хранимое значение</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>