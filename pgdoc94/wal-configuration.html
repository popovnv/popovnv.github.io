<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Настройка WAL</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Надёжность и журнал упреждающей записи"
HREF="wal.html"><LINK
REL="PREVIOUS"
TITLE="Асинхронное подтверждение транзакций"
HREF="wal-async-commit.html"><LINK
REL="NEXT"
TITLE="Внутреннее устройство WAL"
HREF="wal-internals.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Асинхронное подтверждение транзакций"
HREF="wal-async-commit.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 29. Надёжность и журнал упреждающей записи</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Внутреннее устройство WAL"
HREF="wal-internals.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WAL-CONFIGURATION"
>29.4. Настройка <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
></A
></H1
><P
>Существует несколько конфигурационных параметров относящихся к <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>, которые влияют на производительность СУБД. Далее рассказывается об их использовании. Общую информацию об установке параметров конфигурации сервера смотрите в <A
HREF="runtime-config.html"
>Главе 18</A
>.</P
><P
><I
CLASS="FIRSTTERM"
>Контрольные точки</I
>&mdash; это точки в последовательности транзакций, в которых гарантируется, что файлы с данными и индексами были обновлены всей информацией записанной перед контрольной точкой. Во время контрольной точки, все страницы данных, находящиеся в памяти, сохраняются на диск, а в файл журнала записывается специальная запись контрольной точки. (Сделанные изменения были перед этим записаны в файлы <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>.) В случае краха процедура восстановления ищет последнюю запись контрольной точки, чтобы определить эту точку в журнале (называемую записью REDO), от которой процедура должна начать операцию воспроизведения изменений. Любые изменения файлов данных перед этой точкой гарантированно находятся уже на диске. Таким образом, после контрольной точки, сегменты журнала, которые предшествуют записи воспроизведения, больше не нужны и могут быть удалены или пущены в циклическую перезапись. (Когда архивирование WAL будет завершено, сегменты журнала должны быть архивированы перед их удалением или циклической перезаписи.)</P
><P
>Запись всех страниц данных из памяти на диск, которая требуется для контрольной точки, может вызвать значительную нагрузку на дисковый ввод/вывод. По этой причине, активность записи по контрольной точке регулируется так, что ввод/вывод начинается при старте контрольной точки и завершается перед стартом следующей контрольной точки; это минимизирует потерю производительности во время прохождения контрольных точек.</P
><P
>Специальный фоновый процесс checkpointer автоматически выполняет контрольную точку с заданной частотой. Контрольная точка выполняется через каждые <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-SEGMENTS"
>checkpoint_segments</A
> сегментов журнала или каждые <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-TIMEOUT"
>checkpoint_timeout</A
> секунд, в зависимости от того, какое событие наступит первым. Значения по умолчанию — 3 сегмента и 300 секунд (5 минут). Если с предыдущей контрольной точки ни один файл WAL так и не был записан, то новые контрольные точки будут пропущены, даже если наступил <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>. (Если используется архивирование WAL и вы хотите управлять частотой смены файлов журнала для ограничения потенциальной потери данных, то нужно корректировать параметр <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT"
>archive_timeout</A
>, а не параметры контрольной точки). Также возможен принудительный запуск контрольной точки с помощью SQL-команды <TT
CLASS="COMMAND"
>CHECKPOINT</TT
>.</P
><P
>Снижение количества <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> и/или <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> приводит к более частому созданию контрольных точек. Это позволяет ускорить восстановление после краха (поскольку для воспроизведения нужно меньше данных). Однако, должен соблюдаться баланс между этим и затратами на более частое сохранение страниц данных из памяти на диск. Если <A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
> установлено (как по умолчанию), существует другой фактор, который необходимо учитывать. Для гарантирования целостности страниц данных, при первом изменении любой страницы после каждой контрольной точки, эта страница записывается в журнал целиком. Это приводит к тому, что маленький интервал между контрольными точками увеличивает объём, выводимый в журнал WAL, что частично негативно сказывается на цели использования более маленького интервала и в любом случае, приводит к большему числу дисковых операций ввода/вывода.</P
><P
>Контрольные точки довольно дороги с точки зрения ресурсов, во-первых, потому что они требуют записи всех буферов из памяти на диск, и во-вторых потому что они создают дополнительный трафик WAL, о чём говорилось выше. Таким образом, будет благоразумным установить параметры контрольных точек так, чтобы контрольные точки не выполнялись слишком часто. Для простой проверки параметров контрольной точки можно установить параметр <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-WARNING"
>checkpoint_warning</A
>. Если промежуток времени между контрольными точками будет меньшее чем количество секунд, заданное параметром <TT
CLASS="VARNAME"
>checkpoint_warning</TT
>, то в журнал сервера будет выдано сообщение с рекомендацией увеличить <TT
CLASS="VARNAME"
>checkpoint_segments</TT
>. Периодическое появление такого сообщения не является поводом для беспокойства. Но если оно появляется часто, необходимо увеличить значения параметров управления контрольными точками. Массовые операции, такие как <TT
CLASS="COMMAND"
>COPY</TT
> с большим объёмом данных, могут привести к появлению нескольких таких предупреждений, если вы не установили <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> достаточно большим.</P
><P
>Чтобы избежать "завала" большим количеством системных операций дискового ввода/вывода из-за взрывного количества операций записи страниц, запись заполненных буферов во время контрольной точки "размазывается" на определённый период времени. Этот период управляется параметром <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>, который задаётся как часть интервала контрольной точки. Количество данных ввода/вывода согласуется так, чтобы контрольная точка завершалась, когда данная часть <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> WAL будет израсходована с момента старта контрольной точки или когда заданная часть <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> секунд истечёт, смотря какое событие из вышеуказанных наступит быстрее. С значением 0.5, заданным по умолчанию, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может ожидать завершения каждой контрольной точки примерно половину времени перед стартом следующей контрольной точки. На системах, которые очень близки к максимальному потоку данных ввода/вывода во время обычного функционирования, вы возможно захотите увеличить <TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
>, чтобы снизить загрузку по вводу/выводу, возникающую из-за контрольных точек. Недостаток такого подхода состоит в том, что пролонгированные контрольные точки влияют на время восстановления, потому что при восстановлении нужно будет использовать большее количество сегментов WAL. Хотя значение <TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
> может быть установлено столь высоким как 1.0, лучше оставить его поменьше (по крайней мере, не больше 0.9), так как контрольные точки включают некоторые другие операции, помимо записи заполненных буферов. Установка значения 1.0 вполне вероятно приведёт к тому, что контрольные точки не будут завершаться вовремя, что приведёт к потере производительности из-за неожиданного изменения количества необходимых сегментов WAL.</P
><P
>Всегда будет по крайней мере один файл сегмента WAL и обычно также будет не более чем (2 + <TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
>) * <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + 1 или <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + <A
HREF="runtime-config-replication.html#GUC-WAL-KEEP-SEGMENTS"
>wal_keep_segments</A
> + 1 файлов. Каждый файл сегмента обычно имеет размер в 16 MB (этот размер можно изменить при сборке сервера). Вы можете использовать этот размер для оценки требуемого дискового пространства для хранения <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>. Обычно, когда старые файлы сегментов больше не нужны, они циклически перезаписываются (переименовываются в порядке нумерации, для того, чтобы принять следующие сегменты). Если из-за кратковременного возрастания количества данных при выводе в журнал, образовалось более, чем 3 * <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + 1 файлов сегментов, ненужные файлы сегментов вместо циклической перезаписи будут удаляться до тех пор, пока система не вернётся в обычный режим работы.</P
><P
>В режиме архивного восстановления или горячего резервирования, сервер периодически выполняет <I
CLASS="FIRSTTERM"
>точки перезапуска</I
>, которые похожи на контрольные точки в обычном режиме работы: сервер принудительно сбрасывает своё состояние на диск, обновляет файл <TT
CLASS="FILENAME"
>pg_control</TT
>, чтобы показать, что уже обработанные данные WAL не нужно сканировать снова и затем циклически перезаписывает все старые файлы сегментов в каталоге <TT
CLASS="FILENAME"
>pg_xlog</TT
>. Точки перезапуска не могут выполняться чаще, чем контрольные точки на главном сервере, так как они могут срабатывать только по достижении записи о контрольной точке в WAL. Точка перезапуска срабатывает по достижении записи о контрольной точке, если прошло не меньше <TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> секунд с момента предыдущей точки перезапуска. В режиме горячего резервирования, точка перезапуска также срабатывает, если с момента последней точки перезапуска было применено <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> сегментов журнала.</P
><P
>Есть две наиболее часто используемые внутренние функции <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>: <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
> и <CODE
CLASS="FUNCTION"
>XLogFlush</CODE
>. <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
> используется для помещения новой записи внутрь буферов <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> в разделяемой памяти. Если для новой записи нет места, <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
> запишет (переместит в кеш ядра) несколько полных буферов <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>. Это нежелательно, потому что <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
> используется при каждом изменении базы данных на низком уровне (например, вставке строки) в то время, когда эксклюзивная блокировка удерживается на соответствующие страницы данных, а эта операция должна быть выполнена так быстро, как только возможно. Что ещё хуже, запись буферов <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> может также привести к созданию нового сегмента журнала, что занимает ещё больше времени. Обычно буферы <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> должны быть записаны и сохранены запросом <CODE
CLASS="FUNCTION"
>XLogFlush</CODE
>, который выполняется, по больше части, за время подтверждения транзакции, чтобы иметь уверенность, что записи транзакций сохранены на устройство постоянного хранения. В системах, где вывод журнала генерирует много данных, запросы <CODE
CLASS="FUNCTION"
>XLogFlush</CODE
> могут не происходить достаточно часто, чтобы предотвратить операции записи, выполняемые <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
>. На таких системах, нужно увеличить количество буферов <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>, изменив конфигурационный параметр <A
HREF="runtime-config-wal.html#GUC-WAL-BUFFERS"
>wal_buffers</A
>. По умолчанию, количество буферов <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> равно 8. Увеличение этого значения будет соответственно увеличивать использование разделяемой памяти. Когда задан параметр <A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
> и система очень загружена, увеличение параметра <TT
CLASS="VARNAME"
>wal_buffers</TT
> поможет сгладить время отклика во время периода, следующего непосредственно за каждой контрольной точкой.</P
><P
>Параметр <A
HREF="runtime-config-wal.html#GUC-COMMIT-DELAY"
>commit_delay</A
> определяет, на сколько микросекунд будет засыпать ведущий процесс группы, записывающий в журнал, после получения блокировки в <CODE
CLASS="FUNCTION"
>XLogFlush</CODE
>, пока подчинённые формируют очередь на запись. Во время этой задержки другие серверные процессы смогут добавлять записи в WAL буферы журнала, чтобы все эти записи сохранились на диск в результате одной операции синхронизации, которую выполнит ведущий. Ведущий процесс не засыпает, если отключён режим <A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>, либо число сеансов с активными транзакциями меньше <A
HREF="runtime-config-wal.html#GUC-COMMIT-SIBLINGS"
>commit_siblings</A
>, так как маловероятно, что какой-либо другой сеанс зафиксирует транзакцию в ближайшее время. Заметьте, что на некоторых платформах, разрешение этого таймера сна составляет 10 миллисекунд, так что любое значение параметра <TT
CLASS="VARNAME"
>commit_delay</TT
> от 1 до 10000 микросекунд будет действовать одинаково. Кроме того, в некоторых системах состояние сна может продлиться несколько дольше, чем требует параметр.</P
><P
>Так как цель <TT
CLASS="VARNAME"
>commit_delay</TT
> состоит в том, чтобы позволить стоимости каждой операции синхронизации амортизироваться через параллельную фиксацию транзакций (потенциально за счёт задержки транзакции), необходимо определить количество той стоимости, прежде чем урегулирование сможет быть выбрано разумно. Чем выше стоимость, тем более эффективный будет <TT
CLASS="VARNAME"
>commit_delay</TT
> в увеличении пропускной способности транзакций в какой-то степени. Программа <A
HREF="pgtestfsync.html"
>              <SPAN
CLASS="APPLICATION"
>pg_test_fsync</SPAN
>
            </A
> может использоваться, чтобы измерить среднее время в микросекундах, которое занимает одиночная работа сброса WAL на диск. Значение половины среднего времени сообщаемого программой рекомендуется в качестве отправной точки для использования значения в параметре <TT
CLASS="VARNAME"
>commit_delay</TT
> при оптимизации для конкретного объёма работы, и говорит о том, сколько нужно времени для синхронизации сброса единственной операции записи 8 КБ. Настройка параметра <TT
CLASS="VARNAME"
>commit_delay</TT
> особенно полезна в случае хранения WAL в хранилище с высокоскоростными дисками, такими как твердотельные накопители (SSD) или RAID-массивы с кешем записи и аварийным питанием на батарее; но это определённо должно тестироваться на репрезентативной рабочей нагрузке. Более высокие значения <TT
CLASS="VARNAME"
>commit_siblings</TT
> должны использоваться в таких случаях, тогда как меньшие значения <TT
CLASS="VARNAME"
>commit_siblings</TT
> часто полезны на носителях с большими задержками. Обратите внимание на то, что увеличение значения параметра <TT
CLASS="VARNAME"
>commit_delay</TT
> может увеличить задержку транзакции настолько, что пострадает общая производительность транзакций.</P
><P
>Даже если <TT
CLASS="VARNAME"
>commit_delay</TT
> равен нулю (значение по умолчанию), групповая фиксация все равно может произойти, но группа будет состоять только из тех сеансов, которым понадобилось сбросить записи о фиксации на диск за то время, пока происходил предыдущий сброс. Чем больше сеансов, тем чаще это происходит даже при нулевом <TT
CLASS="VARNAME"
>commit_delay</TT
>, поэтому увеличение этого параметра может и не оказать заметного действия. Установка <TT
CLASS="VARNAME"
>commit_delay</TT
> имеет смысл в двух случаях: (1) когда несколько транзакций одновременно фиксируют изменения, (2) либо когда частота фиксаций ограничена пропускной способностью дисковой подсистемы. Однако при задержке из-за низкой скорости вращения диска, эта настройка может оказаться полезной даже всего при двух сеансах.</P
><P
>Параметр <A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
> определяет, как <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет обращаться к ядру, чтобы принудительно сохранить <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> на диск. Все методы должны быть одинаковыми в плане надёжности, за исключением <TT
CLASS="LITERAL"
>fsync_writethrough</TT
>, который может иногда принудительно сбрасывать кеш диска, даже если другие методы не делают этого. Однако, какой из них самый быстрый, во многом определяется платформой; вы можете протестировать скорость, используя модуль <A
HREF="pgtestfsync.html"
>              <SPAN
CLASS="APPLICATION"
>pg_test_fsync</SPAN
>
            </A
>. Обратите внимание, что данный параметр не имеет значения, если <TT
CLASS="VARNAME"
>fsync</TT
> выключен.</P
><P
>Включение параметра конфигурации <A
HREF="runtime-config-developer.html#GUC-WAL-DEBUG"
>wal_debug</A
> (предоставляется, если <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> был скомпилирован с его поддержкой) будет приводить к тому, что каждый вызов функций <CODE
CLASS="FUNCTION"
>XLogInsert</CODE
> и <CODE
CLASS="FUNCTION"
>XLogFlush</CODE
> будет протоколироваться в журнал сервера. Данный параметр может быть замещён в будущем более правильным механизмом.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="wal-async-commit.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="wal-internals.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Асинхронное подтверждение транзакций</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Внутреннее устройство WAL</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>