<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Лексическая структура</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Синтаксис SQL"
HREF="sql-syntax.html"><LINK
REL="PREVIOUS"
TITLE="Синтаксис SQL"
HREF="sql-syntax.html"><LINK
REL="NEXT"
TITLE="Выражения значения"
HREF="sql-expressions.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Синтаксис SQL"
HREF="sql-syntax.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 4. Синтаксис SQL</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Выражения значения"
HREF="sql-expressions.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SQL-SYNTAX-LEXICAL"
>4.1. Лексическая структура</A
></H1
><P
>SQL-программа состоит из последовательности <I
CLASS="FIRSTTERM"
>команд</I
>. Команда, в свою очередь, представляет собой последовательность <I
CLASS="FIRSTTERM"
>компонентов</I
>, оканчивающуюся точкой с запятой (<SPAN
CLASS="QUOTE"
>";"</SPAN
>). Конец входного потока также считается концом команды. Какие именно компоненты допустимы для конкретной команды, зависит от её синтаксиса.</P
><P
>Компонентом команды может быть <I
CLASS="FIRSTTERM"
>ключевое слово</I
>, <I
CLASS="FIRSTTERM"
>идентификатор</I
>, <I
CLASS="FIRSTTERM"
>идентификатор в кавычках</I
>, <I
CLASS="FIRSTTERM"
>строка</I
> (или константа) или специальный символ. Компоненты обычно разделяются пробельными символами (пробел, табуляция, перевод строки), но это не требуется, если нет неоднозначности (например, когда спецсимвол оказывается рядом с компонентом другого типа).</P
><P
>Например, следующий текст является правильной (синтаксически) SQL-программой: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</PRE
><P> Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну строку или наоборот, разделить команды на несколько строк).</P
><P
>Кроме этого, SQL-программы могут содержать <I
CLASS="FIRSTTERM"
>комментарии</I
>. Они не являются компонентами команд, а по сути равносильны пробельным символам.</P
><P
>Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие &mdash; их операнды или параметры. Первые несколько компонентов обычно содержат имя команды, так что в данном примере мы можем говорить о командах <SPAN
CLASS="QUOTE"
>"SELECT"</SPAN
>, <SPAN
CLASS="QUOTE"
>"UPDATE"</SPAN
> и <SPAN
CLASS="QUOTE"
>"INSERT"</SPAN
>. Но например, команда <TT
CLASS="COMMAND"
>UPDATE</TT
> требует, чтобы также в определённом положении всегда стоял компонент <TT
CLASS="TOKEN"
>SET</TT
>, а <TT
CLASS="COMMAND"
>INSERT</TT
> в приведённом виде требует наличия компонента <TT
CLASS="TOKEN"
>VALUES</TT
>. Точные синтаксические правила для каждой команды описаны в <A
HREF="reference.html"
>Части VI</A
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-IDENTIFIERS"
>4.1.1. Идентификаторы и ключевые слова</A
></H2
><P
>Показанные выше команды содержали компоненты <TT
CLASS="TOKEN"
>SELECT</TT
>, <TT
CLASS="TOKEN"
>UPDATE</TT
> и <TT
CLASS="TOKEN"
>VALUES</TT
>, которые являются примерами <I
CLASS="FIRSTTERM"
>ключевых слов</I
>, то есть слов, имеющих фиксированное значение в языке SQL. Компоненты <TT
CLASS="TOKEN"
>MY_TABLE</TT
> и <TT
CLASS="TOKEN"
>A</TT
> являются примерами <I
CLASS="FIRSTTERM"
>идентификаторов</I
>. Они идентифицируют имена таблиц, колонок или других объектов баз данных, в зависимости от того, где они используются. Поэтому иногда их называют просто <SPAN
CLASS="QUOTE"
>"именами"</SPAN
>. Ключевые слова и идентификаторы имеют одинаковую лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый компонент ключевым словом или идентификатором. Полный список ключевых слов приведён в <A
HREF="sql-keywords-appendix.html"
>Приложении C</A
>.</P
><P
>Идентификаторы и ключевые слова SQL должны начинаться с буквы (<TT
CLASS="LITERAL"
>a</TT
>-<TT
CLASS="LITERAL"
>z</TT
>, хотя допускаются также не латинские буквы и буквы с диакритическими знаками) или подчёркивания (<TT
CLASS="LITERAL"
>_</TT
>). Последующими символами в идентификаторе или ключевом слове могут быть буквы, цифры (<TT
CLASS="LITERAL"
>0</TT
>-<TT
CLASS="LITERAL"
>9</TT
>), знаки доллара (<TT
CLASS="LITERAL"
>$</TT
>) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя использовать в идентификаторах, так что их использование вредит переносимости приложений. В стандарте SQL гарантированно не будет ключевых слов с цифрами и начинающихся или заканчивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных конфликтов с будущими расширениями стандарта.</P
><P
> Система выделяет для идентификатора не более <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>-1 байт, а более длинные имена усекаются. По умолчанию <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
> равно 64, так что максимальная длина идентификатора равна 63 байтам. Если этого недостаточно, этот предел можно увеличить, изменив константу <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
> в файле <TT
CLASS="FILENAME"
>src/include/pg_config_manual.h</TT
>.</P
><P
> Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра. Таким образом: </P><PRE
CLASS="PROGRAMLISTING"
>UPDATE MY_TABLE SET A = 5;</PRE
><P> равносильно записи: </P><PRE
CLASS="PROGRAMLISTING"
>uPDaTE my_TabLE SeT a = 5;</PRE
><P> Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например: </P><PRE
CLASS="PROGRAMLISTING"
>UPDATE my_table SET a = 5;</PRE
><P></P
><P
> Есть и другой тип идентификаторов: <I
CLASS="FIRSTTERM"
>отделённые идентификаторы</I
> или <I
CLASS="FIRSTTERM"
>идентификаторы в кавычках</I
>. Они образуются при заключении обычного набора символов в двойные кавычки (<TT
CLASS="LITERAL"
>"</TT
>). Такие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами. Так <TT
CLASS="LITERAL"
>"select"</TT
> можно использовать для обозначения колонки или таблицы <SPAN
CLASS="QUOTE"
>"select"</SPAN
>, тогда как <TT
CLASS="LITERAL"
>select</TT
> без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте, где ожидается имя таблицы или колонки. Тот же пример можно переписать с идентификаторами в кавычках следующим образом: </P><PRE
CLASS="PROGRAMLISTING"
>UPDATE "my_table" SET "a" = 5;</PRE
><P></P
><P
>Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом 0. (Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать таблицы и колонки с именами, которые иначе были бы невозможны, например, с пробелами или амперсандами. Ограничение длины при этом сохраняется.</P
><P
>Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их кодам. Такой идентификатор начинается с <TT
CLASS="LITERAL"
>U&amp;</TT
> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт двойная кавычка, например <TT
CLASS="LITERAL"
>U&amp;"foo"</TT
>. (Заметьте, что при этом возникает неоднозначность с оператором <TT
CLASS="LITERAL"
>&amp;</TT
>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, идентификатор <TT
CLASS="LITERAL"
>"data"</TT
> можно записать так: </P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"d\0061t\+000061"</PRE
><P> В следующем менее тривиальном примере закодировано русское слово <SPAN
CLASS="QUOTE"
>"слон"</SPAN
>, записанное кириллицей: </P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"\0441\043B\043E\043D"</PRE
><P></P
><P
>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <TT
CLASS="LITERAL"
>UESCAPE</TT
> после строки, например: </P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"d!0061t!+000061" UESCAPE '!'</PRE
><P> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в двойные кавычки, а в апострофы.</P
><P
>Чтобы сделать спецсимволом знак апострофа, напишите его дважды.</P
><P
>Unicode-формат полностью поддерживается только при использовании на сервере кодировки <TT
CLASS="LITERAL"
>UTF8</TT
>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <TT
CLASS="LITERAL"
>\007F</TT
>). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а объединяются в один символ, который затем кодируется в UTF-8.)</P
><P
>Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентификаторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы <TT
CLASS="LITERAL"
>FOO</TT
>, <TT
CLASS="LITERAL"
>foo</TT
> и <TT
CLASS="LITERAL"
>"foo"</TT
> считаются одинаковыми в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, но <TT
CLASS="LITERAL"
>"Foo"</TT
> и <TT
CLASS="LITERAL"
>"FOO"</TT
> отличны друг от друга и от предыдущих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, несовместимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему регистру. То есть, согласно стандарту <TT
CLASS="LITERAL"
>foo</TT
> должно быть эквивалентно <TT
CLASS="LITERAL"
>"FOO"</TT
>, а не <TT
CLASS="LITERAL"
>"foo"</TT
>. Поэтому при создании переносимых приложений рекомендуется либо всегда заключать определённое имя в кавычки, либо не заключать никогда.)</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-CONSTANTS"
>4.1.2. Константы</A
></H2
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть три типа констант <I
CLASS="FIRSTTERM"
>подразумеваемых типов</I
>: строки, битовые строки и числа. Константы можно также записывать, указывая типы явно, что позволяет представить их более точно и обработать более эффективно. Эти варианты рассматриваются в следующих подразделах.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS"
>4.1.2.1. Строковые константы</A
></H3
><P
> Строковая константа в SQL &mdash; это обычная последовательность символов, заключённая в апострофы (<TT
CLASS="LITERAL"
>'</TT
>), например: <TT
CLASS="LITERAL"
>'Это строка'</TT
>. Чтобы включить апостроф в строку, напишите в ней два апострофа рядом, например: <TT
CLASS="LITERAL"
>'Жанна д''Арк'</TT
>. Заметьте, это <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> то же самое, что двойная кавычка (<TT
CLASS="LITERAL"
>"</TT
>).</P
><P
>Две строковые константы, разделённые пробельными символами <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>и минимум одним переводом строки</I
></SPAN
>, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foo'
'bar';</PRE
><P> эквивалентно: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foobar';</PRE
><P> но эта запись: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foo'      'bar';</PRE
><P> считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> просто следует ему.)</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS-ESCAPE"
>4.1.2.2. Строковые константы со спецпоследовательностями в стиле C</A
></H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> также принимает <SPAN
CLASS="QUOTE"
>"спецпоследовательности"</SPAN
>, что является расширением стандарта SQL. Строка со спецпоследовательностями начинается с буквы <TT
CLASS="LITERAL"
>E</TT
> (заглавной или строчной), стоящей непосредственно перед апострофом, например: <TT
CLASS="LITERAL"
>E'foo'</TT
>. (Когда константа со спецпоследовательностью разбивается на несколько строк, букву <TT
CLASS="LITERAL"
>E</TT
> нужно поставить только перед первым открывающим апострофом.) Внутри таких строк символ обратной косой черты (<TT
CLASS="LITERAL"
>\</TT
>) начинает C-подобные <I
CLASS="FIRSTTERM"
>спецпоследовательности</I
>, в которых сочетание обратной косой черты со следующим символом(ами) даёт определённое байтовое значение, как показано в <A
HREF="sql-syntax-lexical.html#SQL-BACKSLASH-TABLE"
>Таблице 4-1</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="SQL-BACKSLASH-TABLE"
></A
><P
><B
>Таблица 4-1. Спецпоследовательности</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Спецпоследовательность</TH
><TH
>Интерпретация</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                      <TT
CLASS="LITERAL"
>\b</TT
>
                    </TD
><TD
>символ &laquo;забой&raquo;</TD
></TR
><TR
><TD
>                      <TT
CLASS="LITERAL"
>\f</TT
>
                    </TD
><TD
>подача формы</TD
></TR
><TR
><TD
>                      <TT
CLASS="LITERAL"
>\n</TT
>
                    </TD
><TD
>новая строка</TD
></TR
><TR
><TD
>                      <TT
CLASS="LITERAL"
>\r</TT
>
                    </TD
><TD
>возврат каретки</TD
></TR
><TR
><TD
>                      <TT
CLASS="LITERAL"
>\t</TT
>
                    </TD
><TD
>табуляция</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>o</I
></TT
></TT
>, <TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>oo</I
></TT
></TT
>, <TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>ooo</I
></TT
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>o</I
></TT
> = 0 - 7)</TD
><TD
>восьмеричное значение байта</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\x<TT
CLASS="REPLACEABLE"
><I
>h</I
></TT
></TT
>, <TT
CLASS="LITERAL"
>\x<TT
CLASS="REPLACEABLE"
><I
>hh</I
></TT
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>h</I
></TT
> = 0 — 9, A — F)</TD
><TD
>шестнадцатеричное значение байта</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\u<TT
CLASS="REPLACEABLE"
><I
>xxxx</I
></TT
></TT
>, <TT
CLASS="LITERAL"
>\U<TT
CLASS="REPLACEABLE"
><I
>xxxxxxxx</I
></TT
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
> = 0 — 9, A — F)</TD
><TD
>16- или 32-битный шестнадцатеричный код символа Unicode</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (<TT
CLASS="LITERAL"
>\\</TT
>). Так же можно включить в строку апостроф, написав <TT
CLASS="LITERAL"
>\'</TT
>, в дополнение к обычному способу <TT
CLASS="LITERAL"
>''</TT
>.</P
><P
>Вы должны позаботиться, чтобы байтовые последовательности, которые вы создаёте таким образом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы в серверной кодировке. Когда сервер работает с кодировкой UTF-8, вместо такой записи байт следует использовать спецпоследовательности Unicode или альтернативный синтаксис Unicode, описанный в <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE"
>Подразделе 4.1.2.3</A
>. (В противном случае придётся кодировать символы UTF-8 вручную и выписывать их по байтам, что очень неудобно.)</P
><P
>Спецпоследовательности с Unicode полностью поддерживаются только при использовании на сервере кодировки <TT
CLASS="LITERAL"
>UTF8</TT
>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <TT
CLASS="LITERAL"
>\u007F</TT
>). И в четырёх, и в восьмизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие восьмизначной формы технически делает это ненужным. (Когда суррогатные пары используются с серверной кодировкой <TT
CLASS="LITERAL"
>UTF8</TT
>, они сначала объединяются в один символ, который затем кодируется в UTF-8.)</P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Предостережение</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Если параметр конфигурации <A
HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS"
>standard_conforming_strings</A
> имеет значение <TT
CLASS="LITERAL"
>off</TT
>, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> распознаёт обратную косую черту как спецсимвол и в обычных строках, и в строках со спецпоследовательностями. Однако в версии <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.1 по умолчанию принято значение <TT
CLASS="LITERAL"
>on</TT
>, и в этом случае обратная косая черта распознаётся только в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить работу приложений, рассчитанных на предыдущий режим, когда обратная косая черта распознавалась везде. В качестве временного решения вы можете изменить этот параметр на <TT
CLASS="LITERAL"
>off</TT
>, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая черта представляла специальный символ, задайте строковую константу с <TT
CLASS="LITERAL"
>E</TT
>.</P
><P
>В дополнение к <TT
CLASS="VARNAME"
>standard_conforming_strings</TT
> поведением обратной косой черты в строковых константах управляют параметры <A
HREF="runtime-config-compatible.html#GUC-ESCAPE-STRING-WARNING"
>escape_string_warning</A
> и <A
HREF="runtime-config-compatible.html#GUC-BACKSLASH-QUOTE"
>backslash_quote</A
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Строковая константа не может включать символ с кодом 0.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS-UESCAPE"
>4.1.2.3. Строковые константы со спецпоследовательностями Unicode</A
></H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> также поддерживает ещё один вариант спецпоследовательностей, позволяющий включать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями Unicode начинается с <TT
CLASS="LITERAL"
>U&amp;</TT
> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт апостроф, например <TT
CLASS="LITERAL"
>U&amp;'foo'</TT
>. (Заметьте, что при этом возникает неоднозначность с оператором <TT
CLASS="LITERAL"
>&amp;</TT
>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, строку <TT
CLASS="LITERAL"
>'data'</TT
> можно записать так:</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'d\0061t\+000061'</PRE
><P> В следующем менее тривиальном примере закодировано русское слово <SPAN
CLASS="QUOTE"
>"слон"</SPAN
>, записанное кириллицей: </P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'\0441\043B\043E\043D'</PRE
><P></P
><P
>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <TT
CLASS="LITERAL"
>UESCAPE</TT
> после строки, например: </P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'d!0061t!+000061' UESCAPE '!'</PRE
><P> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа.</P
><P
>Спецпоследовательности с Unicode поддерживаются только при использовании на сервере кодировки <TT
CLASS="LITERAL"
>UTF8</TT
>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <TT
CLASS="LITERAL"
>\007F</TT
>). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной формы технически делает это ненужным. (Когда суррогатные пары используются с серверной кодировкой <TT
CLASS="LITERAL"
>UTF8</TT
>, они сначала объединяются в один символ, который затем кодируется в UTF-8.)</P
><P
>Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только когда параметр конфигурации <A
HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS"
>standard_conforming_strings</A
> равен <TT
CLASS="LITERAL"
>on</TT
>. Это объясняется тем, что иначе клиентские программы, проверяющие SQL-операторы, можно будет ввести в заблуждение и эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет значение <TT
CLASS="LITERAL"
>off</TT
>, эти спецпоследовательности будут вызывать ошибку.</P
><P
>Чтобы включить спецсимвол в строку буквально, напишите его дважды.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-DOLLAR-QUOTING"
>4.1.2.4. Строковые константы, заключённые в доллары</A
></H3
><P
>Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может плохо читаться, когда строка содержит много апострофов или обратных косых черт, так как каждый такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались читаемыми, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> предлагает ещё один способ записи строковых констант &mdash; <SPAN
CLASS="QUOTE"
>"заключение строк в доллары"</SPAN
>. Строковая константа, заключённая в доллары, начинается со знака доллара (<TT
CLASS="LITERAL"
>$</TT
>), необязательного <SPAN
CLASS="QUOTE"
>"тега"</SPAN
> из нескольких символов и ещё одного знака доллара, затем содержит обычную последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же тегом и замыкающим знаком доллара. Например, строку <SPAN
CLASS="QUOTE"
>"Жанна д'Арк"</SPAN
> можно записать в долларах двумя способами: </P><PRE
CLASS="PROGRAMLISTING"
>$$Жанна д'Арк$$
$SomeTag$Жанна д'Арк$SomeTag$</PRE
><P> Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не являются спецсимволами, если только они не образуют последовательность, соответствующую открывающему тегу.</P
><P
>Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вложенности разные теги. Чаще всего это используется при написании определений функций. Например: </P><PRE
CLASS="PROGRAMLISTING"
>$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</PRE
><P> Здесь последовательность <TT
CLASS="LITERAL"
>$q$[\t\r\n\v\\]$q$</TT
> представляет в долларах текстовую строку <TT
CLASS="LITERAL"
>[\t\r\n\v\\]</TT
>, которая будет обработана, когда <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет выполнять эту функцию. Но так как эта последовательность не соответствует внешнему тегу в долларах (<TT
CLASS="LITERAL"
>$function$</TT
>), с точки зрения внешней строки это просто обычные символы внутри константы.</P
><P
>Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистрозависимы, так что <TT
CLASS="LITERAL"
>$tag$String content$tag$</TT
> &mdash; правильная строка, а <TT
CLASS="LITERAL"
>$TAG$String content$tag$</TT
> &mdash; нет.</P
><P
>Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от него пробельными символами, иначе доллар будет считаться продолжением предыдущего идентификатора.</P
><P
>Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный способ записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен, когда нужно представить строковую константу внутри другой строки, что часто требуется в определениях процедурных функций. Ограничившись только апострофами, каждую обратную косую черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы затем уменьшились до двух при разборе внешней строки, и наконец до одного при обработке внутренней строки во время выполнения функции.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-BIT-STRINGS"
>4.1.2.5. Битовые строковые константы</A
></H3
><P
>Битовые строковые константы похожи на обычные с дополнительной буквой <TT
CLASS="LITERAL"
>B</TT
> (заглавной или строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных пробелов), например: <TT
CLASS="LITERAL"
>B'1001'</TT
>. В битовых строковых константах допускаются лишь символы <TT
CLASS="LITERAL"
>0</TT
> и <TT
CLASS="LITERAL"
>1</TT
>.</P
><P
>Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной буквой <TT
CLASS="LITERAL"
>X</TT
> (заглавной или строчной), например: <TT
CLASS="LITERAL"
>X'1FF'</TT
>. Такая запись эквивалентна двоичной, только четыре двоичных цифры заменяются одной шестнадцатеричной.</P
><P
>Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако заключать в доллары битовые строки нельзя.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-CONSTANTS-NUMERIC"
>4.1.2.6. Числовые константы</A
></H3
><P
>Числовые константы могут быть заданы в следующем общем виде: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
>.[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></SPAN
>][<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></SPAN
>]
[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></SPAN
>].<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
>[<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></SPAN
>]
<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
></PRE
><P> где <TT
CLASS="REPLACEABLE"
><I
>цифры</I
></TT
> &mdash; это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за обозначением экспоненты (<TT
CLASS="LITERAL"
>e</TT
>), если оно присутствует. В числовой константе не может быть пробелов или других символов. Заметьте, что любой знак минус или плюс в начале строки не считается частью числа; это оператор, применённый к константе.</P
><P
>Несколько примеров допустимых числовых констант: <P
CLASS="LITERALLAYOUT"
>42<br>
3.5<br>
4.<br>
.001<br>
5e2<br>
1.925e-3</P
></P
><P
> Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как константа типа <TT
CLASS="TYPE"
>integer</TT
>, если её значение умещается в 32-битный тип <TT
CLASS="TYPE"
>integer</TT
>; затем как константа типа <TT
CLASS="TYPE"
>bigint</TT
>, если её значение умещается в 64-битный <TT
CLASS="TYPE"
>bigint</TT
>; в противном случае она принимает тип <TT
CLASS="TYPE"
>numeric</TT
>. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются константами типа <TT
CLASS="TYPE"
>numeric</TT
>.</P
><P
>Изначально назначенный тип данных числовой константы это только отправная точка для алгоритмов определения типа. В большинстве случаев константа будет автоматически приведена к наиболее подходящему типу для данного контекста. При необходимости вы можете принудительно интерпретировать числовое значение как значение определённого типа, приведя его тип к нужному. Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип <TT
CLASS="TYPE"
>real</TT
> (<TT
CLASS="TYPE"
>float4</TT
>), написав: </P><PRE
CLASS="PROGRAMLISTING"
>REAL '1.23'  -- строковый стиль
1.23::REAL   -- стиль PostgreSQL (исторический)</PRE
><P> На самом деле это только частные случаи синтаксиса приведения типов, который будет рассматриваться далее.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-CONSTANTS-GENERIC"
>4.1.2.7. Константы других типов</A
></H3
><P
>Константу <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>обычного</I
></SPAN
> типа можно ввести одним из следующих способов: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'
'<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'::<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>
CAST ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' AS <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> )</PRE
><P> Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного здесь <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>. Результатом становится константа указанного типа. Явное приведение типа можно опустить, если нужный тип константы определяется однозначно (например, когда она присваивается непосредственно колонке таблицы), так как в этом случае приведение происходит автоматически.</P
><P
>Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с долларами.</P
><P
>Также можно записать приведение типов, используя синтаксис функций: </P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>typename</I
></TT
> ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' )</PRE
><P>но это работает не для всех имён типов; подробнее об этом написано в <A
HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS"
>Подразделе 4.2.9</A
>.</P
><P
>Конструкцию <TT
CLASS="LITERAL"
>::</TT
>, <TT
CLASS="LITERAL"
>CAST()</TT
> и синтаксис вызова функции можно также использовать для преобразования типов обычных выражений во время выполнения, как описано в <A
HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS"
>Подразделе 4.2.9</A
>. Во избежание синтаксической неопределённости, запись <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>тип</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>строка</I
></TT
>'</TT
> можно использовать только для указания типа простой текстовой константы. Ещё одно ограничение записи <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>тип</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>строка</I
></TT
>'</TT
>: она не работает для массивов; для таких констант следует использовать <TT
CLASS="LITERAL"
>::</TT
> или <TT
CLASS="LITERAL"
>CAST()</TT
>.</P
><P
>Синтаксис <TT
CLASS="LITERAL"
>CAST()</TT
> соответствует SQL, а запись <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'</TT
> является обобщением стандарта: в SQL такой синтаксис поддерживает только некоторые типы данных, но <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> позволяет использовать его для всех. Синтаксис с <TT
CLASS="LITERAL"
>::</TT
> имеет исторические корни в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, как и запись в виде вызова функции.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-OPERATORS"
>4.1.3. Операторы</A
></H2
><P
>Имя оператора образует последовательность не более чем <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>-1 (по умолчанию 63) символов из следующего списка: <P
CLASS="LITERALLAYOUT"
>+&nbsp;-&nbsp;*&nbsp;/&nbsp;&lt;&nbsp;&gt;&nbsp;=&nbsp;~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P
> Однако для имён операторов есть ещё несколько ограничений: <P
></P
></P><UL
><LI
><P
>Сочетания символов <TT
CLASS="LITERAL"
>--</TT
> и <TT
CLASS="LITERAL"
>/*</TT
> не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.</P
></LI
><LI
><P
>Многосимвольное имя оператора не может заканчиваться знаками <TT
CLASS="LITERAL"
>+</TT
> или <TT
CLASS="LITERAL"
>-</TT
>, если только оно не содержит также один из этих символов: <P
CLASS="LITERALLAYOUT"
>~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P
> Например, <TT
CLASS="LITERAL"
>@-</TT
> &mdash; допустимое имя оператора, а <TT
CLASS="LITERAL"
>*-</TT
> &mdash; нет. Благодаря этому ограничению <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, может разбирать корректные SQL-запросы без пробелов между компонентами.</P
></LI
></UL
><P></P
><P
>Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов пробелами для однозначности. Например, если вы определили левый унарный оператор с именем <TT
CLASS="LITERAL"
>@</TT
>, вы не можете написать <TT
CLASS="LITERAL"
>X*@Y</TT
>, а должны написать <TT
CLASS="LITERAL"
>X* @Y</TT
>, чтобы <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> однозначно прочитал это как два оператора, а не один.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-SPECIAL-CHARS"
>4.1.4. Специальные знаки</A
></H2
><P
>Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не являются операторами. Подробнее их использование будет рассмотрено при описании соответствующего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения их предназначения. <P
></P
></P><UL
><LI
><P
>Знак доллара (<TT
CLASS="LITERAL"
>$</TT
>), предваряющий число, используется для представления позиционного параметра в теле определения функции или подготовленного оператора. В других контекстах знак доллара может быть частью идентификатора или строковой константы, заключённой в доллары.</P
></LI
><LI
><P
>Круглые скобки (<TT
CLASS="LITERAL"
>()</TT
>) имеют обычное значение и применяются для группировки выражений и повышения приоритета операций. В некоторых случаях скобки &mdash; это необходимая часть синтаксиса определённых SQL-команд.</P
></LI
><LI
><P
>Квадратные скобки (<TT
CLASS="LITERAL"
>[]</TT
>) применяются для выделения элементов массива. Подробнее массивы рассматриваются в <A
HREF="arrays.html"
>Разделе 8.15</A
>.</P
></LI
><LI
><P
>Запятые (<TT
CLASS="LITERAL"
>,</TT
>) используются в некоторых синтаксических конструкциях для разделения элементов списка.</P
></LI
><LI
><P
>Точка с запятой (<TT
CLASS="LITERAL"
>;</TT
>) завершает команду SQL. Она не может находиться нигде внутри команды, за исключением строковых констант или идентификаторов в кавычках.</P
></LI
><LI
><P
>Двоеточие (<TT
CLASS="LITERAL"
>:</TT
>) применяется для выборки <SPAN
CLASS="QUOTE"
>"срезов"</SPAN
> массивов (см. <A
HREF="arrays.html"
>Раздел 8.15</A
>.) В некоторых диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени переменной.</P
></LI
><LI
><P
>Звёздочка (<TT
CLASS="LITERAL"
>*</TT
>) используется в некоторых контекстах как обозначение всех полей строки или составного значения. Она также имеет специальное значение, когда используется как аргумент некоторых агрегатных функций, а именно функций, которым не нужны явные параметры.</P
></LI
><LI
><P
>Точка (<TT
CLASS="LITERAL"
>.</TT
>) используется в числовых константах, а также для отделения имён схемы, таблицы и колонки.</P
></LI
></UL
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-COMMENTS"
>4.1.5. Комментарии</A
></H2
><P
>Комментарий &mdash; это последовательность символов, которая начинается с двух минусов и продолжается до конца строки, например: </P><PRE
CLASS="PROGRAMLISTING"
>-- Это стандартный комментарий SQL</PRE
><P></P
><P
>Кроме этого, блочные комментарии можно записывать в стиле C: </P><PRE
CLASS="PROGRAMLISTING"
>/* многострочный комментарий
 * с вложенностью: /* вложенный блок комментария */
 */</PRE
><P> где комментарий начинается с <TT
CLASS="LITERAL"
>/*</TT
> и продолжается до соответствующего вхождения <TT
CLASS="LITERAL"
>*/</TT
>. Блочные комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в C), так что вы можете комментировать большие блоки кода, которые при этом уже могут содержать блоки комментариев.</P
><P
>Комментарий удаляется из входного потока в начале синтаксического анализа и фактически заменяется пробелом.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-PRECEDENCE"
>4.1.6. Приоритеты операторов</A
></H2
><P
>В <A
HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE"
>Таблице 4-2</A
> показаны приоритеты и очерёдность операторов, действующие в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. Большинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и очерёдность операторов жёстко фиксированы в синтаксическом анализаторе. Вследствие этого их поведение может быть не интуитивным, например, логические операторы <TT
CLASS="LITERAL"
>&lt;</TT
> и <TT
CLASS="LITERAL"
>&gt;</TT
> имеют приоритет, отличный от логических операторов <TT
CLASS="LITERAL"
>&lt;=</TT
> и <TT
CLASS="LITERAL"
>&gt;=</TT
>. Кроме того, иногда вам потребуется добавлять скобки, когда вы комбинируете унарные и бинарные операторы. Например, выражение: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 5 ! - 6;</PRE
><P> будет разобрано как: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 5 ! (- 6);</PRE
><P> так как анализатор до последнего не знает, что оператор <TT
CLASS="TOKEN"
>!</TT
> определён как постфиксный, а не инфиксный (внутренний). Чтобы получить желаемый результат в этом случае, нужно написать: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT (5 !) - 6;</PRE
><P> Такова цена расширяемости.</P
><DIV
CLASS="TABLE"
><A
NAME="SQL-PRECEDENCE-TABLE"
></A
><P
><B
>Таблица 4-2. Приоритет операторов (по убыванию)</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Оператор/элемент</TH
><TH
>Очерёдность</TH
><TH
>Описание</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <TT
CLASS="TOKEN"
>.</TT
>
                  </TD
><TD
>слева-направо</TD
><TD
>разделитель имён таблицы и колонки</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>::</TT
>
                  </TD
><TD
>слева-направо</TD
><TD
>приведение типов в стиле <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
></TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>[</TT
> <TT
CLASS="TOKEN"
>]</TT
></TD
><TD
>слева-направо</TD
><TD
>выбор элемента массива</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>+</TT
> <TT
CLASS="TOKEN"
>-</TT
></TD
><TD
>справа-налево</TD
><TD
>унарный плюс, унарный минус</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>^</TT
>
                  </TD
><TD
>слева-направо</TD
><TD
>возведение в степень</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>*</TT
> <TT
CLASS="TOKEN"
>/</TT
> <TT
CLASS="TOKEN"
>%</TT
></TD
><TD
>слева-направо</TD
><TD
>умножение, деление, остаток от деления</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>+</TT
> <TT
CLASS="TOKEN"
>-</TT
></TD
><TD
>слева-направо</TD
><TD
>сложение, вычитание</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>IS</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
><TT
CLASS="LITERAL"
>IS TRUE</TT
>, <TT
CLASS="LITERAL"
>IS FALSE</TT
>, <TT
CLASS="LITERAL"
>IS NULL</TT
> и т. д.</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>ISNULL</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
>проверка на значение NULL</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>NOTNULL</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
>проверка на значение не NULL</TD
></TR
><TR
><TD
>(все остальные)</TD
><TD
>слева-направо</TD
><TD
>все другие встроенные и пользовательские операторы</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>IN</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
>проверка членства</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>BETWEEN</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
>проверка диапазона</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>OVERLAPS</TT
>
                  </TD
><TD
>&nbsp;</TD
><TD
>проверка пересечения временных интервалов</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>LIKE</TT
> <TT
CLASS="TOKEN"
>ILIKE</TT
> <TT
CLASS="TOKEN"
>SIMILAR</TT
></TD
><TD
>&nbsp;</TD
><TD
>сравнение строк по шаблону</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>&lt;</TT
> <TT
CLASS="TOKEN"
>&gt;</TT
></TD
><TD
>&nbsp;</TD
><TD
>меньше, больше</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>=</TT
>
                  </TD
><TD
>справа-налево</TD
><TD
>проверка равенства, присваивание</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>NOT</TT
>
                  </TD
><TD
>справа-налево</TD
><TD
>логическое отрицание</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>AND</TT
>
                  </TD
><TD
>слева-направо</TD
><TD
>логическая конъюнкция</TD
></TR
><TR
><TD
>                    <TT
CLASS="TOKEN"
>OR</TT
>
                  </TD
><TD
>слева-направо</TD
><TD
>логическая дизъюнкция</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Заметьте, что правила приоритета операторов так же применяются к операторам, определённым пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например, если вы определите оператор <SPAN
CLASS="QUOTE"
>"+"</SPAN
> для некоторого нестандартного типа данных, он будет иметь тот же приоритет, что и встроенный оператор <SPAN
CLASS="QUOTE"
>"+"</SPAN
>, независимо от того, что он у вас делает.</P
><P
>Когда в конструкции <TT
CLASS="LITERAL"
>OPERATOR</TT
> используется имя оператора со схемой, например так: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT 3 OPERATOR(pg_catalog.+) 4;</PRE
><P> тогда <TT
CLASS="LITERAL"
>OPERATOR</TT
> имеет приоритет по умолчанию, соответствующий в <A
HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE"
>Таблице 4-2</A
> строке <SPAN
CLASS="QUOTE"
>"все остальные"</SPAN
>. Это не зависит от того, какие именно операторы находятся в конструкции <TT
CLASS="LITERAL"
>OPERATOR()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-expressions.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Синтаксис SQL</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Выражения значения</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>