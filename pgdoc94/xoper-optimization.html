<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Информация для оптимизации операторов</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Расширение SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Пользовательские операторы"
HREF="xoper.html"><LINK
REL="NEXT"
TITLE="Интерфейсы расширений для индексов"
HREF="xindex.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Пользовательские операторы"
HREF="xoper.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 35. Расширение <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Интерфейсы расширений для индексов"
HREF="xindex.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XOPER-OPTIMIZATION"
>35.13. Информация для оптимизации операторов</A
></H1
><P
>Определение оператора в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может включать различные дополнительные предложения, которые сообщают системе полезные сведения о поведении оператора. Старайтесь задавать эти предложения при возможности, так как они могут значительно ускорить выполнение запросов, использующих данный оператор. Но если вы задаёте их, убедитесь, что они корректны! Неправильное применение предложений оптимизации может привести к замедлению запросов, неочевидным ошибочным результатам и другим неприятностям. Если вы не уверены в правильности предложения оптимизации, лучше вовсе не использовать его; единственным последствием будет то, что запросы будут работать медленнее, чем могли бы.</P
><P
>В будущих версиях <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> могут быть добавлены и другие предложения. Здесь описываются те, что поддерживаются версией 9.4.1.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56519"
>35.13.1. <TT
CLASS="LITERAL"
>COMMUTATOR</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>COMMUTATOR</TT
>, если представлено, задаёт оператор, коммутирующий для определяемого. Оператор A является коммутирующим для оператора B, если (x A y) равняется (y B x) для всех возможных значений x, y. Заметьте, что B также будет коммутирующим для A. Например, операторы <TT
CLASS="LITERAL"
>&lt;</TT
> и <TT
CLASS="LITERAL"
>&gt;</TT
> для конкретного типа данных обычно являются коммутирующими друг для друга, а оператор <TT
CLASS="LITERAL"
>+</TT
> — коммутирующий для себя. Но традиционный оператор <TT
CLASS="LITERAL"
>-</TT
> коммутирующего не имеет.</P
><P
>Тип левого операнда оператора должен совпадать с типом правого операнда коммутирующего для него оператора, и наоборот. Поэтому имя коммутирующего оператора — это всё, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> должен знать, чтобы найти коммутатор, и всё, что нужно указать в предложении <TT
CLASS="LITERAL"
>COMMUTATOR</TT
>.</P
><P
>Информация о коммутирующих операторах крайне важна для операторов, которые будут применяться в индексах и условиях соединения, так как, используя её, оптимизатор запросов может <SPAN
CLASS="QUOTE"
>"переворачивать"</SPAN
> такие выражения и получать формы, необходимые для разных типов планов. Например, рассмотрим запрос с предложением WHERE <TT
CLASS="LITERAL"
>tab1.x = tab2.y</TT
>, где <TT
CLASS="LITERAL"
>tab1.x</TT
> и <TT
CLASS="LITERAL"
>tab2.y</TT
> имеют пользовательский тип, и предположим, что у нас есть индекс по колонке <TT
CLASS="LITERAL"
>tab2.y</TT
>. Оптимизатор сможет задействовать сканирование по индексу, только если ему удастся перевернуть выражение <TT
CLASS="LITERAL"
>tab2.y = tab1.x</TT
>, так как механизм сканирования по индексу ожидает, что индексируемая колонка находится слева от оператора. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> сам по себе <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>не</I
></SPAN
> будет полагать, что такое преобразование возможно &mdash; это должен определить создатель оператора <TT
CLASS="LITERAL"
>=</TT
>, добавив информацию о коммутирующем операторе.</P
><P
>Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно это. Если же вы определяете пару коммутирующих операторов, возникает небольшое затруднение: как оператор, определяемый первым, может ссылаться на другой, ещё не определённый? Есть два решения этой проблемы: <P
></P
></P><UL
><LI
><P
>Во-первых, можно опустить предложение <TT
CLASS="LITERAL"
>COMMUTATOR</TT
> для первого оператора, который вы определяете, а затем добавить его в определении второго. Так как <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> знает, что коммутирующие операторы связаны парами, встречая второе определение, он автоматически возвращается к первому и добавляет в него недостающее предложение <TT
CLASS="LITERAL"
>COMMUTATOR</TT
>.</P
></LI
><LI
><P
>Во-вторых, можно добавить предложение <TT
CLASS="LITERAL"
>COMMUTATOR</TT
> в оба определения. Когда <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> обрабатывает первое определение и видит, что <TT
CLASS="LITERAL"
>COMMUTATOR</TT
> ссылается на несуществующий оператор, в системном каталоге создаётся фиктивная запись для этого оператора. В этой фиктивной записи актуальны будут только имя оператора, типы левого и правого операндов, а также тип результата, так как это всё, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> может определить в этот момент. Запись первого оператора будет связана с этой фиктивной записью. Затем, когда вы определите второй оператор, система внесёт в эту фиктивную запись дополнительную информацию из второго определения. Если вы попытаетесь применить фиктивный оператор, прежде чем он будет полностью определён, вы просто получите сообщение об ошибке.</P
></LI
></UL
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56554"
>35.13.2. <TT
CLASS="LITERAL"
>NEGATOR</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>NEGATOR</TT
>, если присутствует, задаёт оператор, обратный к определяемому. Оператор A является обратным к оператору B, если они оба возвращают булевский результат и (x A y) равняется NOT (x B y) для всех возможных x, y. Заметьте, что B так же является обратным к A. Например, операторы <TT
CLASS="LITERAL"
>&lt;</TT
> и <TT
CLASS="LITERAL"
>&gt;=</TT
> составляют пару обратных друг к другу для большинства типов данных. Никакой оператор не может быть обратным к себе же.</P
><P
>В отличие от коммутирующих операторов, два унарных оператора вполне могут быть обратными к друг другу; это будет означать, что (A x) равняется NOT (B x) для всех x (и для правых унарных операторов аналогично).</P
><P
>У оператора, обратного данному, типы левого и/или правого операнда должны соответствовать типам данного оператора, так же как и с предложением <TT
CLASS="LITERAL"
>COMMUTATOR</TT
>; отличие только в том, что имя оператора задаётся в предложении <TT
CLASS="LITERAL"
>NEGATOR</TT
>.</P
><P
>Указание обратного оператора очень полезно для оптимизатора запросов, так как это позволяет упростить выражение вида <TT
CLASS="LITERAL"
>NOT (x = y)</TT
> до <TT
CLASS="LITERAL"
>x &lt;&gt; y</TT
>. Такие выражения не так редки, как может показаться, так как операции <TT
CLASS="LITERAL"
>NOT</TT
> могут добавляться автоматически в результате реорганизаций выражений.</P
><P
>Пару обратных операторов можно определить теми же способами, что были описаны ранее для пары коммутирующих.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56570"
>35.13.3. <TT
CLASS="LITERAL"
>RESTRICT</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>RESTRICT</TT
>, если представлено, определяет функцию оценки избирательности ограничения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <TT
CLASS="LITERAL"
>RESTRICT</TT
> имеют смысл только для бинарных операторов, возвращающих <TT
CLASS="TYPE"
>boolean</TT
>. Идея оценки избирательности ограничения заключается в том, чтобы определить, какой процент строк в таблице будет удовлетворять условию <TT
CLASS="LITERAL"
>WHERE</TT
> вида: </P><PRE
CLASS="PROGRAMLISTING"
>column OP constant</PRE
><P> для текущего оператора и определённого значения константы. Это помогает оптимизатору примерно определить, сколько строк будет исключено предложениями <TT
CLASS="LITERAL"
>WHERE</TT
> такого вида. (ВЫ спросите, а что если константа находится слева? Ну, собственно для таких случаев и задаётся <TT
CLASS="LITERAL"
>COMMUTATOR</TT
>...)</P
><P
>Разработка новых функций оценки избирательности ограничения выходит за рамки данной главы, но обычно можно использовать один из стандартных системных оценщиков для большинства дополнительных операторов. Стандартные оценщики ограничений следующие: <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><CODE
CLASS="FUNCTION"
>eqsel</CODE
> для <TT
CLASS="LITERAL"
>=</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>neqsel</CODE
> для <TT
CLASS="LITERAL"
>&lt;&gt;</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>scalarltsel</CODE
> для <TT
CLASS="LITERAL"
>&lt;</TT
> или <TT
CLASS="LITERAL"
>&lt;=</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>scalargtsel</CODE
> для <TT
CLASS="LITERAL"
>&gt;</TT
> или <TT
CLASS="LITERAL"
>&gt;=</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
> Может показаться немного странным, что выбраны именно эти категории, но если подумать, это имеет смысл. Оператор <TT
CLASS="LITERAL"
>=</TT
> обычно оставляет только небольшой процент строк в таблице, а <TT
CLASS="LITERAL"
>&lt;&gt;</TT
> отбрасывает то же количество. Оператор <TT
CLASS="LITERAL"
>&lt;</TT
> оставляет процент, зависящий от того, в какой диапазон значений определённой колонки таблицы попадает заданная константа (информация об этих диапазонах собирается командой <TT
CLASS="COMMAND"
>ANALYZE</TT
> и предоставляется оценщику избирательности). Оператор <TT
CLASS="LITERAL"
>&lt;=</TT
> оставляет чуть больший процент, чем <TT
CLASS="LITERAL"
>&lt;</TT
>, при сравнении с той же константой, но они настолько близки, что различать их не имеет смысла, так как это не даст лучшего результата, чем просто угадывание. Подобные замечания применимы и к операторам <TT
CLASS="LITERAL"
>&gt;</TT
> и <TT
CLASS="LITERAL"
>&gt;=</TT
>.</P
><P
>Часто вы можете обойтись функциями <CODE
CLASS="FUNCTION"
>eqsel</CODE
> и <CODE
CLASS="FUNCTION"
>neqsel</CODE
> для операторов с очень высокой или низкой избирательностью, даже если это не операторы собственно равенства или неравенства. Например, геометрические операторы приблизительного равенства используют <CODE
CLASS="FUNCTION"
>eqsel</CODE
> в предположении, что соответствующие (равные) элементы будут составлять только небольшой процент от всех записей таблицы.</P
><P
>Функции <CODE
CLASS="FUNCTION"
>scalarltsel</CODE
> и <CODE
CLASS="FUNCTION"
>scalargtsel</CODE
> можно использовать для сравнений с типами данных, которые могут быть каким-либо осмысленным образом преобразованы в числовые скалярные значения для сравнения диапазонов. Если возможно, добавьте свой тип данных в число тех, что понимает функция <CODE
CLASS="FUNCTION"
>convert_to_scalar()</CODE
> в <TT
CLASS="FILENAME"
>src/backend/utils/adt/selfuncs.c</TT
>. (Когда-нибудь эта функция должна быть заменена специализированными функциями, которые будут устанавливаться для конкретных типов в определённой колонке системного каталога <CODE
CLASS="CLASSNAME"
>pg_type</CODE
>; но сейчас это не так.) Если вы этого не сделаете, всё будет работать, но оценки оптимизатора будут не так хороши, как могли бы быть.</P
><P
>Для геометрических операторов разработаны дополнительные функции оценки избирательности в <TT
CLASS="FILENAME"
>src/backend/utils/adt/geo_selfuncs.c</TT
>: <CODE
CLASS="FUNCTION"
>areasel</CODE
>, <CODE
CLASS="FUNCTION"
>positionsel</CODE
> и <CODE
CLASS="FUNCTION"
>contsel</CODE
>. На момент написания документации это просто заглушки, но вы, тем не менее, вполне можете использовать (или ещё лучше, доработать) их.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56620"
>35.13.4. <TT
CLASS="LITERAL"
>JOIN</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>JOIN</TT
>, если представлено, определяет функцию оценки избирательности соединения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <TT
CLASS="LITERAL"
>JOIN</TT
> имеют смысл только для бинарных операторов, возвращающих <TT
CLASS="TYPE"
>boolean</TT
>. Идея оценки избирательности соединения заключается в том, чтобы угадать, какой процент строк в паре таблиц будет удовлетворять условию <TT
CLASS="LITERAL"
>WHERE</TT
> следующего вида: </P><PRE
CLASS="PROGRAMLISTING"
>table1.column1 OP table2.column2</PRE
><P> для текущего оператора. Как и <TT
CLASS="LITERAL"
>RESTRICT</TT
>, это предложение очень помогает оптимизатору, позволяя ему выяснить, какой из возможных вариантов соединения скорее всего окажется выгоднее.</P
><P
>Как и ранее, в этой главе мы не будем пытаться рассказать, как написать функцию оценивания избирательности соединения, а просто отметим, что вы можете использовать один из подходящих стандартных оценщиков: <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><CODE
CLASS="FUNCTION"
>eqjoinsel</CODE
> для <TT
CLASS="LITERAL"
>=</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>neqjoinsel</CODE
> для <TT
CLASS="LITERAL"
>&lt;&gt;</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>scalarltjoinsel</CODE
> для <TT
CLASS="LITERAL"
>&lt;</TT
> или <TT
CLASS="LITERAL"
>&lt;=</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>scalargtjoinsel</CODE
> для <TT
CLASS="LITERAL"
>&gt;</TT
> или <TT
CLASS="LITERAL"
>&gt;=</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>areajoinsel</CODE
> для сравнений областей в плоскости</TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>positionjoinsel</CODE
> для сравнения положений в плоскости</TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>contjoinsel</CODE
> для проверки на включение в плоскости</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56652"
>35.13.5. <TT
CLASS="LITERAL"
>HASHES</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>HASHES</TT
>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения по хешу. <TT
CLASS="LITERAL"
>HASHES</TT
> имеет смысл только для бинарного оператора, который возвращает <TT
CLASS="LITERAL"
>boolean</TT
>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</P
><P
>Соединение по хешу базируется на том предположении, что оператор соединения возвращает истину только для таких пар значений слева и справа, для которых получается одинаковый хеш. Если два значения оказываются в разных ячейках хеша, операция соединения никогда не будет сравнивать их, неявно подразумевая, что результат оператора соединения в этом случае должен быть ложным. Поэтому не имеет никакого смысла указывать <TT
CLASS="LITERAL"
>HASHES</TT
> для операторов, которые не представляют какую-любо форму равенства. В большинстве случаев практический смысл в поддержке хеширования есть только для операторов, принимающих один тип данных с обеих сторон. Однако иногда возможно разработать хеш-функции, совместимые сразу с несколькими типами данных; то есть, функции, которые будут выдавать одинаковые хеш-коды для <SPAN
CLASS="QUOTE"
>"равных"</SPAN
> значений, несмотря на то, что эти значения будут представлены по-разному. Например, довольно легко функции с такой особенностью реализуются для хеширования целых чисел различного размера.</P
><P
>Чтобы оператор соединения имел характеристику <TT
CLASS="LITERAL"
>HASHES</TT
>, он должен входить в семейство операторов индексирования по хешу. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но при попытке использовать такой оператор для соединения по хешу, возникнет ошибка во время выполнения, если такого семейства не окажется. Системе необходимо знать семейство операторов, чтобы найти функции для хеширования типа(ов) входных данных оператора. Конечно, вы должны также определить подходящие функции хеширования, прежде чем сможете создать семейство операторов.</P
><P
>При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она всегда выдавала нужный результат, вне зависимости от особенностей машинной архитектуры. Например, если ваш тип данных представлен в структуре, в которой есть незначащие дополняющие биты, нельзя просто передать всю структуру функции <CODE
CLASS="FUNCTION"
>hash_any</CODE
>. (Это возможно, только если все ваши операторы и функции гарантированно очищают незначащие биты, что является рекомендуемой стратегией.) В качестве другого примера можно привести типы с плавающей точкой в стандарте <ACRONYM
CLASS="ACRONYM"
>IEEE</ACRONYM
>, в которых отрицательный ноль и положительный ноль — различные значения (отличаются на уровне битов), но при сравнении они считаются равными. Если значение с плавающей точкой может содержать отрицательный ноль, требуются дополнительные действия, чтобы для него выдавался тот же хеш, что и для положительного нуля.</P
><P
>Оператор соединения по хешу должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов хеширования, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Функция, реализующая оператор соединения по хешу, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения по хешу.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта функция также должна быть полной: то есть она должна возвращать true или false, но не NULL, для любых двух аргументов, отличных от NULL. Если это правило не соблюдается, оптимизация операций <TT
CLASS="LITERAL"
>IN</TT
> с хешем может приводить к неверным результатам. (В частности, выражение <TT
CLASS="LITERAL"
>IN</TT
> может вернуть false, когда правильным ответом, согласно стандарту, должен быть NULL, либо выдать ошибку с сообщением о том, что оно не готов к результату NULL.)</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56674"
>35.13.6. <TT
CLASS="LITERAL"
>MERGES</TT
></A
></H2
><P
>Предложение <TT
CLASS="LITERAL"
>MERGES</TT
>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения слиянием. <TT
CLASS="LITERAL"
>MERGES</TT
> имеет смысл только для бинарного оператора, который возвращает <TT
CLASS="LITERAL"
>boolean</TT
>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</P
><P
>Идея объединения слиянием заключается в упорядочивании таблиц слева и справа и затем параллельном сканировании их. Поэтому оба типа данных должны поддерживать сортировку в полном объёме, а оператор соединения должен давать положительный результат только для пар значений, оказавшихся в <SPAN
CLASS="QUOTE"
>"одном месте"</SPAN
> при определённом порядке сортировки. На практике это означает, что оператор соединения должен работать как проверка на равенство. Но при этом возможно объединить слиянием два различных типа данных, если они совместимы логически. Например, оператор проверки равенства <TT
CLASS="TYPE"
>smallint</TT
> и <TT
CLASS="TYPE"
>integer</TT
> может применяться для соединений слиянием; понадобятся только операторы сортировки, приводящие оба типа данных в логически совместимые последовательности.</P
><P
>Чтобы оператор соединения имел характеристику <TT
CLASS="LITERAL"
>MERGES</TT
>, он должен являться членом семейства операторов индекса <TT
CLASS="LITERAL"
>btree</TT
>, реализующим равенство. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но этот оператор не будет фактически применяться для соединений слиянием, пока не будет найдено соответствующее семейство операторов. Таким образом, флаг <TT
CLASS="LITERAL"
>MERGES</TT
> только подсказывает планировщику, что стоит обратиться к соответствующему семейству.</P
><P
>Оператор соединения слиянием должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов <TT
CLASS="LITERAL"
>btree</TT
>, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>Функция, реализующая оператор соединения слиянием, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения слиянием.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xoper.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xindex.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Пользовательские операторы</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Интерфейсы расширений для индексов</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>