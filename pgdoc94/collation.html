<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Поддержка правил сортировки</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Локализация"
HREF="charset.html"><LINK
REL="PREVIOUS"
TITLE="Поддержка языковых стандартов"
HREF="locale.html"><LINK
REL="NEXT"
TITLE="Поддержка кодировок"
HREF="multibyte.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Поддержка языковых стандартов"
HREF="locale.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="charset.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 22. Локализация</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Поддержка кодировок"
HREF="multibyte.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COLLATION"
>22.2. Поддержка правил сортировки</A
></H1
><P
>Правила сортировки позволяют устанавливать порядок сортировки и особенности классификации символов в отдельных столбцах или даже при выполнении отдельных операций. Это смягчает последствия того, что параметры базы данных <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> и <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> невозможно изменить после её создания.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35100"
>22.2.1. Основные понятия</A
></H2
><P
>Концептуально, каждое выражение с типом данных, к которому применяется сортировка, имеет правила сортировки. (Встроенными сортируемыми типами данных являются <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>varchar</TT
>, и <TT
CLASS="TYPE"
>char</TT
>. Типы, определяемые в базе пользователем, могут также быть отмечены как сортируемые, и, конечно, домен на основе сортируемого типа данных является сортируемым.) Если выражение содержит ссылку на столбец, правила сортировки выражения определяются правилами сортировки столбца. Если выражение — константа, правилами сортировки являются стандартные правила для типа данных константы. Правила сортировки более сложных выражений являются производной от правил сортировки входящих в него частей, как описано ниже.</P
><P
>Правилами сортировки выражения могут быть правила сортировки <SPAN
CLASS="QUOTE"
>"по умолчанию"</SPAN
>, что означает использование параметров локали, установленных для базы данных. Также возможно, что правила сортировки выражения могут не определиться. В таких случаях операции упорядочивания и другие операции, для которых необходимы правила сортировки, завершатся с ошибкой.</P
><P
>Когда база данных должна выполнить упорядочивание или классификацию символов, она использует правила сортировки выполняемого выражения. Это происходит, к примеру, с предложениями <TT
CLASS="LITERAL"
>ORDER BY</TT
> и такими вызовами функций или операторов как <TT
CLASS="LITERAL"
>&lt;</TT
>. Правила сортировки, которые применяются в предложении <TT
CLASS="LITERAL"
>ORDER BY</TT
>, это просто правила ключа сортировки. Правила сортировки, применяемые к вызову функции или оператора, определяются их параметрами, как описано ниже. В дополнение к операциям сравнения, правила сортировки учитываются функциями, преобразующими регистр символов, такими как <CODE
CLASS="FUNCTION"
>lower</CODE
>, <CODE
CLASS="FUNCTION"
>upper</CODE
>, и <CODE
CLASS="FUNCTION"
>initcap</CODE
>; операторами поиска по шаблону; и функцией <CODE
CLASS="FUNCTION"
>to_char</CODE
> и связанными с ней.</P
><P
>При вызове функции или оператора правило сортировки определяется в зависимости от того, какие правила заданы для аргументов во время выполнения данной операции. Если результатом вызова функции или оператора является сортируемый тип данных, правила сортировки также используются во время разбора как определяемые правила сортировки функции или выражения оператора, в случае, если для внешнего выражения требуется знание правил сортировки.</P
><P
><I
CLASS="FIRSTTERM"
>Определение правил сортировки </I
> выражения может быть неявным или явным. Это отличие влияет на то, как комбинируются правила сортировки, когда несколько разных правил появляются в выражении. Явное определение правил сортировки возникает, когда используется предложение <TT
CLASS="LITERAL"
>COLLATE</TT
>; все прочие варианты являются неявными. Когда необходимо объединить несколько правил сортировки, например, в вызове функции, используются следующие правила: <P
></P
></P><OL
TYPE="1"
><LI
><P
>Если для одного из выражений-аргументов правило сортировки определено явно, то и для других аргументов явно задаваемое правило должно быть тем же, иначе возникнет ошибка. В случае присутствия явного определения правила сортировки, оно становится результирующим для всей операции.</P
></LI
><LI
><P
>В противном случае все входные выражения должны иметь одни и те же неявно определяемые правила сортировки или правила сортировки по умолчанию. Если присутствуют какие- либо правила сортировки, отличные от заданных по умолчанию, получаем результат комбинации правил сортировки. Иначе результатом станут правила сортировки, заданные по умолчанию.</P
></LI
><LI
><P
>Если среди входных выражений есть конфликтующие неявные правила сортировки, отличные от заданных по умолчанию, тогда комбинация рассматривается как имеющая неопределённые правила сортировки. Это не является условием возникновения ошибки, если вызываемой конкретной функции не требуются данные о правилах сортировки, которые ей следует применить. Если же такие данные требуются, это приведёт к ошибке во время выполнения.</P
></LI
></OL
><P> В качестве примера рассмотрим данное определение таблицы: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE test1 (
    a text COLLATE "de_DE",
    b text COLLATE "es_ES",
    ...
);</PRE
><P> Затем в </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; 'foo' FROM test1;</PRE
><P> выполняется оператор сравнения <TT
CLASS="LITERAL"
>&lt;</TT
> согласно правилам <TT
CLASS="LITERAL"
>de_DE</TT
>, так как выражение объединяет неявно определяемые правила сортировки с правилами, заданными по умолчанию. Но в </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; ('foo' COLLATE "fr_FR") FROM test1;</PRE
><P> сравнение выполняется с помощью правил <TT
CLASS="LITERAL"
>fr_FR</TT
>, так как явное определение правил сортировки переопределяет неявное. Кроме того, получив </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; b FROM test1;</PRE
><P>, анализатор запросов не может определить, какое правило сортировки использовать, поскольку столбцы <TT
CLASS="STRUCTFIELD"
>a</TT
> и <TT
CLASS="STRUCTFIELD"
>b</TT
> имеют конфликтующие неявные правила сортировки. Так как оператору <TT
CLASS="LITERAL"
>&lt;</TT
> требуется знать, какое правило использовать, это приведёт к ошибке. Ошибку можно устранить, применив явное указание правил сортировки к любому из двух входных выражений. Например: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; b COLLATE "de_DE" FROM test1;</PRE
><P> либо эквивалентное ему </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a COLLATE "de_DE" &lt; b FROM test1;</PRE
><P> С другой стороны, следующее выражение схожей структуры </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a || b FROM test1;</PRE
><P> не приводит к ошибке, поскольку для оператора <TT
CLASS="LITERAL"
>||</TT
> правила сортировки не имеют значения, так как результат не зависит от сортировки.</P
><P
>Правила сортировки, назначенные функции или комбинации входных выражений оператора, также могут быть применены к функции или результату оператора, если функция или оператор возвращают результат сортируемого типа данных. Так, в </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || 'foo';</PRE
><P> упорядочение будет происходить согласно правилам <TT
CLASS="LITERAL"
>de_DE</TT
>. Но данный запрос: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || b;</PRE
><P> приводит к ошибке, потому что, даже если оператору <TT
CLASS="LITERAL"
>||</TT
> не нужно знать правила сортировки, предложению <TT
CLASS="LITERAL"
>ORDER BY</TT
> это требуется. Как было сказано выше, конфликт может быть разрешён при помощи явного указания правил сортировки: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || b COLLATE "fr_FR";</PRE
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35148"
>22.2.2. Управление правилами сортировки</A
></H2
><P
>Правила сортировки представляют собой объект схемы SQL, который сопоставляет SQL-имя с локалью операционной системы. В частности, оно преобразуется в комбинацию <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> и <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>. (Как видно из названия, основная цель правил сортировки — настроить параметр <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
>, который контролирует порядок сортировки. Однако на практике редко возникает необходимость иметь <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>, отличный от <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
>, поэтому удобнее объединить их в одно целое, чем создавать ещё один элемент инфраструктуры для указания <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> на уровне выражения.) Также, правила сортировки связаны с кодировкой набора символов (см. <A
HREF="multibyte.html"
>Раздел 22.3</A
>). Одно и то же имя правил сортировки может существовать для разных кодировок.</P
><P
>На всех платформах доступны правила сортировки под названием <TT
CLASS="LITERAL"
>default</TT
>, <TT
CLASS="LITERAL"
>C</TT
>, и <TT
CLASS="LITERAL"
>POSIX</TT
>. Дополнительные правила сортировки могут быть доступны в зависимости от поддержки операционной системы. Правило сортировки <TT
CLASS="LITERAL"
>default</TT
> использует значения <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> и <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>, заданные при создании базы данных. Правила сортировки <TT
CLASS="LITERAL"
>C</TT
> и <TT
CLASS="LITERAL"
>POSIX</TT
> определяют поведение, характерное для <SPAN
CLASS="QUOTE"
>"традиционного C "</SPAN
>, в котором только знаки кодировки ASCII от <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>A</TT
>"</SPAN
> до <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>Z</TT
>"</SPAN
> рассматриваются как буквы, и сортировка осуществляется строго по символьному коду байтов.</P
><P
>Если операционная система обеспечивает использование нескольких локалей внутри одной программы (<CODE
CLASS="FUNCTION"
>newlocale</CODE
> и аналогичные функции), тогда при создании кластера баз данных <TT
CLASS="COMMAND"
>initdb</TT
> заполняет системный каталог <TT
CLASS="LITERAL"
>pg_collation</TT
> правилами сортировки на основе всех локалей, найденных в операционной системе на текущий момент. Допустим, операционная система может предоставить локаль с именем <TT
CLASS="LITERAL"
>de_DE.utf8</TT
>. Тогда <TT
CLASS="COMMAND"
>initdb</TT
> создаст правила сортировки под именем <TT
CLASS="LITERAL"
>de_DE.utf8</TT
> для кодировки <TT
CLASS="LITERAL"
>UTF8</TT
>, которые имеют как <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
>, так и <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>, установленные в <TT
CLASS="LITERAL"
>de_DE.utf8</TT
>. Также будут созданы правила сортировки без <TT
CLASS="LITERAL"
>.utf8</TT
> в окончании имени. Таким образом, вы также могли бы использовать правила сортировки под именем <TT
CLASS="LITERAL"
>de_DE</TT
>, которое не так громоздко при написании и менее зависимо от кодировки. Однако, необходимо отметить, что исходный набор имён правил сортировки зависит от платформы.</P
><P
>В случае если необходимы правила сортировки, имеющие разные значения для <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> и <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>, могут быть созданы новые правила сортировки с помощью команды <A
HREF="sql-createcollation.html"
>CREATE COLLATION</A
>. Эта команда может быть использована для создания новых правил сортировки из уже существующих, что может быть полезно при использовании в приложениях имён правил сортировки, не зависящих от операционной системы.</P
><P
>В любой базе данных имеют значение только те правила сортировки, которые используют кодировку этой базы данных. Прочие записи в <TT
CLASS="LITERAL"
>pg_collation</TT
> игнорируются. Таким образом, усечённое имя правил сортировки, такое как <TT
CLASS="LITERAL"
>de_DE</TT
>, может считаться уникальным внутри данной базы данных, даже если бы оно не было уникальным глобально. Использование усечённого имени сортировки рекомендуется, так как при переходе на другую кодировку базы данных придётся выполнить на одно изменение меньше. Однако, следует помнить, что правила сортировки <TT
CLASS="LITERAL"
>default</TT
>, <TT
CLASS="LITERAL"
>C</TT
> и <TT
CLASS="LITERAL"
>POSIX</TT
> можно использовать независимо от кодировки базы данных.</P
><P
>В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> предполагается, что отдельные объекты правил сортировки несовместимы, даже когда они имеют идентичные свойства. Так, например, </P><PRE
CLASS="PROGRAMLISTING"
>SELECT a COLLATE "C" &lt; b COLLATE "POSIX" FROM test1;</PRE
><P> выведет сообщение об ошибке, несмотря на то, что поведение правил сортировки <TT
CLASS="LITERAL"
>C</TT
> и <TT
CLASS="LITERAL"
>POSIX</TT
> идентично. По этой причине смешивать усечённые и полные имена правил сортировки не рекомендуется.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="locale.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="multibyte.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Поддержка языковых стандартов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="charset.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Поддержка кодировок</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>