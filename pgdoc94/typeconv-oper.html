<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Операторы</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Преобразование типов"
HREF="typeconv.html"><LINK
REL="PREVIOUS"
TITLE="Обзор"
HREF="typeconv-overview.html"><LINK
REL="NEXT"
TITLE="Функции"
HREF="typeconv-func.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Обзор"
HREF="typeconv-overview.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 10. Преобразование типов</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Функции"
HREF="typeconv-func.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPECONV-OPER"
>10.2. Операторы</A
></H1
><P
>При выборе конкретного оператора, задействованного в выражении, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> следует описанному ниже алгоритму. Заметьте, что на этот выбор могут неявно влиять приоритеты остальных операторов в данном выражении, так как они определяют, какие подвыражения будут аргументами операторов. Подробнее об этом рассказывается в <A
HREF="sql-syntax-lexical.html#SQL-PRECEDENCE"
>Подразделе 4.1.6</A
>.</P
><DIV
CLASS="PROCEDURE"
><P
><B
>Выбор оператора по типу</B
></P
><OL
TYPE="1"
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-SELECT"
></A
><P
>Выбрать операторы для рассмотрения из системного каталога <CODE
CLASS="CLASSNAME"
>pg_operator</CODE
>. Если имя оператора не дополнено именем схемы (обычно это так), будут рассматриваться все операторы с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <A
HREF="ddl-schemas.html#DDL-SCHEMAS-PATH"
>Подраздел 5.7.3</A
>). Если имя оператора определено полностью, в рассмотрение принимаются только операторы из указанной схемы.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
CLASS="STEP"
><P
>Если в пути поиска оказывается несколько операторов с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Операторы с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</P
></LI
></OL
></LI
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-EXACT-MATCH"
></A
><P
>Проверить, нет ли среди них оператора с точно совпадающими типами аргументов. Если такой оператор есть (он может быть только одним в отобранном ранее наборе), использовать его.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-EXACT-UNKNOWN"
></A
><P
>Если один аргумент при вызове бинарного оператора имеет тип <TT
CLASS="TYPE"
>unknown</TT
>, для данной проверки предполагается, что он имеет тот же тип, что и второй его аргумент. При вызове бинарного оператора с двумя аргументами <TT
CLASS="TYPE"
>unknown</TT
> или унарного с одним <TT
CLASS="TYPE"
>unknown</TT
>, оператор не будет выбран на этом шаге.</P
></LI
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-EXACT-DOMAIN"
></A
><P
>Если один аргумент при вызове бинарного оператора имеет тип <TT
CLASS="TYPE"
>unknown</TT
>, а другой &mdash; домен, проверить, есть ли оператор, принимающий базовый тип домена с обеих сторон; если таковой находится, использовать его.</P
></LI
></OL
></LI
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-BEST-MATCH"
></A
><P
>Найти самый подходящий.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
CLASS="STEP"
><P
>Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <TT
CLASS="TYPE"
>unknown</TT
> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданного оператора домены будут подобны свои базовым типам.</P
></LI
><LI
CLASS="STEP"
><P
>Просмотреть все кандидаты и оставить только те, для которых точно совпадают как можно больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><P
>Если какие-либо значения имеют тип <TT
CLASS="TYPE"
>unknown</TT
>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <TT
CLASS="TYPE"
>string</TT
>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу &mdash; сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</P
></LI
><LI
CLASS="STEP"
><A
NAME="OP-RESOL-LAST-UNKNOWN"
></A
><P
>Если в списке аргументов есть аргументы и типа <TT
CLASS="TYPE"
>unknown</TT
>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <TT
CLASS="TYPE"
>unknown</TT
> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <TT
CLASS="TYPE"
>unknown</TT
>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</P
></LI
></OL
></LI
></OL
></DIV
><P
>Ниже это проиллюстрировано на примерах.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22775"
></A
><P
><B
>Пример 10-1. Разрешение оператора факториала</B
></P
><P
>В стандартном каталоге определён только один оператор факториала (постфиксный <TT
CLASS="LITERAL"
>!</TT
>) и он принимает аргумент типа <TT
CLASS="TYPE"
>bigint</TT
>. При просмотре следующего выражения его аргументу изначально назначается тип <TT
CLASS="TYPE"
>integer</TT
>: </P><PRE
CLASS="SCREEN"
>SELECT 40 ! AS "40 factorial";

                   40 factorial
--------------------------------------------------
 815915283247897734345611269596115894272000000000
(1 row)</PRE
><P> Анализатор выполняет преобразование типа для этого операнда и запрос становится равносильным: </P><PRE
CLASS="SCREEN"
>SELECT CAST(40 AS bigint) ! AS "40 factorial";</PRE
><P></P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22783"
></A
><P
><B
>Пример 10-2. Разрешение оператора конкатенации строк</B
></P
><P
>Синтаксис текстовых строк используется как для записи строковых типов, так и для сложных типов расширений. Если тип не указан явно, такие строки сопоставляются по тому же алгоритму с наиболее подходящими операторами.</P
><P
>Пример с одним неопределённым аргументом: </P><PRE
CLASS="SCREEN"
>SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)</PRE
><P></P
><P
>В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента имеют тип <TT
CLASS="TYPE"
>text</TT
>. Такой оператор находится, поэтому предполагается, что второй аргумент следует воспринимать как аргумент типа <TT
CLASS="TYPE"
>text</TT
>.</P
><P
>Конкатенация двух значений неопределённых типов: </P><PRE
CLASS="SCREEN"
>SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)</PRE
><P></P
><P
>В данном случае нет подсказки для выбора типа, так как в данном запросе никакие типы не указаны. Поэтому анализатор просматривает все возможные операторы и находит в них кандидаты, принимающие аргументы категорий string и bit-string. Так как категория string является предпочтительной, выбирается она, а затем для разрешения типа не типизированной константы выбирается предпочтительный тип этой категории, <TT
CLASS="TYPE"
>text</TT
>.</P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22795"
></A
><P
><B
>Пример 10-3. Разрешение оператора абсолютного значения и отрицания</B
></P
><P
>В каталоге операторов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> для префиксного оператора <TT
CLASS="LITERAL"
>@</TT
> есть несколько записей, описывающих операции получения абсолютного значения для различных числовых типов данных. Одна из записей соответствует типу <TT
CLASS="TYPE"
>float8</TT
>, предпочтительного в категории числовых типов. Таким образом, столкнувшись со значением типа <TT
CLASS="TYPE"
>unknown</TT
>, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> выберет эту запись: </P><PRE
CLASS="SCREEN"
>SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)</PRE
><P> Здесь система неявно привела константу неизвестного типа к типу <TT
CLASS="TYPE"
>float8</TT
>, прежде чем применять выбранный оператор. Можно убедиться в том, что выбран именно тип <TT
CLASS="TYPE"
>float8</TT
>, а не какой-то другой: </P><PRE
CLASS="SCREEN"
>SELECT @ '-4.5e500' AS "abs";

ОШИБКА:  "-4.5e500" вне диапазона для типа double precision</PRE
><P></P
><P
>С другой стороны, префиксный оператор <TT
CLASS="LITERAL"
>~</TT
> (побитовое отрицание) определён только для целочисленных типов данных, но не для <TT
CLASS="TYPE"
>float8</TT
>. Поэтому, если попытаться выполнить похожий запрос с <TT
CLASS="LITERAL"
>~</TT
>, мы получаем: </P><PRE
CLASS="SCREEN"
>SELECT ~ '20' AS "negation";

ОШИБКА: оператор не уникален: ~ "unknown"
ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам следует
добавить явные преобразования типов.</PRE
><P> Это происходит оттого, что система не может решить, какой оператор предпочесть из нескольких возможных вариантов <TT
CLASS="LITERAL"
>~</TT
>. Мы можем облегчить её задачу, добавив явное преобразование: </P><PRE
CLASS="SCREEN"
>SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)</PRE
><P></P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22814"
></A
><P
><B
>Пример 10-4. Разрешение оператора включения в массив</B
></P
><P
>Ещё один пример разрешения оператора с одним аргументом известного типа и другим неизвестного: </P><PRE
CLASS="SCREEN"
>SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)</PRE
><P> В каталоге операторов <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> есть несколько записей для инфиксного оператора <TT
CLASS="LITERAL"
>&lt;@</TT
>, но только два из них могут принять целочисленный массива слева: оператор включения массива (<TT
CLASS="TYPE"
>anyarray</TT
><TT
CLASS="LITERAL"
>&lt;@</TT
><TT
CLASS="TYPE"
>anyarray</TT
>) и оператор включения диапазона (<TT
CLASS="TYPE"
>anyelement</TT
><TT
CLASS="LITERAL"
>&lt;@</TT
><TT
CLASS="TYPE"
>anyrange</TT
>). Так как ни один из этих полиморфных псевдотипов (см. <A
HREF="datatype-pseudo.html"
>Раздел 8.20</A
>) не считается предпочтительным, анализатор не может избавиться от неоднозначности на данном этапе. Однако, в <A
HREF="typeconv-oper.html#OP-RESOL-LAST-UNKNOWN"
>Шаге 3.f</A
> говорится, что константа неизвестного типа должна рассматриваться как значение типа другого аргумента, в данном случае это целочисленный массив. После этого подходящим считается только один из двух операторов, так что выбирается оператор с целочисленными массивами. (Если бы был выбран оператор включения диапазона, мы получили бы ошибку, так как значение в строке не соответствует формату значений диапазона.)</P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN22828"
></A
><P
><B
>Пример 10-5. Нестандартный оператор с доменом</B
></P
><P
>Иногда пользователи пытаются ввести операторы, применимые только к определённому домену. Это возможно, но вовсе не так полезно, как может показаться, ведь правила разрешения операторов применяются к базовому типу домена. Взгляните на этот пример: </P><PRE
CLASS="SCREEN"
>CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';</PRE
><P> В этом запросе не будет использоваться нововведённый оператор. При разборе запроса сначала будет проверено, есть ли оператор <TT
CLASS="TYPE"
>mytext</TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="TYPE"
>mytext</TT
> (см. <A
HREF="typeconv-oper.html#OP-RESOL-EXACT-UNKNOWN"
>Шаг 2.a</A
>), но это не так; затем будет рассмотрен базовый тип домена (<TT
CLASS="TYPE"
>text</TT
>) и проверено наличие оператора <TT
CLASS="TYPE"
>text</TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="TYPE"
>text</TT
> (см. <A
HREF="typeconv-oper.html#OP-RESOL-EXACT-DOMAIN"
>Шаг 2.b</A
>), и таковой действительно есть; в итоге строковое значение типа <TT
CLASS="TYPE"
>unknown</TT
> будет воспринято как <TT
CLASS="TYPE"
>text</TT
> и будет применён оператор <TT
CLASS="TYPE"
>text</TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="TYPE"
>text</TT
>. Единственный вариант задействовать нововведённый оператор &mdash; добавить явное приведение: </P><PRE
CLASS="SCREEN"
>SELECT * FROM mytable WHERE val = text 'foo';</PRE
><P> так, чтобы оператор <TT
CLASS="TYPE"
>mytext</TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="TYPE"
>text</TT
> был найден сразу, согласно правилу точного совпадения. Если дело доходит до правил наибольшего соответствия, они активно дискредитируют операторы доменных типов. Если бы они этого не делали, с таким оператором возникало бы слишком много ошибок разрешения операторов, потому что правила приведения всегда считают домен приводимым к базовому типу и наоборот, так что доменный оператор применялся бы во всех случаях, где применяется одноимённый оператор с базовым типом.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv-overview.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="typeconv-func.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Обзор</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Функции</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>