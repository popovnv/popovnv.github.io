<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Упаковывание связанных объектов в расширение</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Расширение SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Интерфейсы расширений для индексов"
HREF="xindex.html"><LINK
REL="NEXT"
TITLE="Инфраструктура сборки расширений"
HREF="extend-pgxs.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Интерфейсы расширений для индексов"
HREF="xindex.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 35. Расширение <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Инфраструктура сборки расширений"
HREF="extend-pgxs.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="EXTEND-EXTENSIONS"
>35.15. Упаковывание связанных объектов в расширение</A
></H1
><P
>Полезное расширение <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> обычно включает несколько объектов SQL; например, с появлением нового типа данных могут потребоваться новые функции, новые операторы и новые классы операторов. Все эти объекты удобно собрать в один пакет, с тем чтобы упростить управление базой данных. В <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> такие пакеты называются <I
CLASS="FIRSTTERM"
>расширениями</I
>. Чтобы определить расширение, вам понадобится как минимум <I
CLASS="FIRSTTERM"
>файл скрипта</I
> с командами <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>, создающими объекты расширения, и <I
CLASS="FIRSTTERM"
>управляющий файл</I
>, в котором определяются несколько базовых свойств самого расширения. Если расширение написано на C, в него обычно также включается файл разделяемой библиотеки, содержащий скомпилированный код. Обеспечив наличие этих файлов, загрузить их в базу данных можно простой командой <A
HREF="sql-createextension.html"
>CREATE EXTENSION</A
>.</P
><P
>Основное преимущество расширений по сравнению с обычным <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скриптом, загружающим множество <SPAN
CLASS="QUOTE"
>"разрозненных"</SPAN
> объектов в базу данных, состоит в том, что <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> будет понимать, что объекты расширения связаны вместе. Вы можете удалить все объекты одной командой <A
HREF="sql-dropextension.html"
>DROP EXTENSION</A
> (разрабатывать отдельный скрипт <SPAN
CLASS="QUOTE"
>"uninstall"</SPAN
> не требуется). Ещё полезнее то, что утилита <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> знает, что не нужно выгружать отдельные объекты, составляющие расширение &mdash; вместо этого она просто включит в архивный файл команду <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
>. Это кардинально упрощает миграцию на новую версию расширения, которая может содержать новые или другие объекты по сравнению с предыдущей версией. Заметьте, однако, что при загрузке такого архива в базу данных обязательно наличие скрипта, управляющего файла и других файлов расширения.</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не позволит удалить отдельный объект, содержащийся в расширении, кроме как при удалении всего расширения. Также имейте в виду, что вы можете изменить определение объекта, относящегося к расширению (например, командой <TT
CLASS="COMMAND"
>CREATE OR REPLACE FUNCTION</TT
> для функции), но изменённое определение не будет выгружено утилитой <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. Такие изменения обычно разумны, только если они параллельно отражаются в файле скрипта расширения. (Для таблиц, содержащих конфигурационные данные, предусмотрены специальные средства; см. ниже.)</P
><P
>Механизм расширений также предоставляет средства для поддержки дополнительных скриптов, призванных изменять определение объектов SQL, содержащихся в расширении. Например, если версия расширения 1.1, по сравнению с версией 1.0, добавляет одну функцию и изменяет тело другой функции, автор расширения может предоставить <I
CLASS="FIRSTTERM"
>скрипт обновления</I
>, который произведёт именно эти два изменения. Затем, воспользовавшись командой <TT
CLASS="COMMAND"
>ALTER EXTENSION UPDATE</TT
>, можно будет применить эти изменения и отследить, какая версия расширения фактически установлена в заданной базе данных.</P
><P
>Типы SQL-объектов, которые могут быть членами расширения, перечислены в описании <A
HREF="sql-alterextension.html"
>ALTER EXTENSION</A
>. Не могут быть его членами, в частности, объекты уровня кластера, такие как базы данных, роли и табличные пространства, так как расширение существует только в рамках одной базы данных. (Скрипту расширения не запрещается создавать такие объекты, но если он сделает это, они не будут считаться частью расширения.) Также заметьте, что несмотря на то, что таблица может быть членом расширения, её подчинённые объекты, такие как индексы, непосредственными членами расширения считаться не будут. Ещё один важный момент — схемы могут принадлежать расширениям, но не наоборот; поэтому расширение имеет неполное имя и не существует <SPAN
CLASS="QUOTE"
>"внутри"</SPAN
> какой-либо схемы. Однако объекты-члены расширения, будут относиться к схемам, если это уместно для их типов. Сами расширения могут иметь, а могут не иметь основания владеть схемами, к которым относятся объекты-члены расширения.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN57226"
>35.15.1. Файлы расширений</A
></H2
><P
>Команда <A
HREF="sql-createextension.html"
>CREATE EXTENSION</A
> задействует управляющий файл расширения, который должен называться по имени расширения, с суффиксом <TT
CLASS="LITERAL"
>.control</TT
>, и должен быть помещён в каталог сервера <TT
CLASS="LITERAL"
>SHAREDIR/extension</TT
>. Должен быть также ещё минимум один <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скрипт, с именем, соответствующим шаблону <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>расширение</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>версия</I
></TT
>.sql</TT
> (например, <TT
CLASS="LITERAL"
>foo--1.0.sql</TT
> для версии <TT
CLASS="LITERAL"
>1.0</TT
> расширения <TT
CLASS="LITERAL"
>foo</TT
>). По умолчанию скрипт(ы) также помещается в каталог <TT
CLASS="LITERAL"
>SHAREDIR/extension</TT
>; но в управляющем файле можно задать и другой каталог.</P
><P
>Формат управляющего файла расширения не отличается от формата <TT
CLASS="FILENAME"
>postgresql.conf</TT
>, а именно представляет собой список присвоений <TT
CLASS="REPLACEABLE"
><I
>имя_параметра</I
></TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="REPLACEABLE"
><I
>значение</I
></TT
>, по одному в строке. В нём также допускаются пустые строки и комментарии, начинающиеся с <TT
CLASS="LITERAL"
>#</TT
>. Все значения, отличные от единственного слова или числа, в нём должны заключаться в кавычки.</P
><P
>В управляющем файле могут устанавливаться следующие параметры:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>directory</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Каталог, содержащий <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скрипт(ы) расширения. Если только не задан абсолютный путь, это имя рассматривается относительно каталога сервера <TT
CLASS="LITERAL"
>SHAREDIR</TT
>. По умолчанию подразумевается указание <TT
CLASS="LITERAL"
>directory = 'extension'</TT
>.</P
></DD
><DT
><TT
CLASS="VARNAME"
>default_version</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Версия расширения по умолчанию (та, которая будет установлена, если в <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> не будет указана никакая версия). Хотя этот параметр можно опустить, это приведёт к ошибке в <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> без явного указания <TT
CLASS="LITERAL"
>VERSION</TT
>, что вряд ли будет желаемым поведением.</P
></DD
><DT
><TT
CLASS="VARNAME"
>comment</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Комментарий (произвольная строка) к расширению. Комментарий также можно задать посредством команды <A
HREF="sql-comment.html"
>COMMENT</A
> в файле скрипта.</P
></DD
><DT
><TT
CLASS="VARNAME"
>encoding</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Кодировка символов, используемая в файлах скриптов. Её следует указать, если эти файлы содержат символы не из набора ASCII. По умолчанию предполагается, что эти файлы содержат текст в кодировке базы данных.</P
></DD
><DT
><TT
CLASS="VARNAME"
>module_pathname</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Значение этого параметра будет подставляться вместо каждого вхождения <TT
CLASS="LITERAL"
>MODULE_PATHNAME</TT
> в скриптах. Если этот параметр не задан, подстановка не производится. Обычно для этого параметра устанавливается значение <TT
CLASS="LITERAL"
>$libdir/<TT
CLASS="REPLACEABLE"
><I
>имя_разделяемой_библиотеки</I
></TT
></TT
>, а затем в командах <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> для функций на языке C указывается <TT
CLASS="LITERAL"
>MODULE_PATHNAME</TT
>, чтобы в скриптах не приходилось жёстко задавать имя разделяемой библиотеки.</P
></DD
><DT
><TT
CLASS="VARNAME"
>requires</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Список имён расширений, от которых зависит данное, например, <TT
CLASS="LITERAL"
>requires = 'foo, bar'</TT
>. Эти расширения должны быть уже установлены, прежде чем можно будет установить данное.</P
></DD
><DT
><TT
CLASS="VARNAME"
>superuser</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>Если этот параметр имеет значение <TT
CLASS="LITERAL"
>true</TT
> (по умолчанию), только суперпользователи смогут создать это расширение или обновить его до новой версии. Если он равен <TT
CLASS="LITERAL"
>false</TT
>, для этого будет достаточно прав, необходимых для выполнения команд в установочном скрипте или скрипте обновления.</P
></DD
><DT
><TT
CLASS="VARNAME"
>relocatable</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>Расширение является <I
CLASS="FIRSTTERM"
>перемещаемым</I
>, если относящиеся к нему объекты после создания расширения можно переместить в другую схему. По умолчанию подразумевается <TT
CLASS="LITERAL"
>false</TT
>, то есть расширение не считается перемещаемым. Подробнее об этом рассказывается ниже.</P
></DD
><DT
><TT
CLASS="VARNAME"
>schema</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>Этот параметр может задаваться только для неперемещаемых расширений. Если он задан, расширение можно будет загрузить только в указанную схему и не в какую другую. Подробнее об этом рассказывается ниже.</P
></DD
></DL
></DIV
><P
>Помимо главного управляющего файла <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>расширение</I
></TT
>.control</TT
>, расширение может включать дополнительные управляющие файлы с именами вида <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>расширение</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>версия</I
></TT
>.control</TT
>. Если они присутствуют, они должны находиться в том же каталоге, что и основной скрипт. Дополнительные управляющие файлы имеют тот же формат, что и основной. Любые параметры, заданные в дополнительном управляющем файле, переопределяют параметры основного файла, когда выполняется установка этой версии расширения или обновление до неё. Однако параметры <TT
CLASS="VARNAME"
>directory</TT
> и <TT
CLASS="VARNAME"
>default_version</TT
> в дополнительных управляющих файлах задать нельзя.</P
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скрипты расширений могут содержать любые команды SQL, за исключением команд управления транзакциями (<TT
CLASS="COMMAND"
>BEGIN</TT
>, <TT
CLASS="COMMAND"
>COMMIT</TT
> и т. д.) и команд, которые не могут выполняться внутри блока транзакции (например, <TT
CLASS="COMMAND"
>VACUUM</TT
>). Это объясняется тем, что эти скрипты неявно выполняются в блоке транзакции.</P
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-скрипты расширений также могут содержать строки, начинающиеся с <TT
CLASS="LITERAL"
>\echo</TT
>, и они будут игнорироваться (восприниматься как комментарии) механизмом расширений. Это часто используется для вывода ошибки в случае, если этот скрипт выполняется в <SPAN
CLASS="APPLICATION"
>psql</SPAN
>, а не загружается командой <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> (см. пример скрипта ниже). Если такое выполнение не предотвратить, пользователи могут случайно загрузить содержимое расширения как <SPAN
CLASS="QUOTE"
>"разрозненные"</SPAN
> объекты, а не как собственно расширение, и получить состояние, которое довольно сложно исправить.</P
><P
>Тогда как файлы скриптов могут содержать любые символы, допустимые в указанной кодировке, управляющие файлы могут содержать только ASCII-символы, так как указать кодировку этих файлов в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> нет никакой возможности. На практике это представляет проблему, только если вы хотите использовать символы не из набора ASCII в комментарии расширения. В таких случаях рекомендуется не использовать параметр <TT
CLASS="VARNAME"
>comment</TT
> в управляющем файле, а вместо этого задать комментарий командой <TT
CLASS="COMMAND"
>COMMENT ON EXTENSION</TT
> в файле скрипта.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN57344"
>35.15.2. Перемещаемость расширений</A
></H2
><P
>У пользователей часто возникает желание загрузить объекты, содержащиеся в расширении, в схему, отличную от той, что выбрал автор расширения. Насколько это поддерживает расширение, описывается одним из трёх уровней:</P
><P
></P
><UL
><LI
><P
>Полностью перемещаемое расширение может быть перемещено в другую схему в любое время, даже после того, как оно загружено в базу данных. Это осуществляется командой <TT
CLASS="COMMAND"
>ALTER EXTENSION SET SCHEMA</TT
>, которая автоматически переименовывает все объекты-члены расширения, перенося их в новую схему. Обычно это возможно, только если в расширении нет никаких внутренних предположений о том, в какой схеме находятся все его объекты. Кроме того, все объекты расширения должны находиться в одной исходной схеме (за исключением объектов, не принадлежащих схемам, как например, процедурные языки). Чтобы пометить расширение как полностью перемещаемое, установите <TT
CLASS="LITERAL"
>relocatable = true</TT
> в его управляющем файле.</P
></LI
><LI
><P
>Расширение может быть перемещаемым в момент установки, но не после. Обычно это имеет место, когда скрипту расширения необходимо явно ссылаться на целевую схему, например, устанавливая свойства <TT
CLASS="LITERAL"
>search_path</TT
> для функций SQL. Для такого расширения нужно задать <TT
CLASS="LITERAL"
>relocatable = false</TT
> в его управляющем файле и обращаться к целевой схеме в скрипте по псевдоимени <TT
CLASS="LITERAL"
>@extschema@</TT
>. Все вхождения этого псевдоимени будут заменены именем выбранной целевой схемы перед выполнением скрипта. Пользователь может выбрать целевую схему в указании <TT
CLASS="LITERAL"
>SCHEMA</TT
> команды <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
>.</P
></LI
><LI
><P
>Если расширение вовсе не поддерживает перемещение, установите в его управляющем файле <TT
CLASS="LITERAL"
>relocatable = false</TT
>, и также задайте в параметре <TT
CLASS="LITERAL"
>schema</TT
> имя предполагаемой целевой схемы. Это предотвратит использование указания <TT
CLASS="LITERAL"
>SCHEMA</TT
> команды <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
>, если только оно задаёт не то же имя, что определёно в управляющем файле. Этот выбор обычно необходим, если в расширении делаются внутренние предположения об именах схемы, которые нельзя свести к использованию псевдоимени <TT
CLASS="LITERAL"
>@extschema@</TT
>. Механизм подстановки <TT
CLASS="LITERAL"
>@extschema@</TT
> будет работать и в этом случае, хотя польза от него будет ограниченной, так как имя схемы определяется управляющим файлом.</P
></LI
></UL
><P
>В любом случае, при выполнении файла скрипта параметр <A
HREF="runtime-config-client.html#GUC-SEARCH-PATH"
>search_path</A
> изначально будет указывать на целевую схему; то есть, <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> делает то же, что и: </P><PRE
CLASS="PROGRAMLISTING"
>SET LOCAL search_path TO @extschema@;</PRE
><P> Это позволяет направить объекты, создаваемые скриптом, в целевую схему. Скрипт может изменить <TT
CLASS="VARNAME"
>search_path</TT
>, если пожелает, но обычно это нежелательно. Параметр <TT
CLASS="VARNAME"
>search_path</TT
> восстанавливает предыдущее значение по завершении <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
>.</P
><P
>Целевая схема определяется параметром <TT
CLASS="VARNAME"
>schema</TT
> (если он задан) в управляющем файле, либо указанием <TT
CLASS="LITERAL"
>SCHEMA</TT
> команды <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> (если оно присутствует), а в противном случае выбирается текущая схема для создания объектов по умолчанию (первая указанная в параметре <TT
CLASS="VARNAME"
>search_path</TT
> вызывающего). Когда используется параметр управляющего файла <TT
CLASS="VARNAME"
>schema</TT
>, целевая схема будет создана, если она ещё не существует, но в двух других случаях она должна уже существовать.</P
><P
>Если в параметре <TT
CLASS="VARNAME"
>requires</TT
> в файле управления указаны какие-либо расширения, необходимые для данного, их целевые схемы добавляются к начальному значению <TT
CLASS="VARNAME"
>search_path</TT
>. Благодаря этому, их объекты видны для скрипта нового расширения.</P
><P
>Хотя неперемещаемое расширение может содержать объекты, распределяемые по нескольким схемам, обычно желательно поместить все объекты, предназначенные для внешнего использования, в одну схему, назначенную целевой схемой расширения. Такой порядок будет хорошо согласовываться со значением <TT
CLASS="VARNAME"
>search_path</TT
> по умолчанию в процессе создания зависимых расширений.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN57385"
>35.15.3. Конфигурационные таблицы расширений</A
></H2
><P
>Некоторые расширения включают конфигурационные таблицы, содержащие данные, которые могут быть добавлены или изменены пользователем после установки расширения. Обычно, если таблица является частью расширения, ни определение таблицы, ни её содержимое не будет выгружаться утилитой <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>. Но это поведение нежелательно для конфигурационных таблиц — изменения, внесённые в них пользователем, должны выгружаться; в противном случае расширение будет вести себя по-другому, когда будет загружено вновь.</P
><P
>Чтобы решить эту проблему, скрипт расширения может пометить созданную им таблицу как конфигурационную, в результате чего <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> включит в выгружаемые данные содержимое таблицы (но не её определение). Для этого нужно вызвать функцию <CODE
CLASS="FUNCTION"
>pg_extension_config_dump(regclass, text)</CODE
> после создания таблицы, например так: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');</PRE
><P> Так можно пометить любое число таблиц.</P
><P
>Когда второй аргумент <CODE
CLASS="FUNCTION"
>pg_extension_config_dump</CODE
> — пустая строка, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> выгружает всё содержимое таблицы. Обычно это правильно, только если после создания скриптом расширения эта таблица изначально пуста. Если же в таблице оказывается смесь начальных данных и данных, добавленных пользователем, во втором аргументе <CODE
CLASS="FUNCTION"
>pg_extension_config_dump</CODE
> передаётся условие <TT
CLASS="LITERAL"
>WHERE</TT
>, которое отфильтровывает данные, подлежащие выгрузке. Например, имея таблицу, созданную таким образом: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</PRE
><P> можно сделать так, чтобы поле <TT
CLASS="STRUCTFIELD"
>standard_entry</TT
> содержало true только для строк, создаваемых скриптом расширения.</P
><P
>В более сложных ситуациях, когда пользователи могут модифицировать и изначально существовавшие строки, можно создать триггеры для конфигурационной таблицы, которые корректно пометят изменённые строки.</P
><P
>Условие фильтра, связанное с конфигурационной таблицей, можно изменить, повторно вызвав <CODE
CLASS="FUNCTION"
>pg_extension_config_dump</CODE
>. (Обычно это находит применение в скрипте обновления расширения.) Единственный способ обозначить, что некоторая таблица более не является конфигурационной — разорвать её связь с расширением командой <TT
CLASS="COMMAND"
>ALTER EXTENSION ... DROP TABLE</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN57406"
>35.15.4. Обновление расширений</A
></H2
><P
>Один из плюсов механизма расширений заключается в том, что он предоставляет удобные способы управления обновлениями SQL-команд, определяющих объекты расширения. В частности, каждой выпускаемой версии установочного скрипта расширения назначается имя или номер версии. Кроме того, если вы хотите, чтобы пользователи могли динамически обновлять одну версию расширения до другой, вы должны предоставить <I
CLASS="FIRSTTERM"
>скрипты обновления</I
>, которые внесут необходимые изменения для перехода от старой версии к новой. Скриптам обновлений назначаются имена, соответствующие шаблону <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>расширение</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>старая_версия</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>новая_версия</I
></TT
>.sql</TT
> (например, <TT
CLASS="LITERAL"
>foo--1.0--1.1.sql</TT
> будет содержать команды, меняющие версию <TT
CLASS="LITERAL"
>1.0</TT
> расширения <TT
CLASS="LITERAL"
>foo</TT
> на версию <TT
CLASS="LITERAL"
>1.1</TT
>).</P
><P
>С условием, что имеется подходящий скрипт расширения, команда <TT
CLASS="COMMAND"
>ALTER EXTENSION UPDATE</TT
> обновит установленное расширение до указанной новой версии. Скрипт обновления запускается в том же окружении, которое организует команда <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> для установочных скриптов: в частности, <TT
CLASS="VARNAME"
>search_path</TT
> устанавливается таким же образом, а любые новые объекты, созданные скриптом, автоматически добавляются в расширение.</P
><P
>Если у расширения есть дополнительные управляющие файлы, для скрипта обновления применяются те параметры, которые связаны с целевой (новой) версией скрипта.</P
><P
>Механизм обновления может использоваться для решения важной особой задачи: преобразование <SPAN
CLASS="QUOTE"
>"разрозненной"</SPAN
> коллекции объектов в расширение. До того как механизм расширений появился в <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> (в версии 9.1), многие писали модули разрешений, которые просто создавали множество неупакованных объектов. Но если у нас уже есть база данных с такими объектами, как их можно преобразовать в правильно упакованное расширение? Один из вариантов — удалить их и затем выполнить простую команду <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
>, но это нежелательно, если у объектов есть зависимости (например, если в таблицах есть колонки типа данных, созданного расширением). Чтобы исправить эту ситуацию, можно создать пустое расширение, затем с помощью команды <TT
CLASS="COMMAND"
>ALTER EXTENSION ADD</TT
> добавить в него каждый существующий объект, и наконец, создать все новые объекты, которые есть в текущей версии расширения, но отсутствуют в неупакованном варианте. <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> поддерживает этот сценарий предложением <TT
CLASS="LITERAL"
>FROM</TT
> <TT
CLASS="REPLACEABLE"
><I
>старая_версия</I
></TT
>, с которым она не будет запускать обычный установочный скрипт для целевой версии, а запустит вместо этого скрипт обновления с именем <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>расширение</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>старая_версия</I
></TT
>--<TT
CLASS="REPLACEABLE"
><I
>новая_версия</I
></TT
>.sql</TT
>. В качестве имени <TT
CLASS="REPLACEABLE"
><I
>старая_версия</I
></TT
> автор расширения может выбрать любое фиктивное имя, но обычно задаётся <TT
CLASS="LITERAL"
>unpackaged</TT
>. Если у вас несколько предыдущих версий, которые нужно привести к стилю расширения, выберите разные фиктивные имена версий, чтобы различить их.</P
><P
><TT
CLASS="COMMAND"
>ALTER EXTENSION</TT
> также может выполнять последовательности скриптов обновления для получения запрошенной версии. Например, если имеются только скрипты <TT
CLASS="LITERAL"
>foo--1.0--1.1.sql</TT
> и <TT
CLASS="LITERAL"
>foo--1.1--2.0.sql</TT
>, <TT
CLASS="COMMAND"
>ALTER EXTENSION</TT
> будет применять их по порядку, если при установленной версии <TT
CLASS="LITERAL"
>1.0</TT
> запрошено обновлении до версии <TT
CLASS="LITERAL"
>2.0</TT
>.</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> не делает никаких предположений о свойствах имён версий: например, он не знает, следует ли версия <TT
CLASS="LITERAL"
>1.1</TT
> за <TT
CLASS="LITERAL"
>1.0</TT
>. Он просто сопоставляет имена имеющихся версий и следует пути, который требует применить как можно меньше скриптов обновлений. (Именем версии на самом деле может быть любая строка, которая не содержит <TT
CLASS="LITERAL"
>--</TT
> и при этом не начинается и не заканчивается символом <TT
CLASS="LITERAL"
>-</TT
>.)</P
><P
>Иногда бывают полезны скрипты <SPAN
CLASS="QUOTE"
>"понижения версии"</SPAN
>, например, <TT
CLASS="LITERAL"
>foo--1.1--1.0.sql</TT
>, которые позволяют откатить изменения, связанные с версией <TT
CLASS="LITERAL"
>1.1</TT
>. Если вы применяете их, учтите, что есть вероятность неожиданного выполнения такого скрипта, если он окажется в кратчайшем пути. Рискованная ситуация возникает при наличии скрипта обновления по <SPAN
CLASS="QUOTE"
>"короткому пути"</SPAN
>, который перепрыгивает через несколько версий, и скрипта понижения версии до начальной точки первого скрипта. В результате может получиться так, что понижение версии с последующим обновлением по короткому пути окажется на несколько шагов короче, чем последовательное повышение версии. Если скрипт понижения версии удаляет какие-либо незаменимые объекты, это может привести к нежелательным результатам.</P
><P
>Чтобы убедиться, что при обновлении не будет выбран нежелательный путь, воспользуйтесь этой командой: </P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM pg_extension_update_paths('<TT
CLASS="REPLACEABLE"
><I
>имя_расширения</I
></TT
>');</PRE
><P> Она показывает каждую пару различных известных имён версий для указанного расширения, вместе с последовательностью обновления, которая будет выбрана для перехода от одной версии к другой, либо <TT
CLASS="LITERAL"
>NULL</TT
>, если путь обновления не находится. Путь выводится в текстовом виде с разделителями <TT
CLASS="LITERAL"
>--</TT
>. Если вы предпочитаете формат массива, вы можете применить <TT
CLASS="LITERAL"
>regexp_split_to_array(path,'--')</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN57461"
>35.15.5. Пример расширения</A
></H2
><P
>Здесь представлен полный пример расширения, в котором средствами исключительно <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> реализуется составной тип с двумя элементами, который может сохранить в своих слотах значения любого типа, названные <SPAN
CLASS="QUOTE"
>"k"</SPAN
> и <SPAN
CLASS="QUOTE"
>"v"</SPAN
>. Для хранения все значения переводятся в текстовый формат (если они имеют другой формат).</P
><P
>Файл скрипта <TT
CLASS="FILENAME"
>pair--1.0.sql</TT
> выглядит так: </P><PRE
CLASS="PROGRAMLISTING"
>-- прервать выполнение, если скрипт запущен в psql, а не командой CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~&gt; (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~&gt; (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);</PRE
><P></P
><P
>Управляющий файл <TT
CLASS="FILENAME"
>pair.control</TT
> выглядит так: </P><PRE
CLASS="PROGRAMLISTING"
># pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true</PRE
><P></P
><P
>Хотя вам вряд ли понадобится сборочный файл, только для того, чтобы установить эти два файла в нужный каталог, вы можете использовать <TT
CLASS="FILENAME"
>Makefile</TT
> следующего содержания: </P><PRE
CLASS="PROGRAMLISTING"
>EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</PRE
><P> Этот Makefile опирается на инфраструктуру <ACRONYM
CLASS="ACRONYM"
>PGXS</ACRONYM
>, которая описывается в <A
HREF="extend-pgxs.html"
>Разделе 35.16</A
>. С ним команда <TT
CLASS="LITERAL"
>make install</TT
> установит управляющий файл и скрипт в правильный каталог, который определит <SPAN
CLASS="APPLICATION"
>pg_config</SPAN
>.</P
><P
>Когда эти файлы будут установлены, выполните команду <A
HREF="sql-createextension.html"
>CREATE EXTENSION</A
>, чтобы загрузить объекты в определённую базу данных.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xindex.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="extend-pgxs.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Интерфейсы расширений для индексов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Инфраструктура сборки расширений</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>