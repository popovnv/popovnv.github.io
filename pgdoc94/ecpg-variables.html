<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Использование переменных среды</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="ECPG — встраиваемый SQL в C"
HREF="ecpg.html"><LINK
REL="PREVIOUS"
TITLE="Запуск команд SQL"
HREF="ecpg-commands.html"><LINK
REL="NEXT"
TITLE="Динамический SQL"
HREF="ecpg-dynamic.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Запуск команд SQL"
HREF="ecpg-commands.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="ecpg.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 33. <SPAN
CLASS="APPLICATION"
>ECPG</SPAN
> — встраиваемый <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> в C</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Динамический SQL"
HREF="ecpg-dynamic.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ECPG-VARIABLES"
>33.4. Использование переменных среды</A
></H1
><P
>В <A
HREF="ecpg-commands.html"
>Разделе 33.3</A
> вы увидели, как можно выполнять операторы SQL в программе со встраиваемым SQL. Некоторые из этих операторов использовали только фиксированные значения и не давали возможности вставлять в операторы произвольные значения или обрабатывать значения, возвращённые запросом. Операторы такого вида не очень полезны в реальных приложениях. В этом разделе подробно описывается, как можно передавать данные между программой на C и встраиваемыми операторами SQL, используя простой механизм, так называемые <I
CLASS="FIRSTTERM"
>переменные среды</I
>. В программе со встраиваемым SQL мы считаем SQL-операторы <I
CLASS="FIRSTTERM"
>внедрёнными</I
> в код программы на C, <I
CLASS="FIRSTTERM"
>языке среды</I
>. Таким образом, переменные программы на C называются <I
CLASS="FIRSTTERM"
>переменными среды</I
>.</P
><P
>Ещё один способ передать значения данных между сервером PostgreSQL и приложениями ECPG заключается в использовании дескрипторов SQL, как описано в <A
HREF="ecpg-descriptors.html"
>Раздел 33.7</A
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-VARIABLES-OVERVIEW"
>33.4.1. Обзор</A
></H2
><P
>Передавать данные между программой C и операторами SQL во встраиваемом SQL очень просто. Вместо того, чтобы вставлять данные в оператор, что влечёт дополнительные усложнения, в частности нужно правильно заключать значения в кавычки, можно просто записать имя переменной C в операторе SQL, предварив его двоеточием. Например: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);</PRE
><P> Этот оператор обращается к двум переменным C с именами <TT
CLASS="VARNAME"
>v1</TT
> и <TT
CLASS="VARNAME"
>v2</TT
> и также использует обычную строковую константу SQL, показывая тем самым, что можно свободно сочетать разные виды данных.</P
><P
>Этот метод включения переменных C в операторы SQL работает везде, где оператор SQL принимает выражение значения.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-DECLARE-SECTIONS"
>33.4.2. Секции объявлений</A
></H2
><P
>Чтобы передать данные из программы в базу данных, например, в виде параметров запроса, либо получить данные из базы данных в программе, переменные C, которые должны содержать эти данные, нужно объявить в специально помеченных секциях, чтобы препроцессор встраиваемого SQL знал о них.</P
><P
>Секция начинается с: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;</PRE
><P> и заканчивается командой: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL END DECLARE SECTION;</PRE
><P> Между этими строками должны располагаться обычные объявления переменных C, например: </P><PRE
CLASS="PROGRAMLISTING"
>int   x = 4;
char  foo[16], bar[16];</PRE
><P> Как здесь показано, переменной можно присвоить начальное значение. Область видимости переменной определяется расположением секции, в которой она объявляется в программе. Вы также можете объявить переменную следующим образом (при этом неявно создаётся секция объявлений): </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL int i = 4;</PRE
><P> Вы можете включать в программу столько секций объявлений, сколько захотите.</P
><P
>Эти объявления выводятся в результирующий файл как объявления обычных переменных C, так что эти переменные не нужно объявлять снова. Переменные, которые не предназначены для использования в командах SQL, можно объявить как обычно вне этих специальных секций.</P
><P
>Определение структуры или объединения тоже должно размещаться в секции <TT
CLASS="LITERAL"
>DECLARE</TT
>. В противном случае препроцессор не сможет воспринять эти типы, так как не будет знать их определения.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-RETRIEVING"
>33.4.3. Получение результатов запроса</A
></H2
><P
>Теперь вы умеете передавать данные, подготовленные вашей программой, в команду SQL. Но как получить результаты запроса? Для этой цели во встраиваемом SQL есть особые вариации обычных команд <TT
CLASS="COMMAND"
>SELECT</TT
> и <TT
CLASS="COMMAND"
>FETCH</TT
>. У этих команд есть специальное предложение <TT
CLASS="LITERAL"
>INTO</TT
>, определяющее, в какие переменные среды будут помещены получаемые значения. <TT
CLASS="COMMAND"
>SELECT</TT
> используется для запросов, возвращающих только одну строку, а <TT
CLASS="COMMAND"
>FETCH</TT
> применяется с курсором для запросов, возвращающих несколько строк.</P
><P
>Пример: </P><PRE
CLASS="PROGRAMLISTING"
>/*
 * предполагается существование такой таблицы:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;</PRE
><P> Предложение <TT
CLASS="LITERAL"
>INTO</TT
> размещается между списком выборки и предложением <TT
CLASS="LITERAL"
>FROM</TT
>. Число элементов в списке выборки должно равняться числу элементов в списке после <TT
CLASS="LITERAL"
>INTO</TT
> (также называемом целевым списком).</P
><P
>Следующий пример демонстрирует использование команды <TT
CLASS="COMMAND"
>FETCH</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);</PRE
><P> Здесь предложение <TT
CLASS="LITERAL"
>INTO</TT
> размещается после всех остальных обычных предложений.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-VARIABLES-TYPE-MAPPING"
>33.4.4. Сопоставление типов</A
></H2
><P
>Когда приложения ECPG передают данные между сервером PostgreSQL и программой на C, например, получая результаты запроса с сервера или выполняя операторы SQL с входными параметрам, эти данные должны преобразовываться из типов PostgreSQL в типы переменных языка среды (а именно типы языка C) и наоборот. Одно из главных качеств ECPG состоит в том, что в большинстве случаев он делает это автоматически.</P
><P
>В этом отношении можно выделить два вида типов данных. К первому относятся простые типы данных PostgreSQL, такие как <TT
CLASS="TYPE"
>integer</TT
> и <TT
CLASS="TYPE"
>text</TT
>, которые приложение может непосредственно читать и писать. С другими типами данных, такими как <TT
CLASS="TYPE"
>timestamp</TT
> и <TT
CLASS="TYPE"
>numeric</TT
>, можно работать только через специальные функции; см. <A
HREF="ecpg-variables.html#ECPG-SPECIAL-TYPES"
>Подраздел 33.4.4.2</A
>.</P
><P
>В <A
HREF="ecpg-variables.html#ECPG-DATATYPE-HOSTVARS-TABLE"
>Таблице 33-1</A
> показано, как типы данных PostgreSQL соответствуют типам данных C. Когда нужно передать или получить значение определённого типа данных PostgreSQL, вы должны объявить переменную C соответствующего типа C в секции объявлений.</P
><DIV
CLASS="TABLE"
><A
NAME="ECPG-DATATYPE-HOSTVARS-TABLE"
></A
><P
><B
>Таблица 33-1. Соответствие между типами данных PostgreSQL и типами переменных C</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Тип данных PostgreSQL</TH
><TH
>Тип переменной среды</TH
></TR
></THEAD
><TBODY
><TR
><TD
>                    <TT
CLASS="TYPE"
>smallint</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>short</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>integer</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>bigint</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>long long int</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>decimal</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>decimal</TT
>
                    <A
NAME="ECPG-DATATYPE-TABLE-FN"
HREF="#FTN.ECPG-DATATYPE-TABLE-FN"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>numeric</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>numeric</TT
>
                    <A
HREF="ecpg-variables.html#FTN.ECPG-DATATYPE-TABLE-FN"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>real</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>float</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>double precision</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>double</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>smallserial</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>short</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>serial</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>int</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>bigserial</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>long long int</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>oid</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>unsigned int</TT
>
                  </TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>character(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>, <TT
CLASS="TYPE"
>varchar(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>, <TT
CLASS="TYPE"
>text</TT
></TD
><TD
><TT
CLASS="TYPE"
>char[<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>+1]</TT
>, <TT
CLASS="TYPE"
>VARCHAR[<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>+1]</TT
><A
NAME="AEN45248"
HREF="#FTN.AEN45248"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
></TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>name</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>char[NAMEDATALEN]</TT
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>timestamp</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>timestamp</TT
>
                    <A
HREF="ecpg-variables.html#FTN.ECPG-DATATYPE-TABLE-FN"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>interval</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>interval</TT
>
                    <A
HREF="ecpg-variables.html#FTN.ECPG-DATATYPE-TABLE-FN"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>date</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>date</TT
>
                    <A
HREF="ecpg-variables.html#FTN.ECPG-DATATYPE-TABLE-FN"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
                  </TD
></TR
><TR
><TD
>                    <TT
CLASS="TYPE"
>boolean</TT
>
                  </TD
><TD
>                    <TT
CLASS="TYPE"
>bool</TT
>
                    <A
NAME="AEN45279"
HREF="#FTN.AEN45279"
><SPAN
CLASS="footnote"
>[c]</SPAN
></A
>
                  </TD
></TR
></TBODY
><TR
><TD
COLSPAN="2"
>Примечания:<BR><A
NAME="FTN.ECPG-DATATYPE-TABLE-FN"
>a. </A
>С этим типом можно работать только через специальные функции; см. <A
HREF="ecpg-variables.html#ECPG-SPECIAL-TYPES"
>Подраздел 33.4.4.2</A
>.<BR><A
NAME="FTN.AEN45248"
>b. </A
>объявляется в <TT
CLASS="FILENAME"
>ecpglib.h</TT
><BR><A
NAME="FTN.AEN45279"
>c. </A
>объявляется в <TT
CLASS="FILENAME"
>ecpglib.h</TT
> при отсутствии стандартного объявления<BR></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="ECPG-CHAR"
>33.4.4.1. Работа с символьными строками</A
></H3
><P
>Для обработки типов символьных строк SQL, таких как <TT
CLASS="TYPE"
>varchar</TT
> и <TT
CLASS="TYPE"
>text</TT
>, предлагаются два варианта объявления переменных среды.</P
><P
>Первый способ заключается в использовании <TT
CLASS="TYPE"
>char[]</TT
>, массива <TT
CLASS="TYPE"
>char</TT
>, как чаще всего и представляются символьные данные в C. </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;</PRE
><P> Заметьте, что о длине этого массива вы должны подумать сами. Если вы укажете данную переменную среды в качестве целевой переменной запроса, возвращающего строку длиннее 49 символов, произойдёт переполнение буфера.</P
><P
>В качестве другого подхода можно использовать специальный тип <TT
CLASS="TYPE"
>VARCHAR</TT
>, представленный в ECPG. Определение массива типа <TT
CLASS="TYPE"
>VARCHAR</TT
> преобразуется в структуру (<TT
CLASS="TYPE"
>struct</TT
>) с собственным именем для каждой переменной. Объявление вида: </P><PRE
CLASS="PROGRAMLISTING"
>VARCHAR var[180];</PRE
><P> преобразуется в: </P><PRE
CLASS="PROGRAMLISTING"
>struct varchar_var { int len; char arr[180]; } var;</PRE
><P> Член структуры <TT
CLASS="STRUCTFIELD"
>arr</TT
> содержит строку, включающую завершающий нулевой байт. Таким образом, чтобы сохранить строку в переменной типа <TT
CLASS="TYPE"
>VARCHAR</TT
>, эта переменная должна быть объявлена с длиной, учитывающей завершающий нулевой байт. Член структуры <TT
CLASS="STRUCTFIELD"
>len</TT
> содержит длину строки, сохранённой в <TT
CLASS="STRUCTFIELD"
>arr</TT
>, без завершающего нулевого байта. Когда на вход запросу подаётся переменная среды, у которой <TT
CLASS="LITERAL"
>strlen(arr)</TT
> отличается от <TT
CLASS="STRUCTFIELD"
>len</TT
>, применяется наименьшее значение.</P
><P
><TT
CLASS="TYPE"
>VARCHAR</TT
> можно записать в верхнем или нижнем регистре, но не в смешанном.</P
><P
>Переменные <TT
CLASS="TYPE"
>char</TT
> и <TT
CLASS="TYPE"
>VARCHAR</TT
> также могут содержать значения других типов SQL в их строковом представлении.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="ECPG-SPECIAL-TYPES"
>33.4.4.2. Обработка специальных типов данных</A
></H3
><P
>ECPG представляет некоторые особые типы, которые должны помочь вам легко оперировать некоторыми специальными типами данных PostgreSQL. В частности, в нём реализована поддержка типов <TT
CLASS="TYPE"
>numeric</TT
>, <TT
CLASS="TYPE"
>decimal</TT
>, <TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
> и <TT
CLASS="TYPE"
>interval</TT
>. Для этих типов нельзя подобрать полезное соответствие с примитивными типами среды (например, <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="TYPE"
>long long int</TT
> или <TT
CLASS="TYPE"
>char[]</TT
>), так как они имеют сложную внутреннюю структуру. Приложения, работающие с этими типами, должны объявлять переменные особых типов и работать с ними, применяя функции из библиотеки pgtypes. Эта библиотека, подробно описанная в <A
HREF="ecpg-pgtypes.html"
>Разделе 33.6</A
> содержит базовые функции для оперирования этими типами, чтобы вам не требовалось, например, передавать запрос SQL-серверу, когда нужно просто добавить интервал к значению времени.</P
><P
>Эти особые типы данных описаны в следующих подразделах. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <A
HREF="ecpg-pgtypes.html"
>Разделу 33.6</A
>.</P
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="AEN45322"
>33.4.4.2.1. timestamp, date</A
></H4
><P
>Для работы с переменными <TT
CLASS="TYPE"
>timestamp</TT
> в приложении ECPG применяется следующая схема.</P
><P
>Сначала в программу нужно включить заголовочный файл, чтобы получить определение типа <TT
CLASS="TYPE"
>timestamp</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>#include &lt;pgtypes_timestamp.h&gt;</PRE
><P></P
><P
>Затем объявите в секции объявлений переменную типа <TT
CLASS="TYPE"
>timestamp</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;</PRE
><P></P
><P
>Прочитав значение в эту переменную, выполняйте действия с ним, используя функции в библиотеке pgtypes. В следующем примере значение <TT
CLASS="TYPE"
>timestamp</TT
> преобразуется в текстовый вид (ASCII) с помощью функции <CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_to_asc()</CODE
>: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));</PRE
><P> Этот пример выведет такой результат: </P><PRE
CLASS="SCREEN"
>ts = 2010-06-27 18:03:56.949343</PRE
><P></P
><P
>Таким же образом можно работать и с типом DATE. В программу нужно включить <TT
CLASS="FILENAME"
>pgtypes_date.h</TT
>, объявить переменную типа date, и затем можно будет преобразовать значение DATE в текстовый вид, используя функцию <CODE
CLASS="FUNCTION"
>PGTYPESdate_to_asc()</CODE
>. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <A
HREF="ecpg-pgtypes.html"
>Разделу 33.6</A
>.</P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="ECPG-TYPE-INTERVAL"
>33.4.4.2.2. interval</A
></H4
><P
>Принцип работы с типом <TT
CLASS="TYPE"
>interval</TT
> тот же, что и с типами <TT
CLASS="TYPE"
>timestamp</TT
> и <TT
CLASS="TYPE"
>date</TT
>, однако для значения типа <TT
CLASS="TYPE"
>interval</TT
> нужно явно выделить память. Другими словами, блок памяти для этой переменной должен размещаться в области кучи, а не в стеке.</P
><P
>Пример программы: </P><PRE
CLASS="PROGRAMLISTING"
>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pgtypes_interval.h&gt;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</PRE
><P></P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="ECPG-TYPE-NUMERIC-DECIMAL"
>33.4.4.2.3. numeric, decimal</A
></H4
><P
>Типы <TT
CLASS="TYPE"
>numeric</TT
> и <TT
CLASS="TYPE"
>decimal</TT
> обрабатываются так же, как и тип <TT
CLASS="TYPE"
>interval</TT
>: вы должны определить указатель, выделить некоторое пространство памяти в куче и обращаться к переменной, используя функции в библиотеке pgtypes. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <A
HREF="ecpg-pgtypes.html"
>Разделу 33.6</A
>.</P
><P
>Для типа <TT
CLASS="TYPE"
>decimal</TT
> никакие специальные функции не реализованы. Для дальнейшей обработки приложение должно преобразовать его в переменную <TT
CLASS="TYPE"
>numeric</TT
>, применив функцию из библиотеки pgtypes.</P
><P
>Следующий пример демонстрирует работу с переменными типов <TT
CLASS="TYPE"
>numeric</TT
> и <TT
CLASS="TYPE"
>decimal</TT
>. </P><PRE
CLASS="PROGRAMLISTING"
>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pgtypes_numeric.h&gt;

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* Преобразовать decimal в numeric, чтобы вывести десятичное значение. */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</PRE
><P></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="ECPG-VARIABLES-NONPRIMITIVE-C"
>33.4.4.3. Переменные среды для непримитивных типов</A
></H3
><P
>В качестве переменных среды также можно использовать массивы, определения типов, структуры и указатели.</P
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="ECPG-VARIABLES-ARRAYS"
>33.4.4.3.1. Массивы</A
></H4
><P
>Для применения массивов в качестве переменных среды есть два варианта использования. Во-первых, в массиве <TT
CLASS="TYPE"
>char[]</TT
> или <TT
CLASS="TYPE"
>VARCHAR[]</TT
> можно сохранить текстовую строку, как рассказывалось в <A
HREF="ecpg-variables.html#ECPG-CHAR"
>Подразделе 33.4.4.1</A
>. Во-вторых, в массив можно получить несколько строк из результата запроса, не используя курсор. Чтобы не применяя массивы, обработать результат запроса, состоящий из нескольких строк, нужно использовать курсор и команду <TT
CLASS="COMMAND"
>FETCH</TT
>. Но с переменными-массивами несколько строк можно получить сразу. Длина определяемого массива должна быть достаточной для размещения всех строк, иначе скорее всего произойдёт переполнение буфера.</P
><P
>Следующий пример сканирует системную таблицу <TT
CLASS="LITERAL"
>pg_database</TT
> и показывает все OID и имена доступных баз данных: </P><PRE
CLASS="PROGRAMLISTING"
>int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    /* Получить в массивы сразу несколько строк. */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</PRE
><P> Этот пример выводит следующий результат. (Точные значения зависят от локальных обстоятельств.) </P><PRE
CLASS="SCREEN"
>oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=</PRE
><P></P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="ECPG-VARIABLES-STRUCT"
>33.4.4.3.2. Структуры</A
></H4
><P
>Для получения значений сразу нескольких колонок можно применить структуру, имена членов которой совпадают с именами колонок результата запроса. Структура позволяет обрабатывать значения нескольких колонок в одной переменной среды.</P
><P
>Следующий пример получает значения OID, имена и размеры имеющихся баз данных из системной таблицы <TT
CLASS="LITERAL"
>pg_database</TT
>, используя при этом функцию <CODE
CLASS="FUNCTION"
>pg_database_size()</CODE
>. В этом примере переменная типа структуры <TT
CLASS="VARNAME"
>dbinfo_t</TT
> с членами, имена которых соответствуют именам всех колонок результата <TT
CLASS="LITERAL"
>SELECT</TT
>, применяется для получения одной строки результата без вовлечения в оператор <TT
CLASS="LITERAL"
>FETCH</TT
> нескольких переменных среды. </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* по достижении конца набора результатов прервать цикл while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Выбрать несколько колонок в одну структуру. */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* Напечатать члены структуры. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;</PRE
><P></P
><P
>Этот пример показывает следующий результат. (Точные значения зависят от локальных обстоятельств.) </P><PRE
CLASS="SCREEN"
>oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012</PRE
><P></P
><P
>Переменные среды типа структуры <SPAN
CLASS="QUOTE"
>"вбирают в себя"</SPAN
> столько колонок, сколько полей содержит структура. Значения дополнительных колонок можно присвоить другим переменным среды. Например, приведённую выше программу можно видоизменить следующим образом, разместив переменную <TT
CLASS="VARNAME"
>size</TT
> вне структуры: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* по достижении конца набора результатов прервать цикл while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Выбрать несколько колонок в одну структуру. */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* Напечатать члены структуры. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;</PRE
><P></P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="AEN45394"
>33.4.4.3.3. Определения типов</A
></H4
><P
>Чтобы сопоставить новые типы с уже существующими, используйте ключевое слово <TT
CLASS="LITERAL"
>typedef</TT
>. </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;</PRE
><P> Заметьте, что вы также можете написать: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL TYPE serial_t IS long;</PRE
><P> Это объявление не обязательно должно находиться в секции объявлений.</P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="AEN45400"
>33.4.4.3.4. Указатели</A
></H4
><P
>Вы можете объявлять указатели на самые распространённые типы. Учтите, однако, что указатели нельзя использовать в качестве целевых переменных запросов без автовыделения. За дополнительными сведениями об автовыделении обратитесь к <A
HREF="ecpg-descriptors.html"
>Разделу 33.7</A
>.</P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;</PRE
><P>
     </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-VARIABLES-NONPRIMITIVE-SQL"
>33.4.5. Обработка непримитивных типов данных SQL</A
></H2
><P
>В этом разделе описывается как работать с нескалярными и пользовательскими типами уровня SQL в приложениях ECPG. Заметьте, что этот подход отличается от использования переменных непримитивных типов, описанного в предыдущем разделе.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN45409"
>33.4.5.1. Массивы</A
></H3
><P
>Массивы уровня SQL в ECPG напрямую не поддерживаются. Невозможно просто сопоставить массив SQL переменной-массивом среды C. Это приводит к неопределённому поведению. Однако существуют обходные решения.</P
><P
>Если запрос обращается к отдельным <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>элементам</I
></SPAN
> массива, это избавляет от необходимости применять массивы в ECPG. В этом случае следует использовать переменную среды, имеющую тип, который можно сопоставить типу элемента. Например, если типом колонки является массив <TT
CLASS="TYPE"
>integer</TT
>, можно использовать переменную среды типа <TT
CLASS="TYPE"
>int</TT
>. Аналогично, если тип элемента — <TT
CLASS="TYPE"
>varchar</TT
> или <TT
CLASS="TYPE"
>text</TT
>, можно использовать переменную типа <TT
CLASS="TYPE"
>char[]</TT
> или <TT
CLASS="TYPE"
>VARCHAR[]</TT
>.</P
><P
>Предположим, что у нас есть таблица: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)</PRE
><P> Следующая программа получает 4-ый элемент массива и сохраняет его в переменной среды, имеющей тип <TT
CLASS="TYPE"
>int</TT
>: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;</PRE
><P> Этот пример выводит следующий результат: </P><PRE
CLASS="SCREEN"
>ii=4</PRE
><P></P
><P
>Чтобы сопоставить несколько элементов массива с несколькими элементами переменной-массивом среды, каждый элемент массива SQL нужно по отдельности связать с каждым элементом массива среды, например: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}</PRE
><P></P
><P
>Ещё раз обратите внимание, что в этом случае вариант </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* НЕПРАВИЛЬНО */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}</PRE
><P> не будет работать корректно, так как колонку с типом массива нельзя напрямую сопоставить с переменной-массивом среды.</P
><P
>Можно также применить обходное решение — хранить массивы в их внешнем строковом представлении в переменных среды типа <TT
CLASS="TYPE"
>char[]</TT
> или <TT
CLASS="TYPE"
>VARCHAR[]</TT
>. Более подробно это представление описывается в <A
HREF="arrays.html#ARRAYS-INPUT"
>Подразделе 8.15.2</A
>. Заметьте, это означает, что с таким массивом в программе нельзя будет работать естественным образом (без дополнительного разбора текстового представления).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN45433"
>33.4.5.2. Составные типы</A
></H3
><P
>Составные типы в ECPG напрямую не поддерживаются, но есть простое обходное решение. Для решения этой проблемы можно применить те же подходы, что были описаны выше для массивов: обращаться к каждому атрибуту по отдельности или использовать внешнее строковое представление.</P
><P
>Для следующих примеров предполагается, что существует такой тип и таблица: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );</PRE
><P> Самое очевидное решение заключается в обращении к каждому атрибуту по отдельности. Следующая программа получает данные из тестовой таблицы, выбирая атрибуты типа <TT
CLASS="TYPE"
>comp_t</TT
> по одному: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* Указать каждый элемент колонки составного типа в списке SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Выбрать каждый элемент колонки составного типа в переменную среды. */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;</PRE
><P></P
><P
>В развитие этого примера, переменные среды, в которые помещаются результаты команды <TT
CLASS="COMMAND"
>FETCH</TT
>, можно собрать в одну структуру. Подробнее переменные среды в форме структуры описываются в <A
HREF="ecpg-variables.html#ECPG-VARIABLES-STRUCT"
>Подразделе 33.4.4.3.2</A
>. Чтобы перейти к структуре, пример можно изменить как показано ниже. Переменные среды, <TT
CLASS="VARNAME"
>intval</TT
> и <TT
CLASS="VARNAME"
>textval</TT
>, становятся членами структуры <TT
CLASS="STRUCTNAME"
>comp_t</TT
>, и эта структура указывается в команде <TT
CLASS="COMMAND"
>FETCH</TT
>. </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* Поместить каждый элемент составного типа в список SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Поместить все значения списка SELECT в одну структуру. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;</PRE
><P> Хотя в команде <TT
CLASS="COMMAND"
>FETCH</TT
> используется структура, имена атрибутов в предложении <TT
CLASS="COMMAND"
>SELECT</TT
> задаются по одному. Это можно дополнительно улучшить, написав <TT
CLASS="LITERAL"
>*</TT
>, что будет обозначать все атрибуты значения составного типа. </P><PRE
CLASS="PROGRAMLISTING"
>...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Выбрать все значения в списке SELECT в одну структуру. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...</PRE
><P> Таким образом составные типы можно сопоставить со структурами практически прозрачно, хотя ECPG и не понимает составные типы.</P
><P
>Наконец, также можно сохранить значения составного типа в их внешнем строковом представлении в переменных среды типа <TT
CLASS="TYPE"
>char[]</TT
> или <TT
CLASS="TYPE"
>VARCHAR[]</TT
>. Однако при таком подходе нет простой возможности обращаться из программы к полям значения.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN45455"
>33.4.5.3. Пользовательские базовые типы</A
></H3
><P
>Определяемые пользователем базовые типы не поддерживаются ECPG напрямую. Для них можно использовать внешнее строковое представление и переменные среды типа <TT
CLASS="TYPE"
>char[]</TT
> или <TT
CLASS="TYPE"
>VARCHAR[]</TT
>, и это решение действительно будет подходящим и достаточным для большинства типов.</P
><P
>Следующий фрагмент кода демонстрирует использование типа данных <TT
CLASS="TYPE"
>complex</TT
> из примера в <A
HREF="xtypes.html"
>Разделе 35.11</A
>. Внешнее строковое представление этого типа имеет форму <TT
CLASS="LITERAL"
>(%lf,%lf)</TT
> и определено в функциях <CODE
CLASS="FUNCTION"
>complex_in()</CODE
> и <CODE
CLASS="FUNCTION"
>complex_out()</CODE
> в <A
HREF="xtypes.html"
>Разделе 35.11</A
>. Следующий пример вставляет значения комплексного типа <TT
CLASS="LITERAL"
>(1,1)</TT
> и <TT
CLASS="LITERAL"
>(3,3)</TT
> в колонки <TT
CLASS="LITERAL"
>a</TT
> и <TT
CLASS="LITERAL"
>b</TT
>, а затем выбирает их из таблицы. </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;</PRE
><P> Этот пример выводит следующий результат: </P><PRE
CLASS="SCREEN"
>a=(1,1), b=(3,3)</PRE
><P></P
><P
>Другое обходное решение состоит в том, чтобы избегать прямого использования пользовательских типов в ECPG, а вместо этого создать функцию или приведение, выполняющее преобразование между пользовательским типом и примитивным типом, который может обработать ECPG. Заметьте однако, что приведения типов, особенно неявные, нужно добавлять в систему типов очень осторожно.</P
><P
>Например: </P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;</PRE
><P> После такого определения следующий код </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));</PRE
><P> будет работать так же, как </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');</PRE
><P></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-INDICATORS"
>33.4.6. Индикаторы</A
></H2
><P
>Приведённые выше примеры никак не обрабатывали значения NULL. На самом деле, в примерах с извлечением данных возникнет ошибка, если они выберут из базы данных значение NULL. Чтобы можно было передавать значения NULL в базу данных или получать их из базы данных, вы должны добавить объявление второй переменной среды для каждой переменной среды, содержащей данные. Эта вторая переменная среды называется <I
CLASS="FIRSTTERM"
>индикатором</I
> и содержит флаг, показывающий, что в данных передаётся NULL, и при этом значение основной переменной среды игнорируется. Следующий пример демонстрирует правильную обработку значений NULL: </P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;</PRE
><P> Переменная индикатора <TT
CLASS="VARNAME"
>val_ind</TT
> будет равна нулю, если значение не NULL, или отрицательному числу, если NULL.</P
><P
>Индикатор выполняет ещё одну функцию: если он содержит положительное число, это означает, что значение не NULL, но оно было обрезано, когда сохранялось в переменной среды.</P
><P
>Если препроцессору <TT
CLASS="COMMAND"
>ecpg</TT
> передаётся аргумент <TT
CLASS="LITERAL"
>-r no_indicator</TT
>, он работает в режиме <SPAN
CLASS="QUOTE"
>"без индикатора"</SPAN
>. В этом режиме, если переменная индикатора не определена, значения NULL обозначаются (при вводе и выводе) для символьных строк пустой строкой, а для целочисленных типов наименьшим возможным значением этого типа (например, <TT
CLASS="SYMBOL"
>INT_MIN</TT
> для <TT
CLASS="TYPE"
>int</TT
>).</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="ecpg-commands.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="ecpg-dynamic.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Запуск команд SQL</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecpg.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Динамический SQL</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>