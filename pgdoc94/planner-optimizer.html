<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Планировщик/оптимизатор</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Документация по PostgreSQL 9.4.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Обзор внутреннего устройства PostgreSQL"
HREF="overview.html"><LINK
REL="PREVIOUS"
TITLE="Система правил PostgreSQL"
HREF="rule-system.html"><LINK
REL="NEXT"
TITLE="Исполнитель"
HREF="executor.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
NAME="creation"
CONTENT="2016-04-12T07:56:57"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Документация по PostgreSQL 9.4.1</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Система правил PostgreSQL"
HREF="rule-system.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Глава 47. Обзор внутреннего устройства PostgreSQL</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Исполнитель"
HREF="executor.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PLANNER-OPTIMIZER"
>47.5. Планировщик/оптимизатор</A
></H1
><P
>Задача <I
CLASS="FIRSTTERM"
>планировщика/оптимизатора</I
> — построить наилучший план выполнения. Определённый SQL-запрос (а значит, и дерево запроса) на самом деле можно выполнить самыми разными способами, при этом получая одни и те же результаты. Если это не требует больших вычислений, оптимизатор запросов будет перебирать все возможные варианты планов, чтобы в итоге выбрать тот, который должен выполниться быстрее остальных.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Замечание: </B
>В некоторых ситуациях рассмотрение всех возможных вариантов выполнения запросов занимает слишком много времени и памяти. В частности, это имеет место при выполнении запросов с большим количеством операций соединения. Поэтому, чтобы выбрать разумный (но не обязательно наилучший) план запроса за приемлемое время, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> использует <I
CLASS="FIRSTTERM"
>генетический оптимизатор запросов</I
> (см. <A
HREF="geqo.html"
>Главу 54</A
>), когда количество соединений превышает некоторый предел (см. <A
HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD"
>geqo_threshold</A
>).</P
></BLOCKQUOTE
></DIV
><P
>Процедура поиска лучшего плана на самом деле работает со структурами данных, называемыми <I
CLASS="FIRSTTERM"
>путями</I
>, которые представляют собой упрощённые схемы планов, содержащие минимум информации, необходимый планировщику для принятия решений. Когда наиболее выгодный план выбран, строится полноценное <I
CLASS="FIRSTTERM"
>дерево плана</I
>, которое и передаётся исполнителю. Оно описывает желаемый план выполнения достаточно подробно, чтобы исполнитель мог обработать его. В продолжении этого раздела мы будем считать, что планы и пути по сути одно и то же.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN94527"
>47.5.1. Выработка возможных планов</A
></H2
><P
>Сначала планировщик/оптимизатор вырабатывает планы для сканирования каждого отдельного отношения (таблицы), используемого в запросе. Множество возможных планов определяется в зависимости от наличия индексов в каждом отношении. Произвести последовательное сканирование отношения можно в любом случае, так что план последовательного сканирования создаётся всегда. Предположим, что для отношения создан индекс (например, индекс-B-дерево) и запрос содержит ограничение <TT
CLASS="LITERAL"
>отношение.атрибут ОПЕР константа</TT
>. Если окажется, что <TT
CLASS="LITERAL"
>отношение.атрибут</TT
> совпадает с ключом индекса-B-дерева и <TT
CLASS="LITERAL"
>ОПЕР</TT
> — один из операторов, входящих в <I
CLASS="FIRSTTERM"
>класс операторов</I
> индекса, создаётся ещё один план, c использованием индекса-B-дерева для чтения отношения. Если находятся другие индексы, ключи которых соответствуют ограничениям запроса, могут добавиться и другие планы. Планы сканирования индекса также создаются для индексов, если их порядок сортировки соответствует предложению <TT
CLASS="LITERAL"
>ORDER BY</TT
> (если оно есть), или этот порядок может быть полезен для соединения слиянием (см. ниже).</P
><P
>Если в запросе требуется соединить два или несколько отношений, после того, как будут определены все подходящие планы сканирования отдельных отношений, рассматриваются планы соединения. При этом возможны три стратегии соединения: <P
></P
></P><UL
><LI
><P
><I
CLASS="FIRSTTERM"
>соединение с вложенным циклом</I
>: Правое отношение сканируется один раз для каждой строки, найденной в левом отношении. Эту стратегию легко реализовать, но она может быть очень трудоёмкой. (Однако, если правое отношение можно сканировать по индексу, эта стратегия может быть удачной. Тогда значения из текущей строки левого отношения могут использоваться как ключи для сканирования по индексу справа.)</P
></LI
><LI
><P
><I
CLASS="FIRSTTERM"
>соединение слиянием</I
>: Каждое отношение сортируется по атрибутам соединения до начала соединения. Затем два отношения сканируются параллельно и соответствующие строки, объединяясь, формируют строки соединения. Этот тип соединения более привлекательный, так как каждое отношение сканируется только один раз. Требуемый порядок сортировки можно получить, либо добавив явный этап сортировки, либо просканировав отношение в нужном порядке, используя индекс по ключу соединения.</P
></LI
><LI
><P
><I
CLASS="FIRSTTERM"
>соединение по хешу</I
>: сначала сканируется правое отношение и формируется хеш-таблица, ключ в которой вычисляется по атрибутам соединения. Затем сканируется левое отношение и по тем же атрибутам в каждой строке вычисляется ключ для поиска в этой хеш-таблице соответствующих строк справа.</P
></LI
></UL
><P></P
><P
>Когда в запросе задействованы более двух отношений, окончательный результат должен быть получен из дерева с узлами соединения, имеющими по два входа. Планировщик рассматривает все возможные последовательности соединения и выбирает самую выгодную.</P
><P
>Если число задействованных в запросе отношений меньше <A
HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD"
>geqo_threshold</A
>, для поиска оптимальной последовательности соединений производится практически полный перебор. Планировщик отдаёт предпочтение соединениям между двумя отношениями, для которых есть соответствующее предложение соединения в условии <TT
CLASS="LITERAL"
>WHERE</TT
> (то есть, для которых находится ограничение вида <TT
CLASS="LITERAL"
>where табл1.атр1=табл2.атр2</TT
>). Пары соединения без подобного предложения рассматриваются, только если нет другого выбора, то есть когда для определённого отношения не находятся предложения соединения с каким-либо другим отношением. Планировщик рассматривает все возможные планы для каждой пары соединения и выбирает самый выгодный из них (по его оценке).</P
><P
>Если <TT
CLASS="VARNAME"
>geqo_threshold</TT
> превышается, последовательность соединений выбирается эвристическим путём, как описано в <A
HREF="geqo.html"
>Главе 54</A
>. В остальном процесс планирования тот же.</P
><P
>Законченное дерево плана содержит узлы сканирования по индексу или последовательного сканирования базовых отношений, плюс узлы соединения с вложенным циклом, соединения слиянием или соединения по хешу (если требуется), плюс, возможно, узлы дополнительных действий, например, сортировки или вычисления агрегатных функций. Большинство из этих узлов могут дополнительно производить <I
CLASS="FIRSTTERM"
>отбор</I
> (отбрасывать строки, не удовлетворяющие заданному логическому условию) и <I
CLASS="FIRSTTERM"
>расчёты</I
> (вычислять производный набор колонок по значениям заданных колонок, то есть вычислять скалярные выражения). Одна из задач планировщика — добавить условия отбора из предложения <TT
CLASS="LITERAL"
>WHERE</TT
> и вычисления требуемых выходных выражений к наиболее подходящим узлам дерева плана.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="rule-system.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="executor.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Система правил <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Исполнитель</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>